[
  {
    "user": "1",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Event implements Comparable{\n\n    @Override\n    public int compareTo(Object o) {\n        if (this.getTitle().compareTo( ((Event) o).getTitle() )!=0){\n            return this.getTitle().compareTo( ((Event) o).getTitle() );\n        }\n        else return this.getCategory().compareTo(((Event) o).getCategory());\n    }\n\n\n\n    private EventCategory category;\n    private String title;\n\n    public Event(String title, EventCategory category) {\n        if (title.equals( null ) || title.isEmpty() || category.equals( null )) throw new IllegalArgumentException(  );\n        this.category = category;\n        this.title = title;\n    }\n\n    public EventCategory getCategory() {\n        return category;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Event implements Comparable{\n\n    @Override\n    public int compareTo(Object o) {\n        if (this.getTitle().compareTo( ((Event) o).getTitle() )!=0){\n            return this.getTitle().compareTo( ((Event) o).getTitle() );\n        }\n        else return this.getCategory().compareTo(((Event) o).getCategory());\n    }\n\n\n\n    private EventCategory category;\n    private String title;\n\n    public Event(String title, EventCategory category) {\n        if (title.equals( null ) || title.isEmpty() || category.equals( null )) throw new IllegalArgumentException(  );\n        this.category = category;\n        this.title = title;\n    }\n\n    public EventCategory getCategory() {\n        return category;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "18",
    "end_line": "18",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "47",
    "end_line": "47",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "57",
    "end_line": "57",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "58",
    "end_line": "58",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "63",
    "end_line": "63",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "70",
    "end_line": "70",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "71",
    "end_line": "71",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "81",
    "end_line": "81",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "86",
    "end_line": "86",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "92",
    "end_line": "92",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 16.07.17.\n */\npublic class EventCatalogImpl implements EventCatalog {\n\n    private Map<Event, HashSet<Time>> catalog;\n\n    public EventCatalogImpl() {\n        this.catalog=new TreeMap<Event, HashSet<Time>>(  );\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n        if (e.equals( null ) || tSet.equals( null )) throw new IllegalArgumentException(  );\n        for (Time t:tSet) {\n            if (t.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (catalog.containsKey( e )) return false;\n        else{\n            HashSet<Time> times = new HashSet<Time>(  );\n            for (Time t: tSet) {\n                if ((int)t.getHour()>0 && (int)t.getMinute()>=0) {\n                    times.add( t );\n                }\n            }\n            catalog.put( e, times );\n            return true;\n        }\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event e, Time t) {\n        if (e.equals( null ) || t.equals( null )) throw new IllegalArgumentException(  );\n        HashSet<Time> times = catalog.get( e );\n        if (catalog.containsKey( e )){\n            if (times.contains( t )){\n                return false;\n            }\n            else {\n                times.add( t );\n                catalog.put( e, times );\n                return true;\n            }\n        }\n        else return false;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        if (catalog.containsKey( e )) return catalog.get( e );\n        else return null;\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        if (category.equals( null )) throw new IllegalArgumentException(  );\n        Map<Event, Set<Time>> result = new TreeMap<Event, Set<Time>>(  );\n        for (Event e: catalog.keySet()) {\n            if (e.getCategory()==category){\n                result.put( e, catalog.get( e ) );\n            }\n        }\n        if (result.size()!=0) return result;\n        else return Collections.emptyMap();\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event e) {\n        if (catalog.containsKey( e )) {\n            Set<Time> times = catalog.get( e );\n            catalog.remove( e );\n            return times;\n        }\n        else return null;\n    }\n\n    @Override\n    public boolean deleteTime(Event e, Time t) {\n        if (e.equals( null )|| t.equals( null )) throw new IllegalArgumentException(  );\n        if (catalog.containsKey( e ) && catalog.get( e ).contains( t )){\n            HashSet<Time> times = catalog.get( e );\n            times.remove( t );\n            return true;\n        }\n        else return false;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 16.07.17.\n */\npublic class Time {\n\n    private Integer hour;\n    private Integer minute;\n\n    public Time(Integer hour, Integer minute) {\n        if (hour<0 || hour>23 || minute<0 || minute>59) throw new IllegalArgumentException(  );\n        this.hour = hour;\n        this.minute = minute;\n    }\n\n    public Object getHour() {\n        return  hour;\n    }\n\n    public  Object getMinute() {\n        return  minute;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'23' is a magic number.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "28",
    "end_column": "28",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 16.07.17.\n */\npublic class Time {\n\n    private Integer hour;\n    private Integer minute;\n\n    public Time(Integer hour, Integer minute) {\n        if (hour<0 || hour>23 || minute<0 || minute>59) throw new IllegalArgumentException(  );\n        this.hour = hour;\n        this.minute = minute;\n    }\n\n    public Object getHour() {\n        return  hour;\n    }\n\n    public  Object getMinute() {\n        return  minute;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Event App",
    "message": "'59' is a magic number.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "53",
    "end_column": "53",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 16.07.17.\n */\npublic class Time {\n\n    private Integer hour;\n    private Integer minute;\n\n    public Time(Integer hour, Integer minute) {\n        if (hour<0 || hour>23 || minute<0 || minute>59) throw new IllegalArgumentException(  );\n        this.hour = hour;\n        this.minute = minute;\n    }\n\n    public Object getHour() {\n        return  hour;\n    }\n\n    public  Object getMinute() {\n        return  minute;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.List;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Adapter implements IProject {\n\n    private Project project;\n\n    public Adapter(String name, String description, double rate) {\n        if (name.equals( null )|| description.equals( null ) || name.isEmpty() || description.isEmpty() || rate<0) throw new IllegalArgumentException(  );\n        this.project=new Project( name, description, rate );\n    }\n\n    @Override\n    public void setTask(Task newTask) {\n        if (newTask.equals( null )) throw new IllegalArgumentException(  );\n        project.setTask( newTask );\n    }\n\n    @Override\n    public long getTotalCost() {\n        return project.getTotalCost();\n    }\n\n    @Override\n    public double getDuration() {\n        return project.getDuration();\n    }\n\n    @Override\n    public List<Deliverable> getDeliverables() {\n        return project.task.allDeliverables();\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.List;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Adapter implements IProject {\n\n    private Project project;\n\n    public Adapter(String name, String description, double rate) {\n        if (name.equals( null )|| description.equals( null ) || name.isEmpty() || description.isEmpty() || rate<0) throw new IllegalArgumentException(  );\n        this.project=new Project( name, description, rate );\n    }\n\n    @Override\n    public void setTask(Task newTask) {\n        if (newTask.equals( null )) throw new IllegalArgumentException(  );\n        project.setTask( newTask );\n    }\n\n    @Override\n    public long getTotalCost() {\n        return project.getTotalCost();\n    }\n\n    @Override\n    public double getDuration() {\n        return project.getDuration();\n    }\n\n    @Override\n    public List<Deliverable> getDeliverables() {\n        return project.task.allDeliverables();\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Calendar;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Deliverable extends ProjectItem {\n    private Long materialCost;\n    private Double productionTime;\n    private Calendar date;\n\n    public Deliverable(String name, String details, Double rate, Long materialCost, Double productionTime, Calendar date) {\n        super( name, details, rate );\n        if (name.isEmpty() ||  details.isEmpty()|| name.equals( null ) || details.equals( 0 ) || date.equals( 0 ) || rate<0 || materialCost<0 || productionTime<=0.0) throw new IllegalArgumentException(  );\n        this.materialCost = materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    public Deliverable(String name, String details, Double rate, int materialCost, Double productionTime, Calendar date) {\n        super( name, details, rate );\n        if (name.isEmpty() || details.isEmpty()||name.equals( null ) || details.equals( 0 ) || date.equals( 0 ) || rate<0 || materialCost<0 || productionTime<=0.0) throw new IllegalArgumentException(  );\n        this.materialCost = (long) materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    @Override\n    public double getTimeRequired() {\n        return this.productionTime;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        return this.materialCost;\n    }\n\n    public Calendar getDate() {\n        return date;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "String literal expressions should be on the left side of an equals comparison.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "89",
    "end_column": "89",
    "rule": {
      "identifier": "EqualsAvoidNull",
      "explanation": "If a string variable may be null, avoid calling .equals(...) on it to compare it to another, non null string. Instead, call the .equals(...) method on the non null string such as in \"Foo\".equals(otherString).",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.Calendar;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Deliverable extends ProjectItem {\n    private Long materialCost;\n    private Double productionTime;\n    private Calendar date;\n\n    public Deliverable(String name, String details, Double rate, Long materialCost, Double productionTime, Calendar date) {\n        super( name, details, rate );\n        if (name.isEmpty() ||  details.isEmpty()|| name.equals( null ) || details.equals( 0 ) || date.equals( 0 ) || rate<0 || materialCost<0 || productionTime<=0.0) throw new IllegalArgumentException(  );\n        this.materialCost = materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    public Deliverable(String name, String details, Double rate, int materialCost, Double productionTime, Calendar date) {\n        super( name, details, rate );\n        if (name.isEmpty() || details.isEmpty()||name.equals( null ) || details.equals( 0 ) || date.equals( 0 ) || rate<0 || materialCost<0 || productionTime<=0.0) throw new IllegalArgumentException(  );\n        this.materialCost = (long) materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    @Override\n    public double getTimeRequired() {\n        return this.productionTime;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        return this.materialCost;\n    }\n\n    public Calendar getDate() {\n        return date;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Calendar;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Deliverable extends ProjectItem {\n    private Long materialCost;\n    private Double productionTime;\n    private Calendar date;\n\n    public Deliverable(String name, String details, Double rate, Long materialCost, Double productionTime, Calendar date) {\n        super( name, details, rate );\n        if (name.isEmpty() ||  details.isEmpty()|| name.equals( null ) || details.equals( 0 ) || date.equals( 0 ) || rate<0 || materialCost<0 || productionTime<=0.0) throw new IllegalArgumentException(  );\n        this.materialCost = materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    public Deliverable(String name, String details, Double rate, int materialCost, Double productionTime, Calendar date) {\n        super( name, details, rate );\n        if (name.isEmpty() || details.isEmpty()||name.equals( null ) || details.equals( 0 ) || date.equals( 0 ) || rate<0 || materialCost<0 || productionTime<=0.0) throw new IllegalArgumentException(  );\n        this.materialCost = (long) materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    @Override\n    public double getTimeRequired() {\n        return this.productionTime;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        return this.materialCost;\n    }\n\n    public Calendar getDate() {\n        return date;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "String literal expressions should be on the left side of an equals comparison.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": "87",
    "end_column": "87",
    "rule": {
      "identifier": "EqualsAvoidNull",
      "explanation": "If a string variable may be null, avoid calling .equals(...) on it to compare it to another, non null string. Instead, call the .equals(...) method on the non null string such as in \"Foo\".equals(otherString).",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.Calendar;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Deliverable extends ProjectItem {\n    private Long materialCost;\n    private Double productionTime;\n    private Calendar date;\n\n    public Deliverable(String name, String details, Double rate, Long materialCost, Double productionTime, Calendar date) {\n        super( name, details, rate );\n        if (name.isEmpty() ||  details.isEmpty()|| name.equals( null ) || details.equals( 0 ) || date.equals( 0 ) || rate<0 || materialCost<0 || productionTime<=0.0) throw new IllegalArgumentException(  );\n        this.materialCost = materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    public Deliverable(String name, String details, Double rate, int materialCost, Double productionTime, Calendar date) {\n        super( name, details, rate );\n        if (name.isEmpty() || details.isEmpty()||name.equals( null ) || details.equals( 0 ) || date.equals( 0 ) || rate<0 || materialCost<0 || productionTime<=0.0) throw new IllegalArgumentException(  );\n        this.materialCost = (long) materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    @Override\n    public double getTimeRequired() {\n        return this.productionTime;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        return this.materialCost;\n    }\n\n    public Calendar getDate() {\n        return date;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "Abbreviation in name 'IProject' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.List;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic interface IProject {\n\n    void setTask(Task newTask);\n\n    long getTotalCost();\n\n    double getDuration();\n\n    List<Deliverable> getDeliverables();\n\n\n\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "Variable 'task' explicitly initialized to 'null' (default value for its type).",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "17",
    "end_column": "17",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Project {\n\n    private String name;\n    private String description;\n    public Task task=null;\n\n    public Project(String name, String description, double rate) {\n        this.name = name;\n        this.description = description;\n        this.task=new Task( name, description, rate );\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setTask(Task NewTask) {\n        if (NewTask.equals( null )) throw new IllegalArgumentException(  );\n        this.task = NewTask;\n    }\n\n    public double getDuration(){\n        return task.getTimeRequired();\n    }\n\n    public long getTotalCost(){\n        return (long) (task.getMaterialCost()+(task.rate*task.getTimeRequired()));\n    }\n\n    public Map<Calendar,List<Deliverable>> allDeliverables(){\n        Map<Calendar, List<Deliverable>> result = new LinkedHashMap<Calendar, List<Deliverable>>();\n        List<Deliverable> deliverableList = task.allDeliverables();\n        for (Deliverable deliverable: deliverableList) {\n            Calendar date = deliverable.getDate();\n            List<Deliverable> updatedList = new LinkedList<Deliverable>(  );\n            if (result.containsKey(date )){\n                updatedList = result.get(date);\n            }\n            updatedList.add( deliverable );\n            result.put( date,updatedList );\n        }\n        return result;\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "Variable 'task' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "17",
    "end_column": "17",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Project {\n\n    private String name;\n    private String description;\n    public Task task=null;\n\n    public Project(String name, String description, double rate) {\n        this.name = name;\n        this.description = description;\n        this.task=new Task( name, description, rate );\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setTask(Task NewTask) {\n        if (NewTask.equals( null )) throw new IllegalArgumentException(  );\n        this.task = NewTask;\n    }\n\n    public double getDuration(){\n        return task.getTimeRequired();\n    }\n\n    public long getTotalCost(){\n        return (long) (task.getMaterialCost()+(task.rate*task.getTimeRequired()));\n    }\n\n    public Map<Calendar,List<Deliverable>> allDeliverables(){\n        Map<Calendar, List<Deliverable>> result = new LinkedHashMap<Calendar, List<Deliverable>>();\n        List<Deliverable> deliverableList = task.allDeliverables();\n        for (Deliverable deliverable: deliverableList) {\n            Calendar date = deliverable.getDate();\n            List<Deliverable> updatedList = new LinkedList<Deliverable>(  );\n            if (result.containsKey(date )){\n                updatedList = result.get(date);\n            }\n            updatedList.add( deliverable );\n            result.put( date,updatedList );\n        }\n        return result;\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Project {\n\n    private String name;\n    private String description;\n    public Task task=null;\n\n    public Project(String name, String description, double rate) {\n        this.name = name;\n        this.description = description;\n        this.task=new Task( name, description, rate );\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setTask(Task NewTask) {\n        if (NewTask.equals( null )) throw new IllegalArgumentException(  );\n        this.task = NewTask;\n    }\n\n    public double getDuration(){\n        return task.getTimeRequired();\n    }\n\n    public long getTotalCost(){\n        return (long) (task.getMaterialCost()+(task.rate*task.getTimeRequired()));\n    }\n\n    public Map<Calendar,List<Deliverable>> allDeliverables(){\n        Map<Calendar, List<Deliverable>> result = new LinkedHashMap<Calendar, List<Deliverable>>();\n        List<Deliverable> deliverableList = task.allDeliverables();\n        for (Deliverable deliverable: deliverableList) {\n            Calendar date = deliverable.getDate();\n            List<Deliverable> updatedList = new LinkedList<Deliverable>(  );\n            if (result.containsKey(date )){\n                updatedList = result.get(date);\n            }\n            updatedList.add( deliverable );\n            result.put( date,updatedList );\n        }\n        return result;\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "Name 'ProjectItem' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import static java.lang.Math.round;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic abstract class ProjectItem {\n    private String name;\n    private String details;\n    public Double rate;\n\n\n    public ProjectItem(String name, String details, Double rate) {\n        if (name.isEmpty() || name.equals( null )|| details.isEmpty() || details.equals( null ) || rate<0) throw new IllegalArgumentException(  );\n        this.name = name;\n        this.details = details;\n        this.rate = rate;\n    }\n\n    public void setDetails(String NewDetails) {\n        this.details = NewDetails;\n    }\n\n    public long getCostEstimate(){\n        return  round(getMaterialCost()+(rate*getTimeRequired()));\n    }\n\n    public abstract double getTimeRequired();\n\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "Variable 'rate' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "19",
    "end_column": "19",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import static java.lang.Math.round;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic abstract class ProjectItem {\n    private String name;\n    private String details;\n    public Double rate;\n\n\n    public ProjectItem(String name, String details, Double rate) {\n        if (name.isEmpty() || name.equals( null )|| details.isEmpty() || details.equals( null ) || rate<0) throw new IllegalArgumentException(  );\n        this.name = name;\n        this.details = details;\n        this.rate = rate;\n    }\n\n    public void setDetails(String NewDetails) {\n        this.details = NewDetails;\n    }\n\n    public long getCostEstimate(){\n        return  round(getMaterialCost()+(rate*getTimeRequired()));\n    }\n\n    public abstract double getTimeRequired();\n\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import static java.lang.Math.round;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic abstract class ProjectItem {\n    private String name;\n    private String details;\n    public Double rate;\n\n\n    public ProjectItem(String name, String details, Double rate) {\n        if (name.isEmpty() || name.equals( null )|| details.isEmpty() || details.equals( null ) || rate<0) throw new IllegalArgumentException(  );\n        this.name = name;\n        this.details = details;\n        this.rate = rate;\n    }\n\n    public void setDetails(String NewDetails) {\n        this.details = NewDetails;\n    }\n\n    public long getCostEstimate(){\n        return  round(getMaterialCost()+(rate*getTimeRequired()));\n    }\n\n    public abstract double getTimeRequired();\n\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "37",
    "end_line": "37",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Task extends ProjectItem {\n\n    private List<ProjectItem> projectItems = new LinkedList<ProjectItem>();\n\n    public Task(String name, String details, Double rate) {\n        super( name, details, rate );\n    }\n\n    public Task(String name, String details, int rate) {\n        super( name, details, (double)rate );\n    }\n\n    @Override\n    public double getTimeRequired() {\n        double result=0;\n        for (ProjectItem pi :projectItems ) {\n            result+=pi.getTimeRequired();\n        }\n        return result;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        long result=0;\n        for (ProjectItem pi :projectItems ) {\n            result+=pi.getMaterialCost();\n        }\n        return result;\n    }\n\n    public void addProjectItem ( ProjectItem pi) {\n        if (pi.equals( null )) throw new IllegalArgumentException(  );\n        projectItems.add( pi );\n    }\n\n    public void removeProjectItem(ProjectItem pi) {\n        if (pi.equals( null )) throw new IllegalArgumentException(  );\n        projectItems.remove( pi );\n    }\n\n    public List<Deliverable> allDeliverables(){\n        List<Deliverable> returnList = new LinkedList<Deliverable>(  );\n        for (ProjectItem pi: projectItems) {\n            if (pi.getClass().equals( Task.class )){\n                Task subTask = (Task)pi;\n                List<Deliverable> subList=subTask.allDeliverables();\n                returnList.addAll( subList );\n            }\n            else {\n                if (pi.getClass().equals( Deliverable.class )){\n                    Deliverable deliverable=(Deliverable)pi;\n                    returnList.add( deliverable );\n                }\n            }\n\n        }\n        return returnList;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "42",
    "end_line": "42",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 23.05.17.\n */\npublic class Task extends ProjectItem {\n\n    private List<ProjectItem> projectItems = new LinkedList<ProjectItem>();\n\n    public Task(String name, String details, Double rate) {\n        super( name, details, rate );\n    }\n\n    public Task(String name, String details, int rate) {\n        super( name, details, (double)rate );\n    }\n\n    @Override\n    public double getTimeRequired() {\n        double result=0;\n        for (ProjectItem pi :projectItems ) {\n            result+=pi.getTimeRequired();\n        }\n        return result;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        long result=0;\n        for (ProjectItem pi :projectItems ) {\n            result+=pi.getMaterialCost();\n        }\n        return result;\n    }\n\n    public void addProjectItem ( ProjectItem pi) {\n        if (pi.equals( null )) throw new IllegalArgumentException(  );\n        projectItems.add( pi );\n    }\n\n    public void removeProjectItem(ProjectItem pi) {\n        if (pi.equals( null )) throw new IllegalArgumentException(  );\n        projectItems.remove( pi );\n    }\n\n    public List<Deliverable> allDeliverables(){\n        List<Deliverable> returnList = new LinkedList<Deliverable>(  );\n        for (ProjectItem pi: projectItems) {\n            if (pi.getClass().equals( Task.class )){\n                Task subTask = (Task)pi;\n                List<Deliverable> subList=subTask.allDeliverables();\n                returnList.addAll( subList );\n            }\n            else {\n                if (pi.getClass().equals( Deliverable.class )){\n                    Deliverable deliverable=(Deliverable)pi;\n                    returnList.add( deliverable );\n                }\n            }\n\n        }\n        return returnList;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Predicate Iterator",
    "message": "'{' at column 56 should have line break after.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "56",
    "end_column": "56",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class PredicateEndsWith<T extends String> implements Predicate<T> {\n    public boolean predicate(T element, T argument) {\n        if( (element == null) || (argument == null ) ) {return false;}\n        //return element.contains( argument ) && element.charAt( element.length() )==argument.charAt( argument.length() );\n        return element.endsWith( argument) ;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class PredicateLength<T extends String> implements Predicate<T> {\n    public boolean predicate(T element, T argument) {\n        if(element == null ||argument == null ) return false;\n        return (element.length() == Integer.parseInt( argument ));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class PredicateStartsWith<T extends String> implements Predicate<T> {\n    @Override\n    public boolean predicate( T element, T argument) {\n        if(element == null ||argument == null ) return false;\n        return element.startsWith( argument ) ;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Name 'limit' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "ConstantName",
      "explanation": "Constants (static and final fields or interface/annotation fields) should conform to naming conventions. For example, naming a constant \"foo\" or \"BAR\" is ok, whereas naming it \"fooBAR\" such as in final static int fooBAR violates the conventions. Constants should match the regular expression \"^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic class Flooring extends Material {\n\n    private static final double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width) {\n        super( name, price );\n        if (price<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.widthOfFlooring=width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea()/widthOfFlooring);\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return ((int)Math.round(result))+1;\n        else return ((int)Math.round(result));\n\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic class Flooring extends Material {\n\n    private static final double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width) {\n        super( name, price );\n        if (price<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.widthOfFlooring=width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea()/widthOfFlooring);\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return ((int)Math.round(result))+1;\n        else return ((int)Math.round(result));\n\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'0.5' is a magic number.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": "49",
    "end_column": "49",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic class Flooring extends Material {\n\n    private static final double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width) {\n        super( name, price );\n        if (price<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.widthOfFlooring=width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea()/widthOfFlooring);\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return ((int)Math.round(result))+1;\n        else return ((int)Math.round(result));\n\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'1000' is a magic number.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": "80",
    "end_column": "80",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic class Flooring extends Material {\n\n    private static final double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width) {\n        super( name, price );\n        if (price<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.widthOfFlooring=width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea()/widthOfFlooring);\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return ((int)Math.round(result))+1;\n        else return ((int)Math.round(result));\n\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'1000' is a magic number.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": "87",
    "end_column": "87",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic class Flooring extends Material {\n\n    private static final double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width) {\n        super( name, price );\n        if (price<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.widthOfFlooring=width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea()/widthOfFlooring);\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return ((int)Math.round(result))+1;\n        else return ((int)Math.round(result));\n\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic class Flooring extends Material {\n\n    private static final double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width) {\n        super( name, price );\n        if (price<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.widthOfFlooring=width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea()/widthOfFlooring);\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return ((int)Math.round(result))+1;\n        else return ((int)Math.round(result));\n\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'0.02' is a magic number.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic class Flooring extends Material {\n\n    private static final double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width) {\n        super( name, price );\n        if (price<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.widthOfFlooring=width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea()/widthOfFlooring);\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return ((int)Math.round(result))+1;\n        else return ((int)Math.round(result));\n\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic class Flooring extends Material {\n\n    private static final double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width) {\n        super( name, price );\n        if (price<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.widthOfFlooring=width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea()/widthOfFlooring);\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return ((int)Math.round(result))+1;\n        else return ((int)Math.round(result));\n\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Name 'Material' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic abstract class Material {\n\n    private String name;\n    private double price;\n\n    public Material(String name, double price) {\n        if (name.equals( null ) || name.isEmpty() || price<=0) throw new IllegalArgumentException();\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public double getPricePerUnit() {\n        return price;\n    }\n\n    public abstract int getMaterialReq(Surface s);\n\n    public double getPriceOfASurface(Surface s){\n        if (s.equals( null )) throw new IllegalArgumentException();\n        return getMaterialReq(s )*getPricePerUnit();\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic abstract class Material {\n\n    private String name;\n    private double price;\n\n    public Material(String name, double price) {\n        if (name.equals( null ) || name.isEmpty() || price<=0) throw new IllegalArgumentException();\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public double getPricePerUnit() {\n        return price;\n    }\n\n    public abstract int getMaterialReq(Surface s);\n\n    public double getPriceOfASurface(Surface s){\n        if (s.equals( null )) throw new IllegalArgumentException();\n        return getMaterialReq(s )*getPricePerUnit();\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'getPriceOfASurface' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic abstract class Material {\n\n    private String name;\n    private double price;\n\n    public Material(String name, double price) {\n        if (name.equals( null ) || name.isEmpty() || price<=0) throw new IllegalArgumentException();\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public double getPricePerUnit() {\n        return price;\n    }\n\n    public abstract int getMaterialReq(Surface s);\n\n    public double getPriceOfASurface(Surface s){\n        if (s.equals( null )) throw new IllegalArgumentException();\n        return getMaterialReq(s )*getPricePerUnit();\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 24.05.17.\n */\npublic abstract class Material {\n\n    private String name;\n    private double price;\n\n    public Material(String name, double price) {\n        if (name.equals( null ) || name.isEmpty() || price<=0) throw new IllegalArgumentException();\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public double getPricePerUnit() {\n        return price;\n    }\n\n    public abstract int getMaterialReq(Surface s);\n\n    public double getPriceOfASurface(Surface s){\n        if (s.equals( null )) throw new IllegalArgumentException();\n        return getMaterialReq(s )*getPricePerUnit();\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Variable 'limit' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "19",
    "end_column": "19",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'0.02' is a magic number.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "27",
    "end_column": "27",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'getNoOfSqMPerLiter' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'noOfSqMPerLiter' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'noOfSqMPerLiter' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'0.5' is a magic number.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": "49",
    "end_column": "49",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'1000' is a magic number.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": "80",
    "end_column": "80",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'1000' is a magic number.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": "87",
    "end_column": "87",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "32",
    "end_line": "32",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'0.02' is a magic number.",
    "priority": "error",
    "start_line": "32",
    "end_line": "32",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'0.5' is a magic number.",
    "priority": "error",
    "start_line": "32",
    "end_line": "32",
    "start_column": "78",
    "end_column": "78",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 14.07.17.\n */\npublic class Paint extends Material {\n\n    static double limit = 0.02;\n\n    public int getNoOfCoats() {\n        return noOfCoats;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return noOfSqMPerLiter;\n    }\n\n    private int noOfCoats;\n    private double noOfSqMPerLiter;\n\n    public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n        super( name, price );\n        if (price<=0 || noOfCoats <=0 || noOfSqMPerLiter<=0) throw new IllegalArgumentException(  );\n        this.noOfCoats = noOfCoats;\n        this.noOfSqMPerLiter = noOfSqMPerLiter;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface s) {\n        double result = (s.getArea() * noOfCoats) / noOfSqMPerLiter;\n        double inaccurateCalculation = result % 0.5;\n        double fixedCalculation = ((double) Math.round(inaccurateCalculation * 1000))/1000;\n        if (fixedCalculation>=0.02) return (int)((double)Math.round(result*2+0.5));\n        else return ((int)Math.round(result*2));\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Name 'RenovationObject' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Set;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic abstract class RenovationObject {\n\n    abstract double getPrice();\n\n    abstract Map<String, Integer> addMaterialReq(Map<String, Integer> materials);\n\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "18",
    "end_line": "18",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class StructuredObject extends RenovationObject {\n\n    private Set<RenovationObject> parts;\n\n    public StructuredObject() {\n        this.parts = new LinkedHashSet<RenovationObject>(  );\n    }\n\n    void add(RenovationObject r){\n        if (r.equals( null )) throw new IllegalArgumentException(  );\n        parts.add( r );\n    }\n\n    @Override\n    double getPrice() {\n        double result=0;\n        for ( RenovationObject o: parts) {\n            result+=o.getPrice();\n        }\n        return result;\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        Map<String, Integer> newMaterials=new TreeMap<String, Integer>( );\n        for (RenovationObject part: parts) {\n                newMaterials.putAll( part.addMaterialReq(new TreeMap<String, Integer>( )) );\n        }\n        return newMaterials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class StructuredObject extends RenovationObject {\n\n    private Set<RenovationObject> parts;\n\n    public StructuredObject() {\n        this.parts = new LinkedHashSet<RenovationObject>(  );\n    }\n\n    void add(RenovationObject r){\n        if (r.equals( null )) throw new IllegalArgumentException(  );\n        parts.add( r );\n    }\n\n    @Override\n    double getPrice() {\n        double result=0;\n        for ( RenovationObject o: parts) {\n            result+=o.getPrice();\n        }\n        return result;\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        Map<String, Integer> newMaterials=new TreeMap<String, Integer>( );\n        for (RenovationObject part: parts) {\n                newMaterials.putAll( part.addMaterialReq(new TreeMap<String, Integer>( )) );\n        }\n        return newMaterials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class StructuredObject extends RenovationObject {\n\n    private Set<RenovationObject> parts;\n\n    public StructuredObject() {\n        this.parts = new LinkedHashSet<RenovationObject>(  );\n    }\n\n    void add(RenovationObject r){\n        if (r.equals( null )) throw new IllegalArgumentException(  );\n        parts.add( r );\n    }\n\n    @Override\n    double getPrice() {\n        double result=0;\n        for ( RenovationObject o: parts) {\n            result+=o.getPrice();\n        }\n        return result;\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        Map<String, Integer> newMaterials=new TreeMap<String, Integer>( );\n        for (RenovationObject part: parts) {\n                newMaterials.putAll( part.addMaterialReq(new TreeMap<String, Integer>( )) );\n        }\n        return newMaterials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "38",
    "end_line": "38",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class StructuredObject extends RenovationObject {\n\n    private Set<RenovationObject> parts;\n\n    public StructuredObject() {\n        this.parts = new LinkedHashSet<RenovationObject>(  );\n    }\n\n    void add(RenovationObject r){\n        if (r.equals( null )) throw new IllegalArgumentException(  );\n        parts.add( r );\n    }\n\n    @Override\n    double getPrice() {\n        double result=0;\n        for ( RenovationObject o: parts) {\n            result+=o.getPrice();\n        }\n        return result;\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        Map<String, Integer> newMaterials=new TreeMap<String, Integer>( );\n        for (RenovationObject part: parts) {\n                newMaterials.putAll( part.addMaterialReq(new TreeMap<String, Integer>( )) );\n        }\n        return newMaterials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Each variable declaration must be in its own statement.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "MultipleVariableDeclarations",
      "explanation": "Each variable declaration should reside in its own statement and line. This increases readability.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Set;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class Surface extends RenovationObject {\n\n    private double length, width;\n    public Material selectedMaterial ;\n\n    public Surface(double length, double width) {\n        if (length<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.length = length;\n        this.width = width;\n    }\n\n    public void setMaterial(Material m) {\n        if (m.equals( null )) throw new IllegalArgumentException(  );\n        this.selectedMaterial = m;\n    }\n\n    public double getArea(){\n        return length*width;\n    }\n\n    public double getLength() {\n        return length;\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    @Override\n    double getPrice() {\n         return selectedMaterial.getPriceOfASurface( this );\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null ) || selectedMaterial.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (materials.containsKey( selectedMaterial.getName() )) {\n            materials.put(selectedMaterial.getName(), selectedMaterial.getMaterialReq( this )+materials.get( selectedMaterial.getName() ) );\n        }\n        else {\n            materials.put( selectedMaterial.getName(), selectedMaterial.getMaterialReq( this ) );\n        }\n        return materials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "Variable 'selectedMaterial' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "21",
    "end_column": "21",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Set;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class Surface extends RenovationObject {\n\n    private double length, width;\n    public Material selectedMaterial ;\n\n    public Surface(double length, double width) {\n        if (length<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.length = length;\n        this.width = width;\n    }\n\n    public void setMaterial(Material m) {\n        if (m.equals( null )) throw new IllegalArgumentException(  );\n        this.selectedMaterial = m;\n    }\n\n    public double getArea(){\n        return length*width;\n    }\n\n    public double getLength() {\n        return length;\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    @Override\n    double getPrice() {\n         return selectedMaterial.getPriceOfASurface( this );\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null ) || selectedMaterial.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (materials.containsKey( selectedMaterial.getName() )) {\n            materials.put(selectedMaterial.getName(), selectedMaterial.getMaterialReq( this )+materials.get( selectedMaterial.getName() ) );\n        }\n        else {\n            materials.put( selectedMaterial.getName(), selectedMaterial.getMaterialReq( this ) );\n        }\n        return materials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Set;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class Surface extends RenovationObject {\n\n    private double length, width;\n    public Material selectedMaterial ;\n\n    public Surface(double length, double width) {\n        if (length<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.length = length;\n        this.width = width;\n    }\n\n    public void setMaterial(Material m) {\n        if (m.equals( null )) throw new IllegalArgumentException(  );\n        this.selectedMaterial = m;\n    }\n\n    public double getArea(){\n        return length*width;\n    }\n\n    public double getLength() {\n        return length;\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    @Override\n    double getPrice() {\n         return selectedMaterial.getPriceOfASurface( this );\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null ) || selectedMaterial.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (materials.containsKey( selectedMaterial.getName() )) {\n            materials.put(selectedMaterial.getName(), selectedMaterial.getMaterialReq( this )+materials.get( selectedMaterial.getName() ) );\n        }\n        else {\n            materials.put( selectedMaterial.getName(), selectedMaterial.getMaterialReq( this ) );\n        }\n        return materials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Set;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class Surface extends RenovationObject {\n\n    private double length, width;\n    public Material selectedMaterial ;\n\n    public Surface(double length, double width) {\n        if (length<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.length = length;\n        this.width = width;\n    }\n\n    public void setMaterial(Material m) {\n        if (m.equals( null )) throw new IllegalArgumentException(  );\n        this.selectedMaterial = m;\n    }\n\n    public double getArea(){\n        return length*width;\n    }\n\n    public double getLength() {\n        return length;\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    @Override\n    double getPrice() {\n         return selectedMaterial.getPriceOfASurface( this );\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null ) || selectedMaterial.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (materials.containsKey( selectedMaterial.getName() )) {\n            materials.put(selectedMaterial.getName(), selectedMaterial.getMaterialReq( this )+materials.get( selectedMaterial.getName() ) );\n        }\n        else {\n            materials.put( selectedMaterial.getName(), selectedMaterial.getMaterialReq( this ) );\n        }\n        return materials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "42",
    "end_line": "42",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Set;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class Surface extends RenovationObject {\n\n    private double length, width;\n    public Material selectedMaterial ;\n\n    public Surface(double length, double width) {\n        if (length<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.length = length;\n        this.width = width;\n    }\n\n    public void setMaterial(Material m) {\n        if (m.equals( null )) throw new IllegalArgumentException(  );\n        this.selectedMaterial = m;\n    }\n\n    public double getArea(){\n        return length*width;\n    }\n\n    public double getLength() {\n        return length;\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    @Override\n    double getPrice() {\n         return selectedMaterial.getPriceOfASurface( this );\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null ) || selectedMaterial.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (materials.containsKey( selectedMaterial.getName() )) {\n            materials.put(selectedMaterial.getName(), selectedMaterial.getMaterialReq( this )+materials.get( selectedMaterial.getName() ) );\n        }\n        else {\n            materials.put( selectedMaterial.getName(), selectedMaterial.getMaterialReq( this ) );\n        }\n        return materials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "44",
    "end_line": "44",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Set;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class Surface extends RenovationObject {\n\n    private double length, width;\n    public Material selectedMaterial ;\n\n    public Surface(double length, double width) {\n        if (length<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.length = length;\n        this.width = width;\n    }\n\n    public void setMaterial(Material m) {\n        if (m.equals( null )) throw new IllegalArgumentException(  );\n        this.selectedMaterial = m;\n    }\n\n    public double getArea(){\n        return length*width;\n    }\n\n    public double getLength() {\n        return length;\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    @Override\n    double getPrice() {\n         return selectedMaterial.getPriceOfASurface( this );\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null ) || selectedMaterial.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (materials.containsKey( selectedMaterial.getName() )) {\n            materials.put(selectedMaterial.getName(), selectedMaterial.getMaterialReq( this )+materials.get( selectedMaterial.getName() ) );\n        }\n        else {\n            materials.put( selectedMaterial.getName(), selectedMaterial.getMaterialReq( this ) );\n        }\n        return materials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "47",
    "end_line": "47",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Set;\n\n/**\n * Created by fkasy on 24.05.17.\n */\npublic class Surface extends RenovationObject {\n\n    private double length, width;\n    public Material selectedMaterial ;\n\n    public Surface(double length, double width) {\n        if (length<=0 || width<=0) throw new IllegalArgumentException(  );\n        this.length = length;\n        this.width = width;\n    }\n\n    public void setMaterial(Material m) {\n        if (m.equals( null )) throw new IllegalArgumentException(  );\n        this.selectedMaterial = m;\n    }\n\n    public double getArea(){\n        return length*width;\n    }\n\n    public double getLength() {\n        return length;\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    @Override\n    double getPrice() {\n         return selectedMaterial.getPriceOfASurface( this );\n    }\n\n    @Override\n    Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n        if (materials.equals( null ) || selectedMaterial.equals( null )) throw new IllegalArgumentException(  );\n        for (String s: materials.keySet()) {\n            if (s.equals( null )) throw new IllegalArgumentException(  );\n        }\n        for (Integer i: materials.values()) {\n            if (i.equals( null )) throw new IllegalArgumentException(  );\n        }\n        if (materials.containsKey( selectedMaterial.getName() )) {\n            materials.put(selectedMaterial.getName(), selectedMaterial.getMaterialReq( this )+materials.get( selectedMaterial.getName() ) );\n        }\n        else {\n            materials.put( selectedMaterial.getName(), selectedMaterial.getMaterialReq( this ) );\n        }\n        return materials;\n    }\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "Each variable declaration must be in its own statement.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "MultipleVariableDeclarations",
      "explanation": "Each variable declaration should reside in its own statement and line. This increases readability.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 19.05.17.\n */\npublic class Appointee extends Employee {\n\n    private int dayOfMonth, hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (dayOfMonth<1 || dayOfMonth>31 || hoursPerMonth<1 || payPerHour<=0) throw new IllegalArgumentException();\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int DayOfMonth) {\n        return (DayOfMonth==dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return ((hoursPerMonth*payPerHour));\n    }\n\n    @Override\n    public double calculateDeductions() {\n        return ((hoursPerMonth*payPerHour)*0.4);\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 19.05.17.\n */\npublic class Appointee extends Employee {\n\n    private int dayOfMonth, hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (dayOfMonth<1 || dayOfMonth>31 || hoursPerMonth<1 || payPerHour<=0) throw new IllegalArgumentException();\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int DayOfMonth) {\n        return (DayOfMonth==dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return ((hoursPerMonth*payPerHour));\n    }\n\n    @Override\n    public double calculateDeductions() {\n        return ((hoursPerMonth*payPerHour)*0.4);\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'31' is a magic number.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "40",
    "end_column": "40",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 19.05.17.\n */\npublic class Appointee extends Employee {\n\n    private int dayOfMonth, hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (dayOfMonth<1 || dayOfMonth>31 || hoursPerMonth<1 || payPerHour<=0) throw new IllegalArgumentException();\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int DayOfMonth) {\n        return (DayOfMonth==dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return ((hoursPerMonth*payPerHour));\n    }\n\n    @Override\n    public double calculateDeductions() {\n        return ((hoursPerMonth*payPerHour)*0.4);\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'0.4' is a magic number.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": "44",
    "end_column": "44",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 19.05.17.\n */\npublic class Appointee extends Employee {\n\n    private int dayOfMonth, hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (dayOfMonth<1 || dayOfMonth>31 || hoursPerMonth<1 || payPerHour<=0) throw new IllegalArgumentException();\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int DayOfMonth) {\n        return (DayOfMonth==dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return ((hoursPerMonth*payPerHour));\n    }\n\n    @Override\n    public double calculateDeductions() {\n        return ((hoursPerMonth*payPerHour)*0.4);\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "Name 'Employee' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public abstract class Employee {\n\n    private String id;\n\n\n    public Employee(String id) {\n        if (id.isEmpty()||id.equals( null )) throw new IllegalArgumentException(  );\n        this.id = id;\n    }\n\n\n    public String getId() {\n        return id;\n    }\n\n    public abstract boolean isPayday(int DayOfMonth);\n\n    public abstract double calculatePay() throws UnpayableEmployeeException;\n\n    public abstract double calculateDeductions();\n\n\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public abstract class Employee {\n\n    private String id;\n\n\n    public Employee(String id) {\n        if (id.isEmpty()||id.equals( null )) throw new IllegalArgumentException(  );\n        this.id = id;\n    }\n\n\n    public String getId() {\n        return id;\n    }\n\n    public abstract boolean isPayday(int DayOfMonth);\n\n    public abstract double calculatePay() throws UnpayableEmployeeException;\n\n    public abstract double calculateDeductions();\n\n\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Iterator;\nimport java.util.List;\n\n/**\n * Created by fkasy on 19.05.17.\n */\npublic class Payroll {\n    private int payday;\n    private PayrollDisposition disposition;\n\n\n    public Payroll( PayrollDisposition disposition, int payday) {\n        if (disposition.equals( null ) || payday<=0 || payday>31) throw new IllegalArgumentException(  );\n        this.payday = payday;\n        this.disposition = disposition;\n    }\n\n    public void doPayroll(PayrollDB db ) {\n        List<Employee> EmplList= db.getEmployeeList();\n        Iterator<Employee> EmplIt = EmplList.iterator();\n        Employee Empl;\n        while (EmplIt.hasNext()){\n            Empl=EmplIt.next();\n            double pay;\n            try {\n                pay=Empl.calculatePay();\n            } catch (UnpayableEmployeeException e) {\n                pay=0;\n            }\n            double deductions = Empl.calculateDeductions();\n            if (pay > 0 && Empl.isPayday( payday )) disposition.sendPayment( Empl, (pay-deductions) );\n        }\n        }\n    }\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'31' is a magic number.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "63",
    "end_column": "63",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Iterator;\nimport java.util.List;\n\n/**\n * Created by fkasy on 19.05.17.\n */\npublic class Payroll {\n    private int payday;\n    private PayrollDisposition disposition;\n\n\n    public Payroll( PayrollDisposition disposition, int payday) {\n        if (disposition.equals( null ) || payday<=0 || payday>31) throw new IllegalArgumentException(  );\n        this.payday = payday;\n        this.disposition = disposition;\n    }\n\n    public void doPayroll(PayrollDB db ) {\n        List<Employee> EmplList= db.getEmployeeList();\n        Iterator<Employee> EmplIt = EmplList.iterator();\n        Employee Empl;\n        while (EmplIt.hasNext()){\n            Empl=EmplIt.next();\n            double pay;\n            try {\n                pay=Empl.calculatePay();\n            } catch (UnpayableEmployeeException e) {\n                pay=0;\n            }\n            double deductions = Empl.calculateDeductions();\n            if (pay > 0 && Empl.isPayday( payday )) disposition.sendPayment( Empl, (pay-deductions) );\n        }\n        }\n    }\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Iterator;\nimport java.util.List;\n\n/**\n * Created by fkasy on 19.05.17.\n */\npublic class Payroll {\n    private int payday;\n    private PayrollDisposition disposition;\n\n\n    public Payroll( PayrollDisposition disposition, int payday) {\n        if (disposition.equals( null ) || payday<=0 || payday>31) throw new IllegalArgumentException(  );\n        this.payday = payday;\n        this.disposition = disposition;\n    }\n\n    public void doPayroll(PayrollDB db ) {\n        List<Employee> EmplList= db.getEmployeeList();\n        Iterator<Employee> EmplIt = EmplList.iterator();\n        Employee Empl;\n        while (EmplIt.hasNext()){\n            Empl=EmplIt.next();\n            double pay;\n            try {\n                pay=Empl.calculatePay();\n            } catch (UnpayableEmployeeException e) {\n                pay=0;\n            }\n            double deductions = Empl.calculateDeductions();\n            if (pay > 0 && Empl.isPayday( payday )) disposition.sendPayment( Empl, (pay-deductions) );\n        }\n        }\n    }\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "Abbreviation in name 'PayrollDB' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.List;\n\n/**\n * Created by fkasy on 19.05.17.\n */\npublic interface PayrollDB {\n    public List<Employee> getEmployeeList();\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.List;\n\n/**\n * Created by fkasy on 19.05.17.\n */\npublic interface PayrollDB {\n    public List<Employee> getEmployeeList();\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 19.05.17.\n */\npublic interface PayrollDisposition {\n    public void sendPayment(Employee empl, double payment);\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 19.05.17.\n */\npublic class PayrollDispositionImpl implements PayrollDisposition {\n\n    private HashMap<Employee,Double> payments;\n\n    public PayrollDispositionImpl() {\n        this.payments=new HashMap<Employee,Double>(  );\n    }\n\n    @Override\n    public void sendPayment(Employee empl, double payment) {\n        if (payment<=0 || empl.equals( null )) throw new IllegalArgumentException(  );\n        payments.put( empl, payment );\n    }\n\n    public double getTotal(){\n        double result=0;\n        if (payments.isEmpty()) return result;\n        for (double value:payments.values()  ) {\n            result+=value;\n        }\n        return result;\n    }\n\n    public double getAverage(){\n        if (payments.isEmpty()) return 0;\n        return getTotal()/payments.size();\n    }\n\n    public Map<Employee,Double> getPayments(){\n        return payments;\n    }\n\n\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 19.05.17.\n */\npublic class PayrollDispositionImpl implements PayrollDisposition {\n\n    private HashMap<Employee,Double> payments;\n\n    public PayrollDispositionImpl() {\n        this.payments=new HashMap<Employee,Double>(  );\n    }\n\n    @Override\n    public void sendPayment(Employee empl, double payment) {\n        if (payment<=0 || empl.equals( null )) throw new IllegalArgumentException(  );\n        payments.put( empl, payment );\n    }\n\n    public double getTotal(){\n        double result=0;\n        if (payments.isEmpty()) return result;\n        for (double value:payments.values()  ) {\n            result+=value;\n        }\n        return result;\n    }\n\n    public double getAverage(){\n        if (payments.isEmpty()) return 0;\n        return getTotal()/payments.size();\n    }\n\n    public Map<Employee,Double> getPayments(){\n        return payments;\n    }\n\n\n}\n"
  },
  {
    "user": "1",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\n/**\n * Created by fkasy on 19.05.17.\n */\npublic class PayrollDispositionImpl implements PayrollDisposition {\n\n    private HashMap<Employee,Double> payments;\n\n    public PayrollDispositionImpl() {\n        this.payments=new HashMap<Employee,Double>(  );\n    }\n\n    @Override\n    public void sendPayment(Employee empl, double payment) {\n        if (payment<=0 || empl.equals( null )) throw new IllegalArgumentException(  );\n        payments.put( empl, payment );\n    }\n\n    public double getTotal(){\n        double result=0;\n        if (payments.isEmpty()) return result;\n        for (double value:payments.values()  ) {\n            result+=value;\n        }\n        return result;\n    }\n\n    public double getAverage(){\n        if (payments.isEmpty()) return 0;\n        return getTotal()/payments.size();\n    }\n\n    public Map<Employee,Double> getPayments(){\n        return payments;\n    }\n\n\n}\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "Each variable declaration must be in its own statement.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "MultipleVariableDeclarations",
      "explanation": "Each variable declaration should reside in its own statement and line. This increases readability.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class AbsoluteDiscountPricing implements ISalePricing{\n\n    private long discount, threshold;\n\n    public AbsoluteDiscountPricing(long discount, long threshold) {\n        if (discount<0 || threshold<0){\n            throw new IllegalArgumentException(  );\n        }\n        this.discount=discount;\n        this.threshold=threshold;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        if (sale==null){\n            throw new NullPointerException(  );\n        }\n        long price = (sale.getPreDiscountTotal()-discount);\n        if (price<threshold && threshold>sale.getPreDiscountTotal()) {\n            return sale.getPreDiscountTotal();\n        }\n        if (price<threshold && threshold<sale.getPreDiscountTotal()){\n            return threshold;\n        }\n        else {\n            return price;\n        }\n    }\n}\n\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "Name 'ComplexPricing' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\n\npublic abstract class ComplexPricing implements ISalePricing {\n    protected List<ISalePricing> pricings = new LinkedList<ISalePricing>();\n\n    public void add(ISalePricing pricing){\n        if (pricing==null) {\n            throw new NullPointerException(  );\n        }\n        pricings.add( pricing);\n    }\n\n    public List<ISalePricing> getPricings(){\n        return pricings;\n    }\n\n}\n\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "Variable 'pricings' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "34",
    "end_column": "34",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\n\npublic abstract class ComplexPricing implements ISalePricing {\n    protected List<ISalePricing> pricings = new LinkedList<ISalePricing>();\n\n    public void add(ISalePricing pricing){\n        if (pricing==null) {\n            throw new NullPointerException(  );\n        }\n        pricings.add( pricing);\n    }\n\n    public List<ISalePricing> getPricings(){\n        return pricings;\n    }\n\n}\n\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'{' at column 1 should be on the previous line.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "/**\n * Created by fkasy on 17.05.17.\n */\n\npublic enum  DiscountType\n{PERCENTAGEDISCOUNT, ABSOLUTEDISCOUNT}\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "Abbreviation in name 'ISalePricing' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public interface ISalePricing{\n    long getTotal(Sale sale);\n}\n\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "24",
    "end_column": "24",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import static java.lang.Math.round;\n\npublic class PercentageDiscountPricing implements ISalePricing{\n\n    private double percentage;\n\n    public PercentageDiscountPricing(double percentage) {\n        if (percentage<0) {\n            throw new IllegalArgumentException(  );\n        }\n        if (percentage>100){\n            throw new IllegalArgumentException(  );\n        }\n        this.percentage=percentage;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        if (sale==null){\n            throw new NullPointerException(  );\n        }\n        return round((sale.getPreDiscountTotal()/100)*(100-percentage));\n        //double price=((sale.preDiscountTotal/100)*(100-percentage));\n    }\n}\n\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": "50",
    "end_column": "50",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import static java.lang.Math.round;\n\npublic class PercentageDiscountPricing implements ISalePricing{\n\n    private double percentage;\n\n    public PercentageDiscountPricing(double percentage) {\n        if (percentage<0) {\n            throw new IllegalArgumentException(  );\n        }\n        if (percentage>100){\n            throw new IllegalArgumentException(  );\n        }\n        this.percentage=percentage;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        if (sale==null){\n            throw new NullPointerException(  );\n        }\n        return round((sale.getPreDiscountTotal()/100)*(100-percentage));\n        //double price=((sale.preDiscountTotal/100)*(100-percentage));\n    }\n}\n\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": "56",
    "end_column": "56",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import static java.lang.Math.round;\n\npublic class PercentageDiscountPricing implements ISalePricing{\n\n    private double percentage;\n\n    public PercentageDiscountPricing(double percentage) {\n        if (percentage<0) {\n            throw new IllegalArgumentException(  );\n        }\n        if (percentage>100){\n            throw new IllegalArgumentException(  );\n        }\n        this.percentage=percentage;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        if (sale==null){\n            throw new NullPointerException(  );\n        }\n        return round((sale.getPreDiscountTotal()/100)*(100-percentage));\n        //double price=((sale.preDiscountTotal/100)*(100-percentage));\n    }\n}\n\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "switch without \"default\" clause.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "MissingSwitchDefault",
      "explanation": "Switch statements should contain a default to account for cases that get introduced by future revisions. Default cases can also throw exceptions if they are never expected to be executed.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Sale {\n\n    private long preDiscountTotal;\n    private ISalePricing Pricing;\n\n\n    public Sale(long preDiscountTotal, ISalePricing Pricing) {\n        if (Pricing==null){\n            throw new NullPointerException(  );\n        }\n        if (preDiscountTotal<0){\n            throw new IllegalArgumentException(  );\n        }\n        this.preDiscountTotal=preDiscountTotal;\n        this.Pricing=Pricing;\n    }\n\n    public long getPreDiscountTotal() {\n        return preDiscountTotal;\n    }\n\n    public void setPricing(ISalePricing pricing) {\n        if (pricing==null){\n            throw new NullPointerException(  );\n        }\n        Pricing = pricing;\n    }\n\n    public long getTotal() {\n        return Pricing.getTotal( this );\n    }\n\n    public static ISalePricing createPricing(DiscountType discountType, double percentage, long discount, long threshold){\n        ISalePricing result=null;\n        switch (discountType){\n            case ABSOLUTEDISCOUNT:\n                result = new AbsoluteDiscountPricing( discount, threshold );\n                break;\n            case PERCENTAGEDISCOUNT:\n                result = new PercentageDiscountPricing( percentage );\n                break;\n        }\n        return result;\n    }\n\n}\n"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "Distance between variable 'sale1' declaration and its first usage is 10, but allowed 3.  Consider to make that variable as final if you still need to store its value in advance (before method calls that might do side effect on original value).",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "VariableDeclarationUsageDistance",
      "explanation": "Variables should be declared as near to their first usage, as possible.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "Distance between variable 'p4' declaration and its first usage is 4, but allowed 3.  Consider to make that variable as final if you still need to store its value in advance (before method calls that might do side effect on original value).",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "VariableDeclarationUsageDistance",
      "explanation": "Variables should be declared as near to their first usage, as possible.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "Distance between variable 'p5' declaration and its first usage is 5, but allowed 3.  Consider to make that variable as final if you still need to store its value in advance (before method calls that might do side effect on original value).",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "VariableDeclarationUsageDistance",
      "explanation": "Variables should be declared as near to their first usage, as possible.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "Each variable declaration must be in its own statement.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "17",
    "end_column": "17",
    "rule": {
      "identifier": "MultipleVariableDeclarations",
      "explanation": "Each variable declaration should reside in its own statement and line. This increases readability.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'10.0' is a magic number.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "74",
    "end_column": "74",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'5.0' is a magic number.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "74",
    "end_column": "74",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'500' is a magic number.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "75",
    "end_column": "75",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'5000' is a magic number.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "80",
    "end_column": "80",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'3000' is a magic number.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "75",
    "end_column": "75",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'15000' is a magic number.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "81",
    "end_column": "81",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'1900' is a magic number.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "75",
    "end_column": "75",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'8000' is a magic number.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "81",
    "end_column": "81",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'10000' is a magic number.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": "34",
    "end_column": "34",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "1",
    "task": "Pricing",
    "message": "'100.00' is a magic number.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": "35",
    "end_column": "35",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class SaleApp {\n\tpublic static void main(String[] args) {\n\t\tSale sale1;\n\t\tISalePricing p1, p2, p3, p4, p5;\n\t\tp1 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 10.0, 0, 0);\n\t\tp2 = Sale.createPricing(DiscountType.PERCENTAGEDISCOUNT, 5.0, 0, 0);\n\t\tp3 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 500, 5000);\n\t\tp4 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 3000, 15000);\n\t\tp5 = Sale.createPricing(DiscountType.ABSOLUTEDISCOUNT, 0, 1900, 8000);\n\t\tBestForCustomerPricing p = new BestForCustomerPricing(p1);\n\t\tp.add(p2);\n\t\tp.add(p3);\n\t\tp.add(p4);\n\t\tp.add(p5);\n\t\tsale1 = new Sale(10000, p);\n\t\tSystem.out.println(\"BestForCustomer Price = \" + sale1.getTotal()\n\t\t\t\t/ 100.00 + \" EUR\");\n\t}\n}"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Event implements Comparable<Event>{\n    private String title;\n    private EventCategory category;\n\n    public Event(String title, EventCategory category){\n        this.title = Validator.checkParam(title);\n        this.category = Objects.requireNonNull(category);\n    }\n\n    public String getTitle() {\n        return this.title;\n    }\n\n    public EventCategory getCategory() {\n        return this.category;\n    }\n\n    @Override\n    public int compareTo(Event event) {\n        int ratioTitle = this.title.compareTo(event.getTitle());\n        int ratioCateg = this.category.compareTo(event.getCategory());\n        if (ratioTitle != 0) return ratioTitle;\n        else return ratioCateg;\n    }\n}"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Event implements Comparable<Event>{\n    private String title;\n    private EventCategory category;\n\n    public Event(String title, EventCategory category){\n        this.title = Validator.checkParam(title);\n        this.category = Objects.requireNonNull(category);\n    }\n\n    public String getTitle() {\n        return this.title;\n    }\n\n    public EventCategory getCategory() {\n        return this.category;\n    }\n\n    @Override\n    public int compareTo(Event event) {\n        int ratioTitle = this.title.compareTo(event.getTitle());\n        int ratioCateg = this.category.compareTo(event.getCategory());\n        if (ratioTitle != 0) return ratioTitle;\n        else return ratioCateg;\n    }\n}"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class EventCatalogImpl extends TreeMap implements EventCatalog {\n    private Map<Event,Set<Time>> catalog;\n\n    public EventCatalogImpl(){\n        catalog = new TreeMap<>();\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event event, Set<Time> timeSet) {\n        if (timeSet == null || timeSet.contains(null))throw new NullPointerException();\n        if (catalog.containsKey(event)) return false;\n\n        catalog.put(event,timeSet);\n        return true;\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event event, Time time) {\n        Objects.requireNonNull(time);\n        if(!catalog.containsKey(event))return false;\n        Set<Time> events = catalog.get(event);\n        if (events.contains(time))return false;\n\n        events.add(time);\n        catalog.put(event,events);\n        return true;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        return catalog.get(e);\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        Objects.requireNonNull(category);\n        Map<Event,Set<Time>> filteredMap = new TreeMap<>();\n\n        for(Map.Entry<Event, Set<Time>> entry : catalog.entrySet()){\n            Event e = entry.getKey();\n            Set<Time> tSet = entry.getValue();\n            if (e.getCategory() == category) {\n                filteredMap.put(e,tSet);\n            }\n\n        }\n        return filteredMap;\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event event) {\n        return catalog.remove(event);\n    }\n\n    @Override\n    public boolean deleteTime(Event event,Time time) {\n        Objects.requireNonNull(event);\n        Objects.requireNonNull(time);\n        if(catalog.containsKey(event)){\n            Set<Time> times = catalog.get(event);\n            if (times.contains(time)){\n                times.remove(time);\n                catalog.put(event,times);\n                return true;\n            }\n        }\n        return false;\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class EventCatalogImpl extends TreeMap implements EventCatalog {\n    private Map<Event,Set<Time>> catalog;\n\n    public EventCatalogImpl(){\n        catalog = new TreeMap<>();\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event event, Set<Time> timeSet) {\n        if (timeSet == null || timeSet.contains(null))throw new NullPointerException();\n        if (catalog.containsKey(event)) return false;\n\n        catalog.put(event,timeSet);\n        return true;\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event event, Time time) {\n        Objects.requireNonNull(time);\n        if(!catalog.containsKey(event))return false;\n        Set<Time> events = catalog.get(event);\n        if (events.contains(time))return false;\n\n        events.add(time);\n        catalog.put(event,events);\n        return true;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        return catalog.get(e);\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        Objects.requireNonNull(category);\n        Map<Event,Set<Time>> filteredMap = new TreeMap<>();\n\n        for(Map.Entry<Event, Set<Time>> entry : catalog.entrySet()){\n            Event e = entry.getKey();\n            Set<Time> tSet = entry.getValue();\n            if (e.getCategory() == category) {\n                filteredMap.put(e,tSet);\n            }\n\n        }\n        return filteredMap;\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event event) {\n        return catalog.remove(event);\n    }\n\n    @Override\n    public boolean deleteTime(Event event,Time time) {\n        Objects.requireNonNull(event);\n        Objects.requireNonNull(time);\n        if(catalog.containsKey(event)){\n            Set<Time> times = catalog.get(event);\n            if (times.contains(time)){\n                times.remove(time);\n                catalog.put(event,times);\n                return true;\n            }\n        }\n        return false;\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class EventCatalogImpl extends TreeMap implements EventCatalog {\n    private Map<Event,Set<Time>> catalog;\n\n    public EventCatalogImpl(){\n        catalog = new TreeMap<>();\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event event, Set<Time> timeSet) {\n        if (timeSet == null || timeSet.contains(null))throw new NullPointerException();\n        if (catalog.containsKey(event)) return false;\n\n        catalog.put(event,timeSet);\n        return true;\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event event, Time time) {\n        Objects.requireNonNull(time);\n        if(!catalog.containsKey(event))return false;\n        Set<Time> events = catalog.get(event);\n        if (events.contains(time))return false;\n\n        events.add(time);\n        catalog.put(event,events);\n        return true;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        return catalog.get(e);\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        Objects.requireNonNull(category);\n        Map<Event,Set<Time>> filteredMap = new TreeMap<>();\n\n        for(Map.Entry<Event, Set<Time>> entry : catalog.entrySet()){\n            Event e = entry.getKey();\n            Set<Time> tSet = entry.getValue();\n            if (e.getCategory() == category) {\n                filteredMap.put(e,tSet);\n            }\n\n        }\n        return filteredMap;\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event event) {\n        return catalog.remove(event);\n    }\n\n    @Override\n    public boolean deleteTime(Event event,Time time) {\n        Objects.requireNonNull(event);\n        Objects.requireNonNull(time);\n        if(catalog.containsKey(event)){\n            Set<Time> times = catalog.get(event);\n            if (times.contains(time)){\n                times.remove(time);\n                catalog.put(event,times);\n                return true;\n            }\n        }\n        return false;\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class EventCatalogImpl extends TreeMap implements EventCatalog {\n    private Map<Event,Set<Time>> catalog;\n\n    public EventCatalogImpl(){\n        catalog = new TreeMap<>();\n    }\n\n    @Override\n    public boolean addCatalogEntry(Event event, Set<Time> timeSet) {\n        if (timeSet == null || timeSet.contains(null))throw new NullPointerException();\n        if (catalog.containsKey(event)) return false;\n\n        catalog.put(event,timeSet);\n        return true;\n    }\n\n    @Override\n    public boolean addTimeToEvent(Event event, Time time) {\n        Objects.requireNonNull(time);\n        if(!catalog.containsKey(event))return false;\n        Set<Time> events = catalog.get(event);\n        if (events.contains(time))return false;\n\n        events.add(time);\n        catalog.put(event,events);\n        return true;\n    }\n\n    @Override\n    public Set<Event> getAllEvents() {\n        return catalog.keySet();\n    }\n\n    @Override\n    public Set<Time> getTimesOfEvent(Event e) {\n        return catalog.get(e);\n    }\n\n    @Override\n    public Map<Event, Set<Time>> filterByEventCategory(EventCategory category) {\n        Objects.requireNonNull(category);\n        Map<Event,Set<Time>> filteredMap = new TreeMap<>();\n\n        for(Map.Entry<Event, Set<Time>> entry : catalog.entrySet()){\n            Event e = entry.getKey();\n            Set<Time> tSet = entry.getValue();\n            if (e.getCategory() == category) {\n                filteredMap.put(e,tSet);\n            }\n\n        }\n        return filteredMap;\n    }\n\n    @Override\n    public Set<Time> deleteEvent(Event event) {\n        return catalog.remove(event);\n    }\n\n    @Override\n    public boolean deleteTime(Event event,Time time) {\n        Objects.requireNonNull(event);\n        Objects.requireNonNull(time);\n        if(catalog.containsKey(event)){\n            Set<Time> times = catalog.get(event);\n            if (times.contains(time)){\n                times.remove(time);\n                catalog.put(event,times);\n                return true;\n            }\n        }\n        return false;\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\nimport java.util.Set;\n\npublic class Validator {\n    static int checkMinutes(int i){\n        if(i < 0 || i > 59)throw new IllegalArgumentException();\n        return i;\n    }\n\n    static int checkHours(int i){\n        if(i < 0 || i > 23) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if(str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static void checkParam(Set<Time> timeSet) {\n        Objects.requireNonNull(timeSet);\n        if(timeSet.stream().anyMatch(Objects::isNull)) throw new NullPointerException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\nimport java.util.Set;\n\npublic class Validator {\n    static int checkMinutes(int i){\n        if(i < 0 || i > 59)throw new IllegalArgumentException();\n        return i;\n    }\n\n    static int checkHours(int i){\n        if(i < 0 || i > 23) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if(str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static void checkParam(Set<Time> timeSet) {\n        Objects.requireNonNull(timeSet);\n        if(timeSet.stream().anyMatch(Objects::isNull)) throw new NullPointerException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'59' is a magic number.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "25",
    "end_column": "25",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\nimport java.util.Set;\n\npublic class Validator {\n    static int checkMinutes(int i){\n        if(i < 0 || i > 59)throw new IllegalArgumentException();\n        return i;\n    }\n\n    static int checkHours(int i){\n        if(i < 0 || i > 23) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if(str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static void checkParam(Set<Time> timeSet) {\n        Objects.requireNonNull(timeSet);\n        if(timeSet.stream().anyMatch(Objects::isNull)) throw new NullPointerException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\nimport java.util.Set;\n\npublic class Validator {\n    static int checkMinutes(int i){\n        if(i < 0 || i > 59)throw new IllegalArgumentException();\n        return i;\n    }\n\n    static int checkHours(int i){\n        if(i < 0 || i > 23) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if(str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static void checkParam(Set<Time> timeSet) {\n        Objects.requireNonNull(timeSet);\n        if(timeSet.stream().anyMatch(Objects::isNull)) throw new NullPointerException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'23' is a magic number.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "25",
    "end_column": "25",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\nimport java.util.Set;\n\npublic class Validator {\n    static int checkMinutes(int i){\n        if(i < 0 || i > 59)throw new IllegalArgumentException();\n        return i;\n    }\n\n    static int checkHours(int i){\n        if(i < 0 || i > 23) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if(str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static void checkParam(Set<Time> timeSet) {\n        Objects.requireNonNull(timeSet);\n        if(timeSet.stream().anyMatch(Objects::isNull)) throw new NullPointerException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\nimport java.util.Set;\n\npublic class Validator {\n    static int checkMinutes(int i){\n        if(i < 0 || i > 59)throw new IllegalArgumentException();\n        return i;\n    }\n\n    static int checkHours(int i){\n        if(i < 0 || i > 23) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if(str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static void checkParam(Set<Time> timeSet) {\n        Objects.requireNonNull(timeSet);\n        if(timeSet.stream().anyMatch(Objects::isNull)) throw new NullPointerException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\nimport java.util.Set;\n\npublic class Validator {\n    static int checkMinutes(int i){\n        if(i < 0 || i > 59)throw new IllegalArgumentException();\n        return i;\n    }\n\n    static int checkHours(int i){\n        if(i < 0 || i > 23) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if(str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static void checkParam(Set<Time> timeSet) {\n        Objects.requireNonNull(timeSet);\n        if(timeSet.stream().anyMatch(Objects::isNull)) throw new NullPointerException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Part Management",
    "message": "Name 'Part' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public abstract class Part {\n    private String id;\n    private String name;\n\n    public Part(String id, String name){\n        this.id = Validator.checkParam(id);\n        this.name = Validator.checkParam(name);\n    }\n\n    public String getId() {\n        return this.id;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class ReceivingStock extends Stock {\n    private int minStockItems;\n    private int maxStockItems;\n    public ReceivingStock(int minStockItems, int maxStockItems) {\n        if (maxStockItems <= minStockItems) throw new IllegalArgumentException();\n        this.maxStockItems = Validator.checkParam(maxStockItems);\n        this.minStockItems = Validator.checkParam(minStockItems);\n    }\n\n    public int getMinStockItems() {\n        return this.minStockItems;\n    }\n\n    public int getMaxStockItems() {\n        return this.maxStockItems;\n    }\n\n    @Override\n    public boolean insert(Part part, int amount) {\n        if ( amount > this.maxStockItems) return false;\n        return super.insert(part, amount);\n    }\n\n    @Override\n    public boolean remove(Part part, int amount){\n        Validator.checkParam(amount);\n        if (amount < 0) return false;\n        return super.remove(part, amount);\n\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class ReceivingStock extends Stock {\n    private int minStockItems;\n    private int maxStockItems;\n    public ReceivingStock(int minStockItems, int maxStockItems) {\n        if (maxStockItems <= minStockItems) throw new IllegalArgumentException();\n        this.maxStockItems = Validator.checkParam(maxStockItems);\n        this.minStockItems = Validator.checkParam(minStockItems);\n    }\n\n    public int getMinStockItems() {\n        return this.minStockItems;\n    }\n\n    public int getMaxStockItems() {\n        return this.maxStockItems;\n    }\n\n    @Override\n    public boolean insert(Part part, int amount) {\n        if ( amount > this.maxStockItems) return false;\n        return super.insert(part, amount);\n    }\n\n    @Override\n    public boolean remove(Part part, int amount){\n        Validator.checkParam(amount);\n        if (amount < 0) return false;\n        return super.remove(part, amount);\n\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class ReceivingStock extends Stock {\n    private int minStockItems;\n    private int maxStockItems;\n    public ReceivingStock(int minStockItems, int maxStockItems) {\n        if (maxStockItems <= minStockItems) throw new IllegalArgumentException();\n        this.maxStockItems = Validator.checkParam(maxStockItems);\n        this.minStockItems = Validator.checkParam(minStockItems);\n    }\n\n    public int getMinStockItems() {\n        return this.minStockItems;\n    }\n\n    public int getMaxStockItems() {\n        return this.maxStockItems;\n    }\n\n    @Override\n    public boolean insert(Part part, int amount) {\n        if ( amount > this.maxStockItems) return false;\n        return super.insert(part, amount);\n    }\n\n    @Override\n    public boolean remove(Part part, int amount){\n        Validator.checkParam(amount);\n        if (amount < 0) return false;\n        return super.remove(part, amount);\n\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Part Management",
    "message": "Name 'Stock' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic abstract class Stock {\n    private Map<Part, Integer> parts;\n    private List<StockObserver> observers;\n\n    public Stock(){\n        this.parts = new HashMap<>();\n        this.observers = new ArrayList<>();\n    }\n\n    public int getCount(Part part){\n        Objects.requireNonNull(part);\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean insert(Part part, int amount){\n        Objects.requireNonNull(part);\n        Validator.checkParam(amount);\n        boolean isInParts = parts.containsKey(part);\n        if (isInParts) {\n            parts.replace(part, parts.get(part) + amount);\n        } else parts.put(part, amount);\n        return true;\n    }\n\n    public boolean remove(Part part, int count) {\n        Objects.requireNonNull(part);\n        Validator.checkParam(count);\n        boolean isNotValid = !parts.containsKey(part) || count <= 0 || parts.get(part) < count;\n        if (isNotValid) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            this.notifyPartCountChanged(part);\n            return true;\n        }\n\n    }\n\n    public void addObserver(StockObserver observer) {\n        Objects.requireNonNull(observer);\n        observers.add(observer);\n    }\n\n    private void notifyPartCountChanged(Part part) {\n        observers.forEach(observer -> observer.onPartCountChanged(part, parts.get(part)));\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Part Management",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic abstract class Stock {\n    private Map<Part, Integer> parts;\n    private List<StockObserver> observers;\n\n    public Stock(){\n        this.parts = new HashMap<>();\n        this.observers = new ArrayList<>();\n    }\n\n    public int getCount(Part part){\n        Objects.requireNonNull(part);\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean insert(Part part, int amount){\n        Objects.requireNonNull(part);\n        Validator.checkParam(amount);\n        boolean isInParts = parts.containsKey(part);\n        if (isInParts) {\n            parts.replace(part, parts.get(part) + amount);\n        } else parts.put(part, amount);\n        return true;\n    }\n\n    public boolean remove(Part part, int count) {\n        Objects.requireNonNull(part);\n        Validator.checkParam(count);\n        boolean isNotValid = !parts.containsKey(part) || count <= 0 || parts.get(part) < count;\n        if (isNotValid) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            this.notifyPartCountChanged(part);\n            return true;\n        }\n\n    }\n\n    public void addObserver(StockObserver observer) {\n        Objects.requireNonNull(observer);\n        observers.add(observer);\n    }\n\n    private void notifyPartCountChanged(Part part) {\n        observers.forEach(observer -> observer.onPartCountChanged(part, parts.get(part)));\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Part Management",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if (str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static int checkParam(int i){\n        if (i < 1) throw new IllegalArgumentException();\n        return i;\n    }\n\n    public static void checkParam(String... strings) {\n        for(String string : strings){\n            checkParam(string);\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if (str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static int checkParam(int i){\n        if (i < 1) throw new IllegalArgumentException();\n        return i;\n    }\n\n    public static void checkParam(String... strings) {\n        for(String string : strings){\n            checkParam(string);\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if (str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static int checkParam(int i){\n        if (i < 1) throw new IllegalArgumentException();\n        return i;\n    }\n\n    public static void checkParam(String... strings) {\n        for(String string : strings){\n            checkParam(string);\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Abbreviation in name 'JAttachment' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.io.File;\nimport java.util.Objects;\n\npublic class JAttachment extends JContent {\n    private File file;\n\n    public JAttachment(String title, String description, File file) {\n        super(title, description);\n        this.file = Objects.requireNonNull(file);\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public void setFile(File file) {\n        this.file = Objects.requireNonNull(file);\n    }\n\n    @Override\n    public String toString() {\n        return \"Attachment: \" + super.getTitle() + '\\n' +\n                super.getDescription();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Abbreviation in name 'JContent' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Observable;\n\npublic abstract class JContent extends Observable {\n    private String title;\n    private String description;\n\n    public JContent(String title, String description){\n        this.title = Validator.checkParam(title);\n        this.description = Validator.checkParam(description);\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = Validator.checkParam(title);\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = Validator.checkParam(description);\n    }\n\n    @Override\n    public abstract String toString();\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Name 'JContent' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Observable;\n\npublic abstract class JContent extends Observable {\n    private String title;\n    private String description;\n\n    public JContent(String title, String description){\n        this.title = Validator.checkParam(title);\n        this.description = Validator.checkParam(description);\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = Validator.checkParam(title);\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = Validator.checkParam(description);\n    }\n\n    @Override\n    public abstract String toString();\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Abbreviation in name 'JIdea' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class JIdea extends JContent{\n\n    private JState state;\n    private List<JAttachment> attachments;\n\n    public JIdea(String title, String description) {\n        super(title, description);\n        this.state = new Draft();\n        this.attachments = new LinkedList<>();\n    }\n\n    public void discuss(String text){\n        this.state.discuss(text);\n    }\n\n    public void evaluate(JValuation valuation){\n        this.state.evaluate(valuation);\n    }\n\n    public void hold(){\n        this.state.hold();\n    }\n\n    public void release(){\n        this.state.release();\n    }\n\n    public void decline(){\n        this.state.decline();\n    }\n\n    public boolean isDeclined(){\n        return Utils.isInstance(this.state, DeclinedIdea.class);\n    }\n\n    public boolean isReleased(){\n        return Utils.isInstance(this.state, ReleasedIdea.class);\n    }\n\n    public String getCurrentDiscussion(){\n        return this.state.getCurrentDiscussion();\n    }\n\n    public JValuation getValuation(){\n        return this.state.getValuation();\n    }\n\n    public void addAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        this.attachments.add(attachment);\n    }\n\n    public List<JAttachment> getAttachments() {\n        return this.attachments;\n    }\n\n    public boolean removeAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        return attachments.remove(attachment);\n    }\n\n    @Override\n    public String toString() {\n        return \"Idea: \" + super.getTitle() + '\\n' + super.getDescription();\n    }\n\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || getClass() != object.getClass()) return false;\n        JIdea idea = (JIdea) object;\n        return  Objects.equals(idea.getTitle(),       this.getTitle()) &&\n                Objects.equals(idea.getDescription(), this.getDescription());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(this.getTitle(), this.getDescription());\n    }\n\n    public abstract class JState {\n        private JValuation valuation;\n        private String currentDiscussion = \"\";\n\n        public void hold() {};\n        public void release(){};\n        public void decline(){};\n\n        public void discuss(String currentDiscussion) {\n            Validator.checkParam(currentDiscussion);\n            this.currentDiscussion += currentDiscussion + '\\n';\n        }\n\n        public void evaluate(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n\n        public String getCurrentDiscussion() {\n            return currentDiscussion;\n        }\n\n        public JValuation getValuation() {\n            return valuation;\n        }\n\n        public void setCurrentDiscussion(String currentDiscussion) {\n            this.currentDiscussion = Validator.checkParam(currentDiscussion);\n        }\n        public void setValuation(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n    }\n    public class Draft extends JState {\n\n        @Override\n        public void hold() {\n            state = new OpenDraft();\n        }\n\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void discuss(String text){\n            throw new IllegalStateException(\"Can be discussed: This is only Draft\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Can be evaluated: This is only Draft\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Can be released: This is only Draft\");\n        }\n    }\n    public class OpenDraft extends JState{\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void hold() {\n            state = new ApprovedIdea();\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released yet: OpenDraft only\");\n        }\n    }\n    public class DeclinedIdea extends JState{\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is declined. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is declined. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is declined. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is declined. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Idea is declined. You can't release it\");\n        }\n    }\n    public class ApprovedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is Approved. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is Approved. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Approved. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Approved. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            state = new ReleasedIdea();\n        }\n    }\n    public class ReleasedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Cannot be holed: ReleasedIdea\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released: ReleasedIdea\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is already released!\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Released. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Released. You can't evaluate it\");\n        }\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "74",
    "end_line": "74",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class JIdea extends JContent{\n\n    private JState state;\n    private List<JAttachment> attachments;\n\n    public JIdea(String title, String description) {\n        super(title, description);\n        this.state = new Draft();\n        this.attachments = new LinkedList<>();\n    }\n\n    public void discuss(String text){\n        this.state.discuss(text);\n    }\n\n    public void evaluate(JValuation valuation){\n        this.state.evaluate(valuation);\n    }\n\n    public void hold(){\n        this.state.hold();\n    }\n\n    public void release(){\n        this.state.release();\n    }\n\n    public void decline(){\n        this.state.decline();\n    }\n\n    public boolean isDeclined(){\n        return Utils.isInstance(this.state, DeclinedIdea.class);\n    }\n\n    public boolean isReleased(){\n        return Utils.isInstance(this.state, ReleasedIdea.class);\n    }\n\n    public String getCurrentDiscussion(){\n        return this.state.getCurrentDiscussion();\n    }\n\n    public JValuation getValuation(){\n        return this.state.getValuation();\n    }\n\n    public void addAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        this.attachments.add(attachment);\n    }\n\n    public List<JAttachment> getAttachments() {\n        return this.attachments;\n    }\n\n    public boolean removeAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        return attachments.remove(attachment);\n    }\n\n    @Override\n    public String toString() {\n        return \"Idea: \" + super.getTitle() + '\\n' + super.getDescription();\n    }\n\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || getClass() != object.getClass()) return false;\n        JIdea idea = (JIdea) object;\n        return  Objects.equals(idea.getTitle(),       this.getTitle()) &&\n                Objects.equals(idea.getDescription(), this.getDescription());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(this.getTitle(), this.getDescription());\n    }\n\n    public abstract class JState {\n        private JValuation valuation;\n        private String currentDiscussion = \"\";\n\n        public void hold() {};\n        public void release(){};\n        public void decline(){};\n\n        public void discuss(String currentDiscussion) {\n            Validator.checkParam(currentDiscussion);\n            this.currentDiscussion += currentDiscussion + '\\n';\n        }\n\n        public void evaluate(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n\n        public String getCurrentDiscussion() {\n            return currentDiscussion;\n        }\n\n        public JValuation getValuation() {\n            return valuation;\n        }\n\n        public void setCurrentDiscussion(String currentDiscussion) {\n            this.currentDiscussion = Validator.checkParam(currentDiscussion);\n        }\n        public void setValuation(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n    }\n    public class Draft extends JState {\n\n        @Override\n        public void hold() {\n            state = new OpenDraft();\n        }\n\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void discuss(String text){\n            throw new IllegalStateException(\"Can be discussed: This is only Draft\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Can be evaluated: This is only Draft\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Can be released: This is only Draft\");\n        }\n    }\n    public class OpenDraft extends JState{\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void hold() {\n            state = new ApprovedIdea();\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released yet: OpenDraft only\");\n        }\n    }\n    public class DeclinedIdea extends JState{\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is declined. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is declined. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is declined. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is declined. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Idea is declined. You can't release it\");\n        }\n    }\n    public class ApprovedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is Approved. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is Approved. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Approved. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Approved. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            state = new ReleasedIdea();\n        }\n    }\n    public class ReleasedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Cannot be holed: ReleasedIdea\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released: ReleasedIdea\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is already released!\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Released. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Released. You can't evaluate it\");\n        }\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "75",
    "end_line": "75",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class JIdea extends JContent{\n\n    private JState state;\n    private List<JAttachment> attachments;\n\n    public JIdea(String title, String description) {\n        super(title, description);\n        this.state = new Draft();\n        this.attachments = new LinkedList<>();\n    }\n\n    public void discuss(String text){\n        this.state.discuss(text);\n    }\n\n    public void evaluate(JValuation valuation){\n        this.state.evaluate(valuation);\n    }\n\n    public void hold(){\n        this.state.hold();\n    }\n\n    public void release(){\n        this.state.release();\n    }\n\n    public void decline(){\n        this.state.decline();\n    }\n\n    public boolean isDeclined(){\n        return Utils.isInstance(this.state, DeclinedIdea.class);\n    }\n\n    public boolean isReleased(){\n        return Utils.isInstance(this.state, ReleasedIdea.class);\n    }\n\n    public String getCurrentDiscussion(){\n        return this.state.getCurrentDiscussion();\n    }\n\n    public JValuation getValuation(){\n        return this.state.getValuation();\n    }\n\n    public void addAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        this.attachments.add(attachment);\n    }\n\n    public List<JAttachment> getAttachments() {\n        return this.attachments;\n    }\n\n    public boolean removeAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        return attachments.remove(attachment);\n    }\n\n    @Override\n    public String toString() {\n        return \"Idea: \" + super.getTitle() + '\\n' + super.getDescription();\n    }\n\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || getClass() != object.getClass()) return false;\n        JIdea idea = (JIdea) object;\n        return  Objects.equals(idea.getTitle(),       this.getTitle()) &&\n                Objects.equals(idea.getDescription(), this.getDescription());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(this.getTitle(), this.getDescription());\n    }\n\n    public abstract class JState {\n        private JValuation valuation;\n        private String currentDiscussion = \"\";\n\n        public void hold() {};\n        public void release(){};\n        public void decline(){};\n\n        public void discuss(String currentDiscussion) {\n            Validator.checkParam(currentDiscussion);\n            this.currentDiscussion += currentDiscussion + '\\n';\n        }\n\n        public void evaluate(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n\n        public String getCurrentDiscussion() {\n            return currentDiscussion;\n        }\n\n        public JValuation getValuation() {\n            return valuation;\n        }\n\n        public void setCurrentDiscussion(String currentDiscussion) {\n            this.currentDiscussion = Validator.checkParam(currentDiscussion);\n        }\n        public void setValuation(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n    }\n    public class Draft extends JState {\n\n        @Override\n        public void hold() {\n            state = new OpenDraft();\n        }\n\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void discuss(String text){\n            throw new IllegalStateException(\"Can be discussed: This is only Draft\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Can be evaluated: This is only Draft\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Can be released: This is only Draft\");\n        }\n    }\n    public class OpenDraft extends JState{\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void hold() {\n            state = new ApprovedIdea();\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released yet: OpenDraft only\");\n        }\n    }\n    public class DeclinedIdea extends JState{\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is declined. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is declined. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is declined. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is declined. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Idea is declined. You can't release it\");\n        }\n    }\n    public class ApprovedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is Approved. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is Approved. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Approved. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Approved. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            state = new ReleasedIdea();\n        }\n    }\n    public class ReleasedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Cannot be holed: ReleasedIdea\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released: ReleasedIdea\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is already released!\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Released. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Released. You can't evaluate it\");\n        }\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Abbreviation in name 'JState' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "86",
    "end_line": "86",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class JIdea extends JContent{\n\n    private JState state;\n    private List<JAttachment> attachments;\n\n    public JIdea(String title, String description) {\n        super(title, description);\n        this.state = new Draft();\n        this.attachments = new LinkedList<>();\n    }\n\n    public void discuss(String text){\n        this.state.discuss(text);\n    }\n\n    public void evaluate(JValuation valuation){\n        this.state.evaluate(valuation);\n    }\n\n    public void hold(){\n        this.state.hold();\n    }\n\n    public void release(){\n        this.state.release();\n    }\n\n    public void decline(){\n        this.state.decline();\n    }\n\n    public boolean isDeclined(){\n        return Utils.isInstance(this.state, DeclinedIdea.class);\n    }\n\n    public boolean isReleased(){\n        return Utils.isInstance(this.state, ReleasedIdea.class);\n    }\n\n    public String getCurrentDiscussion(){\n        return this.state.getCurrentDiscussion();\n    }\n\n    public JValuation getValuation(){\n        return this.state.getValuation();\n    }\n\n    public void addAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        this.attachments.add(attachment);\n    }\n\n    public List<JAttachment> getAttachments() {\n        return this.attachments;\n    }\n\n    public boolean removeAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        return attachments.remove(attachment);\n    }\n\n    @Override\n    public String toString() {\n        return \"Idea: \" + super.getTitle() + '\\n' + super.getDescription();\n    }\n\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || getClass() != object.getClass()) return false;\n        JIdea idea = (JIdea) object;\n        return  Objects.equals(idea.getTitle(),       this.getTitle()) &&\n                Objects.equals(idea.getDescription(), this.getDescription());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(this.getTitle(), this.getDescription());\n    }\n\n    public abstract class JState {\n        private JValuation valuation;\n        private String currentDiscussion = \"\";\n\n        public void hold() {};\n        public void release(){};\n        public void decline(){};\n\n        public void discuss(String currentDiscussion) {\n            Validator.checkParam(currentDiscussion);\n            this.currentDiscussion += currentDiscussion + '\\n';\n        }\n\n        public void evaluate(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n\n        public String getCurrentDiscussion() {\n            return currentDiscussion;\n        }\n\n        public JValuation getValuation() {\n            return valuation;\n        }\n\n        public void setCurrentDiscussion(String currentDiscussion) {\n            this.currentDiscussion = Validator.checkParam(currentDiscussion);\n        }\n        public void setValuation(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n    }\n    public class Draft extends JState {\n\n        @Override\n        public void hold() {\n            state = new OpenDraft();\n        }\n\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void discuss(String text){\n            throw new IllegalStateException(\"Can be discussed: This is only Draft\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Can be evaluated: This is only Draft\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Can be released: This is only Draft\");\n        }\n    }\n    public class OpenDraft extends JState{\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void hold() {\n            state = new ApprovedIdea();\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released yet: OpenDraft only\");\n        }\n    }\n    public class DeclinedIdea extends JState{\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is declined. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is declined. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is declined. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is declined. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Idea is declined. You can't release it\");\n        }\n    }\n    public class ApprovedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is Approved. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is Approved. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Approved. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Approved. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            state = new ReleasedIdea();\n        }\n    }\n    public class ReleasedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Cannot be holed: ReleasedIdea\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released: ReleasedIdea\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is already released!\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Released. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Released. You can't evaluate it\");\n        }\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Name 'JState' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "86",
    "end_line": "86",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class JIdea extends JContent{\n\n    private JState state;\n    private List<JAttachment> attachments;\n\n    public JIdea(String title, String description) {\n        super(title, description);\n        this.state = new Draft();\n        this.attachments = new LinkedList<>();\n    }\n\n    public void discuss(String text){\n        this.state.discuss(text);\n    }\n\n    public void evaluate(JValuation valuation){\n        this.state.evaluate(valuation);\n    }\n\n    public void hold(){\n        this.state.hold();\n    }\n\n    public void release(){\n        this.state.release();\n    }\n\n    public void decline(){\n        this.state.decline();\n    }\n\n    public boolean isDeclined(){\n        return Utils.isInstance(this.state, DeclinedIdea.class);\n    }\n\n    public boolean isReleased(){\n        return Utils.isInstance(this.state, ReleasedIdea.class);\n    }\n\n    public String getCurrentDiscussion(){\n        return this.state.getCurrentDiscussion();\n    }\n\n    public JValuation getValuation(){\n        return this.state.getValuation();\n    }\n\n    public void addAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        this.attachments.add(attachment);\n    }\n\n    public List<JAttachment> getAttachments() {\n        return this.attachments;\n    }\n\n    public boolean removeAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        return attachments.remove(attachment);\n    }\n\n    @Override\n    public String toString() {\n        return \"Idea: \" + super.getTitle() + '\\n' + super.getDescription();\n    }\n\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || getClass() != object.getClass()) return false;\n        JIdea idea = (JIdea) object;\n        return  Objects.equals(idea.getTitle(),       this.getTitle()) &&\n                Objects.equals(idea.getDescription(), this.getDescription());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(this.getTitle(), this.getDescription());\n    }\n\n    public abstract class JState {\n        private JValuation valuation;\n        private String currentDiscussion = \"\";\n\n        public void hold() {};\n        public void release(){};\n        public void decline(){};\n\n        public void discuss(String currentDiscussion) {\n            Validator.checkParam(currentDiscussion);\n            this.currentDiscussion += currentDiscussion + '\\n';\n        }\n\n        public void evaluate(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n\n        public String getCurrentDiscussion() {\n            return currentDiscussion;\n        }\n\n        public JValuation getValuation() {\n            return valuation;\n        }\n\n        public void setCurrentDiscussion(String currentDiscussion) {\n            this.currentDiscussion = Validator.checkParam(currentDiscussion);\n        }\n        public void setValuation(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n    }\n    public class Draft extends JState {\n\n        @Override\n        public void hold() {\n            state = new OpenDraft();\n        }\n\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void discuss(String text){\n            throw new IllegalStateException(\"Can be discussed: This is only Draft\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Can be evaluated: This is only Draft\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Can be released: This is only Draft\");\n        }\n    }\n    public class OpenDraft extends JState{\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void hold() {\n            state = new ApprovedIdea();\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released yet: OpenDraft only\");\n        }\n    }\n    public class DeclinedIdea extends JState{\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is declined. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is declined. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is declined. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is declined. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Idea is declined. You can't release it\");\n        }\n    }\n    public class ApprovedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is Approved. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is Approved. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Approved. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Approved. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            state = new ReleasedIdea();\n        }\n    }\n    public class ReleasedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Cannot be holed: ReleasedIdea\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released: ReleasedIdea\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is already released!\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Released. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Released. You can't evaluate it\");\n        }\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'currentDiscussion' hides a field.",
    "priority": "error",
    "start_line": "94",
    "end_line": "94",
    "start_column": "36",
    "end_column": "36",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class JIdea extends JContent{\n\n    private JState state;\n    private List<JAttachment> attachments;\n\n    public JIdea(String title, String description) {\n        super(title, description);\n        this.state = new Draft();\n        this.attachments = new LinkedList<>();\n    }\n\n    public void discuss(String text){\n        this.state.discuss(text);\n    }\n\n    public void evaluate(JValuation valuation){\n        this.state.evaluate(valuation);\n    }\n\n    public void hold(){\n        this.state.hold();\n    }\n\n    public void release(){\n        this.state.release();\n    }\n\n    public void decline(){\n        this.state.decline();\n    }\n\n    public boolean isDeclined(){\n        return Utils.isInstance(this.state, DeclinedIdea.class);\n    }\n\n    public boolean isReleased(){\n        return Utils.isInstance(this.state, ReleasedIdea.class);\n    }\n\n    public String getCurrentDiscussion(){\n        return this.state.getCurrentDiscussion();\n    }\n\n    public JValuation getValuation(){\n        return this.state.getValuation();\n    }\n\n    public void addAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        this.attachments.add(attachment);\n    }\n\n    public List<JAttachment> getAttachments() {\n        return this.attachments;\n    }\n\n    public boolean removeAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        return attachments.remove(attachment);\n    }\n\n    @Override\n    public String toString() {\n        return \"Idea: \" + super.getTitle() + '\\n' + super.getDescription();\n    }\n\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || getClass() != object.getClass()) return false;\n        JIdea idea = (JIdea) object;\n        return  Objects.equals(idea.getTitle(),       this.getTitle()) &&\n                Objects.equals(idea.getDescription(), this.getDescription());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(this.getTitle(), this.getDescription());\n    }\n\n    public abstract class JState {\n        private JValuation valuation;\n        private String currentDiscussion = \"\";\n\n        public void hold() {};\n        public void release(){};\n        public void decline(){};\n\n        public void discuss(String currentDiscussion) {\n            Validator.checkParam(currentDiscussion);\n            this.currentDiscussion += currentDiscussion + '\\n';\n        }\n\n        public void evaluate(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n\n        public String getCurrentDiscussion() {\n            return currentDiscussion;\n        }\n\n        public JValuation getValuation() {\n            return valuation;\n        }\n\n        public void setCurrentDiscussion(String currentDiscussion) {\n            this.currentDiscussion = Validator.checkParam(currentDiscussion);\n        }\n        public void setValuation(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n    }\n    public class Draft extends JState {\n\n        @Override\n        public void hold() {\n            state = new OpenDraft();\n        }\n\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void discuss(String text){\n            throw new IllegalStateException(\"Can be discussed: This is only Draft\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Can be evaluated: This is only Draft\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Can be released: This is only Draft\");\n        }\n    }\n    public class OpenDraft extends JState{\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void hold() {\n            state = new ApprovedIdea();\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released yet: OpenDraft only\");\n        }\n    }\n    public class DeclinedIdea extends JState{\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is declined. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is declined. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is declined. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is declined. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Idea is declined. You can't release it\");\n        }\n    }\n    public class ApprovedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is Approved. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is Approved. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Approved. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Approved. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            state = new ReleasedIdea();\n        }\n    }\n    public class ReleasedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Cannot be holed: ReleasedIdea\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released: ReleasedIdea\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is already released!\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Released. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Released. You can't evaluate it\");\n        }\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'valuation' hides a field.",
    "priority": "error",
    "start_line": "99",
    "end_line": "99",
    "start_column": "41",
    "end_column": "41",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class JIdea extends JContent{\n\n    private JState state;\n    private List<JAttachment> attachments;\n\n    public JIdea(String title, String description) {\n        super(title, description);\n        this.state = new Draft();\n        this.attachments = new LinkedList<>();\n    }\n\n    public void discuss(String text){\n        this.state.discuss(text);\n    }\n\n    public void evaluate(JValuation valuation){\n        this.state.evaluate(valuation);\n    }\n\n    public void hold(){\n        this.state.hold();\n    }\n\n    public void release(){\n        this.state.release();\n    }\n\n    public void decline(){\n        this.state.decline();\n    }\n\n    public boolean isDeclined(){\n        return Utils.isInstance(this.state, DeclinedIdea.class);\n    }\n\n    public boolean isReleased(){\n        return Utils.isInstance(this.state, ReleasedIdea.class);\n    }\n\n    public String getCurrentDiscussion(){\n        return this.state.getCurrentDiscussion();\n    }\n\n    public JValuation getValuation(){\n        return this.state.getValuation();\n    }\n\n    public void addAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        this.attachments.add(attachment);\n    }\n\n    public List<JAttachment> getAttachments() {\n        return this.attachments;\n    }\n\n    public boolean removeAttachment(JAttachment attachment){\n        Objects.requireNonNull(attachment);\n        return attachments.remove(attachment);\n    }\n\n    @Override\n    public String toString() {\n        return \"Idea: \" + super.getTitle() + '\\n' + super.getDescription();\n    }\n\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || getClass() != object.getClass()) return false;\n        JIdea idea = (JIdea) object;\n        return  Objects.equals(idea.getTitle(),       this.getTitle()) &&\n                Objects.equals(idea.getDescription(), this.getDescription());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(this.getTitle(), this.getDescription());\n    }\n\n    public abstract class JState {\n        private JValuation valuation;\n        private String currentDiscussion = \"\";\n\n        public void hold() {};\n        public void release(){};\n        public void decline(){};\n\n        public void discuss(String currentDiscussion) {\n            Validator.checkParam(currentDiscussion);\n            this.currentDiscussion += currentDiscussion + '\\n';\n        }\n\n        public void evaluate(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n\n        public String getCurrentDiscussion() {\n            return currentDiscussion;\n        }\n\n        public JValuation getValuation() {\n            return valuation;\n        }\n\n        public void setCurrentDiscussion(String currentDiscussion) {\n            this.currentDiscussion = Validator.checkParam(currentDiscussion);\n        }\n        public void setValuation(JValuation valuation) {\n            this.valuation = Objects.requireNonNull(valuation);\n        }\n    }\n    public class Draft extends JState {\n\n        @Override\n        public void hold() {\n            state = new OpenDraft();\n        }\n\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void discuss(String text){\n            throw new IllegalStateException(\"Can be discussed: This is only Draft\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Can be evaluated: This is only Draft\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Can be released: This is only Draft\");\n        }\n    }\n    public class OpenDraft extends JState{\n        @Override\n        public void decline() {\n            state = new DeclinedIdea();\n        }\n\n        @Override\n        public void hold() {\n            state = new ApprovedIdea();\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released yet: OpenDraft only\");\n        }\n    }\n    public class DeclinedIdea extends JState{\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is declined. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is declined. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is declined. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is declined. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Idea is declined. You can't release it\");\n        }\n    }\n    public class ApprovedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Idea is Approved. You can't hold it\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is Approved. You can't decline it\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Approved. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Approved. You can't evaluate it\");\n        }\n\n        @Override\n        public void release() {\n            state = new ReleasedIdea();\n        }\n    }\n    public class ReleasedIdea extends JState {\n        @Override\n        public void hold() {\n            throw new IllegalStateException(\"Cannot be holed: ReleasedIdea\");\n        }\n\n        @Override\n        public void release() {\n            throw new IllegalStateException(\"Cannot be released: ReleasedIdea\");\n        }\n\n        @Override\n        public void decline() {\n            throw new IllegalStateException(\"Idea is already released!\");\n        }\n\n        @Override\n        public void discuss(String currentDiscussion) {\n            throw new IllegalStateException(\"Idea is Released. You can't discuss it\");\n        }\n\n        @Override\n        public void evaluate(JValuation valuation) {\n            throw new IllegalStateException(\"Idea is Released. You can't evaluate it\");\n        }\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Abbreviation in name 'JIdeaPool' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "59",
    "end_line": "59",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "60",
    "end_line": "60",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "67",
    "end_line": "67",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "68",
    "end_line": "68",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "69",
    "end_line": "69",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "80",
    "end_line": "80",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "81",
    "end_line": "81",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Overload methods should not be split. Previous overloaded method located at line '55'.",
    "priority": "error",
    "start_line": "95",
    "end_line": "95",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "OverloadMethodsDeclarationOrder",
      "explanation": "Overloaded methods should be placed next to each other to increase readability. Overloaded methods are methods, which have the same name but different sets of parameters.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'while' construct must use '{}'s.",
    "priority": "error",
    "start_line": "99",
    "end_line": "99",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "100",
    "end_line": "100",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\npublic class JIdeaPool {\n    private Map<JTopic, Set<JIdea>> pool;\n\n    public JIdeaPool() {\n        this.pool = new HashMap<>();\n    }\n\n    public void add(JTopic topic) {\n        Objects.requireNonNull(topic);\n        if (!pool.containsKey(topic)) pool.put(topic, new HashSet<>());\n    }\n\n    public void add(JIdea idea, JTopic topic) {\n        Objects.requireNonNull(idea);\n        Objects.requireNonNull(topic);\n        // TODO: Refactor it later (never)\n        boolean ideaFound = false;\n        if (this.pool.containsKey(topic)) {\n            Set<JIdea> setOfIdeas = this.pool.get(topic);\n            for (JIdea i : setOfIdeas) {\n                if (i.getTitle().equals(idea.getTitle())) {\n                    ideaFound = true;\n                    break;\n                }\n            }\n            if (!ideaFound) setOfIdeas.add(idea);\n        }\n        else {\n            Collection<Set<JIdea>> ideas = pool.values();\n            for (Set<JIdea> set : ideas){\n                for (JIdea i : set){\n                    if (idea.getTitle().equals(i.getTitle()) && idea != i) {\n                        ideaFound = true;\n                        break;\n                    }\n                }\n            }\n            if (!ideaFound) {\n                Set<JIdea> newIdeaSet = new HashSet<>();\n                newIdeaSet.add(idea);\n                this.pool.put(topic, newIdeaSet);\n            }\n        }\n    }\n\n    public boolean remove(JTopic topic) {\n        Objects.requireNonNull(topic);\n        return pool.remove(topic) != null;\n    }\n\n    public boolean remove(JIdea ideaToRemove) {\n        Objects.requireNonNull(ideaToRemove);\n        Collection<Set<JIdea>> ideas = pool.values();\n        boolean removed = false;\n        for (Set<JIdea> setOfIdeas : ideas)\n            if (setOfIdeas.remove(ideaToRemove)) removed = true;\n        return removed;\n    }\n\n    public JIdea getIdea(String title) {\n        Validator.checkParam(title);\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                if (idea.getTitle().equals(title)) return idea;\n        return null;\n    }\n\n    public int numberOfTopics() {\n        return pool.size();\n    }\n\n    public int numberOfIdeas() {\n        Set<String> uniq = new HashSet<>();\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas)\n            for (JIdea idea : setOfIdeas)\n                uniq.add(idea.getTitle());\n        return uniq.size();\n    }\n\n\n    public void removeDeclined() {\n        this.remove(JIdea::isDeclined);\n    }\n\n    public void removeReleased() {\n        this.remove(JIdea::isReleased);\n    }\n\n    private void remove(Predicate<JIdea> predicate){\n        Collection<Set<JIdea>> ideas = pool.values();\n        for (Set<JIdea> setOfIdeas : ideas) {\n            Iterator<JIdea> iterator = setOfIdeas.iterator();\n            while (iterator.hasNext())\n                if (predicate.test(iterator.next()))\n                    iterator.remove();\n        }\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Abbreviation in name 'JMember' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class JMember implements Observer {\n    private Set<JTopic> topics  = new HashSet<>();\n\n    @Override\n    public void update(Observable jTopic, Object o) {\n        JTopic topic;\n        if (jTopic instanceof JTopic) {\n            topic = (JTopic) jTopic;\n            System.out.println(\"The topic \" + topic.getId() + \" has been updated!\");\n        }\n    }\n\n    public void subscribe(JTopic topic) {\n        Objects.requireNonNull(topic);\n        topic.addObserver(this);\n        this.topics.add(topic);\n    }\n\n    public void unsubscribe(JTopic topic) {\n        Objects.requireNonNull(topic);\n        topic.deleteObserver(this);\n        this.topics.remove(topic);\n    }\n\n    public Set<JTopic> getSubscribedTopics() {\n        return this.topics;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Abbreviation in name 'JTopic' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class JTopic extends JContent {\n    private int id;\n\n    public JTopic(String title, String description, int id){\n        super(title, description);\n        this.id = Validator.checkParam(id);\n    }\n\n    public int getId() {\n        return this.id;\n    }\n\n    @Override\n    public String toString() {\n        return \"Topic: \" + super.getTitle() + '\\n' +\n                super.getDescription();\n    }\n\n    public void setTitle(String title) {\n        super.setTitle(title);\n        this.not();\n    }\n\n    public void setDescription(String description) {\n        super.setDescription(description);\n        this.not();\n    }\n\n    private void not() {\n        setChanged();\n        notifyObservers(this);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Abbreviation in name 'JValuation' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class JValuation extends JContent {\n\n    public JValuation(String title, String description) {\n        super(title, description);\n    }\n\n    @Override\n    public String toString() {\n        return \"Valuation: \" + super.getTitle() + '\\n'\n                + super.getDescription();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Utils {\n\n    public static boolean isInstance(Object object, Class clazz){\n        return clazz.isInstance(object);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static void checkParam(String... strings){\n        for (String string : strings){\n            checkParam(string);\n        }\n    }\n\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static int checkParam(int i){\n        if (i<0) throw new IllegalArgumentException();\n        return i;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static void checkParam(String... strings){\n        for (String string : strings){\n            checkParam(string);\n        }\n    }\n\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static int checkParam(int i){\n        if (i<0) throw new IllegalArgumentException();\n        return i;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "CoolIdeas",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static void checkParam(String... strings){\n        for (String string : strings){\n            checkParam(string);\n        }\n    }\n\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static int checkParam(int i){\n        if (i<0) throw new IllegalArgumentException();\n        return i;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Project Management",
    "message": "Abbreviation in name 'IProject' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.List;\n\ninterface IProject {\n    void setTask(Task newTask);\n    double getDuration();\n    long getTotalCost();\n    List<Deliverable> getDeliverables();\n}"
  },
  {
    "user": "4",
    "task": "Project Management",
    "message": "Name 'ProjectItem' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.time.LocalDate;\nimport java.util.Map;\n\npublic abstract class ProjectItem {\n    private double rate;\n    private String name;\n    private String details;\n\n\n    public ProjectItem(String name, String details, Double rate) {\n        this.name = Validator.checkParam(name);\n        this.details = Validator.checkParam(details);\n        this.rate = Validator.checkParam(rate);\n    }\n\n\n    public long getCostEstimate(){\n        double timeCost = this.rate * this.getTimeRequired();\n        double totalCost = timeCost + this.getMaterialCost();\n        return Math.round(totalCost);\n    }\n\n    public abstract double getTimeRequired();\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "4",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class Task extends ProjectItem {\n    private List<ProjectItem> projectItems;\n\n    public Task(String name, String details, double rate) {\n        super(name, details, rate);\n        this.projectItems = new LinkedList<>();\n    }\n\n    public void addProjectItem(ProjectItem projectItem){\n        Objects.requireNonNull(projectItem);\n        projectItems.add(projectItem);\n    }\n\n    public void removeProjectItem(ProjectItem projectItem){\n        Objects.requireNonNull(projectItem);\n        projectItems.remove(projectItem);\n    }\n\n    public List<Deliverable> allDeliverables(){\n        List<Deliverable> deliverables = new LinkedList<>();\n\n        this.projectItems.forEach(item -> {\n            if (item instanceof Deliverable)\n                deliverables.add((Deliverable) item);\n            if (item instanceof Task)\n                deliverables.addAll(\n                        ((Task) item).allDeliverables()\n                );\n        });\n\n        return deliverables;\n    }\n\n    @Override\n    public double getTimeRequired() {\n        double time = projectItems\n                .stream()\n                .mapToDouble(ProjectItem::getTimeRequired)\n                .sum();\n        return time;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        long totalCoost = projectItems\n                .stream()\n                .mapToLong(ProjectItem::getMaterialCost)\n                .sum();\n        return totalCoost;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class Task extends ProjectItem {\n    private List<ProjectItem> projectItems;\n\n    public Task(String name, String details, double rate) {\n        super(name, details, rate);\n        this.projectItems = new LinkedList<>();\n    }\n\n    public void addProjectItem(ProjectItem projectItem){\n        Objects.requireNonNull(projectItem);\n        projectItems.add(projectItem);\n    }\n\n    public void removeProjectItem(ProjectItem projectItem){\n        Objects.requireNonNull(projectItem);\n        projectItems.remove(projectItem);\n    }\n\n    public List<Deliverable> allDeliverables(){\n        List<Deliverable> deliverables = new LinkedList<>();\n\n        this.projectItems.forEach(item -> {\n            if (item instanceof Deliverable)\n                deliverables.add((Deliverable) item);\n            if (item instanceof Task)\n                deliverables.addAll(\n                        ((Task) item).allDeliverables()\n                );\n        });\n\n        return deliverables;\n    }\n\n    @Override\n    public double getTimeRequired() {\n        double time = projectItems\n                .stream()\n                .mapToDouble(ProjectItem::getTimeRequired)\n                .sum();\n        return time;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        long totalCoost = projectItems\n                .stream()\n                .mapToLong(ProjectItem::getMaterialCost)\n                .sum();\n        return totalCoost;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Project Management",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static long checkParam(long l){\n        if (l < 0) throw new IllegalArgumentException();\n        return l;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static long checkParam(long l){\n        if (l < 0) throw new IllegalArgumentException();\n        return l;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static long checkParam(long l){\n        if (l < 0) throw new IllegalArgumentException();\n        return l;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static long checkParam(long l){\n        if (l < 0) throw new IllegalArgumentException();\n        return l;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "'{' at column 51 should have line break after.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": "51",
    "end_column": "51",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n    private static int size;\n    private ListElement head;\n\n    // appends the specified element to the end of this list.\n    public void append(String data) {\n\n        // Initialize ListElement only incase of 1st element\n        if (this.head == null) {\n            this.head = new ListElement(data);\n            return;\n        }\n\n        ListElement tempElement = new ListElement(data);\n        ListElement currElement = this.head;\n\n        if (currElement != null) {\n\n            while (currElement.getNext() != null) { currElement = currElement.getNext(); }\n            currElement.setNext(tempElement);\n        }\n        incrementSize();\n\n    }\n\n    private static int getSize() { return size; }\n    private static void incrementSize() { size++; }\n    private void decrementSize() { size--; }\n\n    public String remove(String content) {\n        // Store head ListElement \n        ListElement currListElement = this.head, prev = null;\n        String data;\n        // \n        // CASE 1: \n        // If head ListElement itself holds the key to be deleted\n\n        if (currListElement != null && currListElement.getContent().equals(content) ) {\n            System.out.println(\"curElem = \" + currListElement.getContent());\n            System.out.println(\"content = \" + content);\n            System.out.println(\"Head = \" + this.head.getContent());\n            data = currListElement.getContent();\n            this.head = currListElement.getNext(); // Changed head\n\n\n            // Display the message \n            System.out.println(data + \" found and deleted head\");\n\n            // Return the updated List\n            decrementSize();\n            return data;\n        }\n\n\n        // \n        // CASE 2: \n        // If the key is somewhere other than at head \n        // \n\n        // Search for the key to be deleted, \n        // keep track of the previous ListElement \n        // as it is needed to change currListElement.next \n        while (currListElement != null && !currListElement.getContent().equals(content)) {\n            // If currListElement does not hold key \n            // continue to next ListElement \n            prev = currListElement;\n            currListElement = currListElement.getNext();\n        }\n\n        // If the key was present, it should be at currListElement \n        // Therefore the currListElement shall not be null \n        if (currListElement != null) {\n            // Since the key is at currListElement \n            // Unlink currListElement from linked list\n            data = currListElement.getContent();\n            Objects.requireNonNull(prev).setNext(currListElement.getNext());\n\n            // Display the message \n            System.out.println(data + \" found and deleted\");\n            decrementSize();\n            return data;\n        }\n\n        // \n        // CASE 3: The key is not present \n        // \n\n        // If key was not present in linked list \n        // currListElement should be null \n        if (currListElement == null) {\n            // Display the message \n            System.out.println(content + \" not found\");\n        }\n\n        // return the List\n        return null;\n    }\n\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n\n        if (this.head != null) {\n            ListElement currElement = this.head.getNext();\n            while (currElement != null) {\n                output.append(\"[\").append(currElement.getContent()).append(\"]\");\n                currElement = currElement.getNext();\n            }\n\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "'}' at column 90 should be alone on a line.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": "90",
    "end_column": "90",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n    private static int size;\n    private ListElement head;\n\n    // appends the specified element to the end of this list.\n    public void append(String data) {\n\n        // Initialize ListElement only incase of 1st element\n        if (this.head == null) {\n            this.head = new ListElement(data);\n            return;\n        }\n\n        ListElement tempElement = new ListElement(data);\n        ListElement currElement = this.head;\n\n        if (currElement != null) {\n\n            while (currElement.getNext() != null) { currElement = currElement.getNext(); }\n            currElement.setNext(tempElement);\n        }\n        incrementSize();\n\n    }\n\n    private static int getSize() { return size; }\n    private static void incrementSize() { size++; }\n    private void decrementSize() { size--; }\n\n    public String remove(String content) {\n        // Store head ListElement \n        ListElement currListElement = this.head, prev = null;\n        String data;\n        // \n        // CASE 1: \n        // If head ListElement itself holds the key to be deleted\n\n        if (currListElement != null && currListElement.getContent().equals(content) ) {\n            System.out.println(\"curElem = \" + currListElement.getContent());\n            System.out.println(\"content = \" + content);\n            System.out.println(\"Head = \" + this.head.getContent());\n            data = currListElement.getContent();\n            this.head = currListElement.getNext(); // Changed head\n\n\n            // Display the message \n            System.out.println(data + \" found and deleted head\");\n\n            // Return the updated List\n            decrementSize();\n            return data;\n        }\n\n\n        // \n        // CASE 2: \n        // If the key is somewhere other than at head \n        // \n\n        // Search for the key to be deleted, \n        // keep track of the previous ListElement \n        // as it is needed to change currListElement.next \n        while (currListElement != null && !currListElement.getContent().equals(content)) {\n            // If currListElement does not hold key \n            // continue to next ListElement \n            prev = currListElement;\n            currListElement = currListElement.getNext();\n        }\n\n        // If the key was present, it should be at currListElement \n        // Therefore the currListElement shall not be null \n        if (currListElement != null) {\n            // Since the key is at currListElement \n            // Unlink currListElement from linked list\n            data = currListElement.getContent();\n            Objects.requireNonNull(prev).setNext(currListElement.getNext());\n\n            // Display the message \n            System.out.println(data + \" found and deleted\");\n            decrementSize();\n            return data;\n        }\n\n        // \n        // CASE 3: The key is not present \n        // \n\n        // If key was not present in linked list \n        // currListElement should be null \n        if (currListElement == null) {\n            // Display the message \n            System.out.println(content + \" not found\");\n        }\n\n        // return the List\n        return null;\n    }\n\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n\n        if (this.head != null) {\n            ListElement currElement = this.head.getNext();\n            while (currElement != null) {\n                output.append(\"[\").append(currElement.getContent()).append(\"]\");\n                currElement = currElement.getNext();\n            }\n\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "'{' at column 34 should have line break after.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": "34",
    "end_column": "34",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n    private static int size;\n    private ListElement head;\n\n    // appends the specified element to the end of this list.\n    public void append(String data) {\n\n        // Initialize ListElement only incase of 1st element\n        if (this.head == null) {\n            this.head = new ListElement(data);\n            return;\n        }\n\n        ListElement tempElement = new ListElement(data);\n        ListElement currElement = this.head;\n\n        if (currElement != null) {\n\n            while (currElement.getNext() != null) { currElement = currElement.getNext(); }\n            currElement.setNext(tempElement);\n        }\n        incrementSize();\n\n    }\n\n    private static int getSize() { return size; }\n    private static void incrementSize() { size++; }\n    private void decrementSize() { size--; }\n\n    public String remove(String content) {\n        // Store head ListElement \n        ListElement currListElement = this.head, prev = null;\n        String data;\n        // \n        // CASE 1: \n        // If head ListElement itself holds the key to be deleted\n\n        if (currListElement != null && currListElement.getContent().equals(content) ) {\n            System.out.println(\"curElem = \" + currListElement.getContent());\n            System.out.println(\"content = \" + content);\n            System.out.println(\"Head = \" + this.head.getContent());\n            data = currListElement.getContent();\n            this.head = currListElement.getNext(); // Changed head\n\n\n            // Display the message \n            System.out.println(data + \" found and deleted head\");\n\n            // Return the updated List\n            decrementSize();\n            return data;\n        }\n\n\n        // \n        // CASE 2: \n        // If the key is somewhere other than at head \n        // \n\n        // Search for the key to be deleted, \n        // keep track of the previous ListElement \n        // as it is needed to change currListElement.next \n        while (currListElement != null && !currListElement.getContent().equals(content)) {\n            // If currListElement does not hold key \n            // continue to next ListElement \n            prev = currListElement;\n            currListElement = currListElement.getNext();\n        }\n\n        // If the key was present, it should be at currListElement \n        // Therefore the currListElement shall not be null \n        if (currListElement != null) {\n            // Since the key is at currListElement \n            // Unlink currListElement from linked list\n            data = currListElement.getContent();\n            Objects.requireNonNull(prev).setNext(currListElement.getNext());\n\n            // Display the message \n            System.out.println(data + \" found and deleted\");\n            decrementSize();\n            return data;\n        }\n\n        // \n        // CASE 3: The key is not present \n        // \n\n        // If key was not present in linked list \n        // currListElement should be null \n        if (currListElement == null) {\n            // Display the message \n            System.out.println(content + \" not found\");\n        }\n\n        // return the List\n        return null;\n    }\n\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n\n        if (this.head != null) {\n            ListElement currElement = this.head.getNext();\n            while (currElement != null) {\n                output.append(\"[\").append(currElement.getContent()).append(\"]\");\n                currElement = currElement.getNext();\n            }\n\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "'}' at column 49 should be alone on a line.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": "49",
    "end_column": "49",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n    private static int size;\n    private ListElement head;\n\n    // appends the specified element to the end of this list.\n    public void append(String data) {\n\n        // Initialize ListElement only incase of 1st element\n        if (this.head == null) {\n            this.head = new ListElement(data);\n            return;\n        }\n\n        ListElement tempElement = new ListElement(data);\n        ListElement currElement = this.head;\n\n        if (currElement != null) {\n\n            while (currElement.getNext() != null) { currElement = currElement.getNext(); }\n            currElement.setNext(tempElement);\n        }\n        incrementSize();\n\n    }\n\n    private static int getSize() { return size; }\n    private static void incrementSize() { size++; }\n    private void decrementSize() { size--; }\n\n    public String remove(String content) {\n        // Store head ListElement \n        ListElement currListElement = this.head, prev = null;\n        String data;\n        // \n        // CASE 1: \n        // If head ListElement itself holds the key to be deleted\n\n        if (currListElement != null && currListElement.getContent().equals(content) ) {\n            System.out.println(\"curElem = \" + currListElement.getContent());\n            System.out.println(\"content = \" + content);\n            System.out.println(\"Head = \" + this.head.getContent());\n            data = currListElement.getContent();\n            this.head = currListElement.getNext(); // Changed head\n\n\n            // Display the message \n            System.out.println(data + \" found and deleted head\");\n\n            // Return the updated List\n            decrementSize();\n            return data;\n        }\n\n\n        // \n        // CASE 2: \n        // If the key is somewhere other than at head \n        // \n\n        // Search for the key to be deleted, \n        // keep track of the previous ListElement \n        // as it is needed to change currListElement.next \n        while (currListElement != null && !currListElement.getContent().equals(content)) {\n            // If currListElement does not hold key \n            // continue to next ListElement \n            prev = currListElement;\n            currListElement = currListElement.getNext();\n        }\n\n        // If the key was present, it should be at currListElement \n        // Therefore the currListElement shall not be null \n        if (currListElement != null) {\n            // Since the key is at currListElement \n            // Unlink currListElement from linked list\n            data = currListElement.getContent();\n            Objects.requireNonNull(prev).setNext(currListElement.getNext());\n\n            // Display the message \n            System.out.println(data + \" found and deleted\");\n            decrementSize();\n            return data;\n        }\n\n        // \n        // CASE 3: The key is not present \n        // \n\n        // If key was not present in linked list \n        // currListElement should be null \n        if (currListElement == null) {\n            // Display the message \n            System.out.println(content + \" not found\");\n        }\n\n        // return the List\n        return null;\n    }\n\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n\n        if (this.head != null) {\n            ListElement currElement = this.head.getNext();\n            while (currElement != null) {\n                output.append(\"[\").append(currElement.getContent()).append(\"]\");\n                currElement = currElement.getNext();\n            }\n\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "'{' at column 41 should have line break after.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": "41",
    "end_column": "41",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n    private static int size;\n    private ListElement head;\n\n    // appends the specified element to the end of this list.\n    public void append(String data) {\n\n        // Initialize ListElement only incase of 1st element\n        if (this.head == null) {\n            this.head = new ListElement(data);\n            return;\n        }\n\n        ListElement tempElement = new ListElement(data);\n        ListElement currElement = this.head;\n\n        if (currElement != null) {\n\n            while (currElement.getNext() != null) { currElement = currElement.getNext(); }\n            currElement.setNext(tempElement);\n        }\n        incrementSize();\n\n    }\n\n    private static int getSize() { return size; }\n    private static void incrementSize() { size++; }\n    private void decrementSize() { size--; }\n\n    public String remove(String content) {\n        // Store head ListElement \n        ListElement currListElement = this.head, prev = null;\n        String data;\n        // \n        // CASE 1: \n        // If head ListElement itself holds the key to be deleted\n\n        if (currListElement != null && currListElement.getContent().equals(content) ) {\n            System.out.println(\"curElem = \" + currListElement.getContent());\n            System.out.println(\"content = \" + content);\n            System.out.println(\"Head = \" + this.head.getContent());\n            data = currListElement.getContent();\n            this.head = currListElement.getNext(); // Changed head\n\n\n            // Display the message \n            System.out.println(data + \" found and deleted head\");\n\n            // Return the updated List\n            decrementSize();\n            return data;\n        }\n\n\n        // \n        // CASE 2: \n        // If the key is somewhere other than at head \n        // \n\n        // Search for the key to be deleted, \n        // keep track of the previous ListElement \n        // as it is needed to change currListElement.next \n        while (currListElement != null && !currListElement.getContent().equals(content)) {\n            // If currListElement does not hold key \n            // continue to next ListElement \n            prev = currListElement;\n            currListElement = currListElement.getNext();\n        }\n\n        // If the key was present, it should be at currListElement \n        // Therefore the currListElement shall not be null \n        if (currListElement != null) {\n            // Since the key is at currListElement \n            // Unlink currListElement from linked list\n            data = currListElement.getContent();\n            Objects.requireNonNull(prev).setNext(currListElement.getNext());\n\n            // Display the message \n            System.out.println(data + \" found and deleted\");\n            decrementSize();\n            return data;\n        }\n\n        // \n        // CASE 3: The key is not present \n        // \n\n        // If key was not present in linked list \n        // currListElement should be null \n        if (currListElement == null) {\n            // Display the message \n            System.out.println(content + \" not found\");\n        }\n\n        // return the List\n        return null;\n    }\n\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n\n        if (this.head != null) {\n            ListElement currElement = this.head.getNext();\n            while (currElement != null) {\n                output.append(\"[\").append(currElement.getContent()).append(\"]\");\n                currElement = currElement.getNext();\n            }\n\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "'}' at column 51 should be alone on a line.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": "51",
    "end_column": "51",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n    private static int size;\n    private ListElement head;\n\n    // appends the specified element to the end of this list.\n    public void append(String data) {\n\n        // Initialize ListElement only incase of 1st element\n        if (this.head == null) {\n            this.head = new ListElement(data);\n            return;\n        }\n\n        ListElement tempElement = new ListElement(data);\n        ListElement currElement = this.head;\n\n        if (currElement != null) {\n\n            while (currElement.getNext() != null) { currElement = currElement.getNext(); }\n            currElement.setNext(tempElement);\n        }\n        incrementSize();\n\n    }\n\n    private static int getSize() { return size; }\n    private static void incrementSize() { size++; }\n    private void decrementSize() { size--; }\n\n    public String remove(String content) {\n        // Store head ListElement \n        ListElement currListElement = this.head, prev = null;\n        String data;\n        // \n        // CASE 1: \n        // If head ListElement itself holds the key to be deleted\n\n        if (currListElement != null && currListElement.getContent().equals(content) ) {\n            System.out.println(\"curElem = \" + currListElement.getContent());\n            System.out.println(\"content = \" + content);\n            System.out.println(\"Head = \" + this.head.getContent());\n            data = currListElement.getContent();\n            this.head = currListElement.getNext(); // Changed head\n\n\n            // Display the message \n            System.out.println(data + \" found and deleted head\");\n\n            // Return the updated List\n            decrementSize();\n            return data;\n        }\n\n\n        // \n        // CASE 2: \n        // If the key is somewhere other than at head \n        // \n\n        // Search for the key to be deleted, \n        // keep track of the previous ListElement \n        // as it is needed to change currListElement.next \n        while (currListElement != null && !currListElement.getContent().equals(content)) {\n            // If currListElement does not hold key \n            // continue to next ListElement \n            prev = currListElement;\n            currListElement = currListElement.getNext();\n        }\n\n        // If the key was present, it should be at currListElement \n        // Therefore the currListElement shall not be null \n        if (currListElement != null) {\n            // Since the key is at currListElement \n            // Unlink currListElement from linked list\n            data = currListElement.getContent();\n            Objects.requireNonNull(prev).setNext(currListElement.getNext());\n\n            // Display the message \n            System.out.println(data + \" found and deleted\");\n            decrementSize();\n            return data;\n        }\n\n        // \n        // CASE 3: The key is not present \n        // \n\n        // If key was not present in linked list \n        // currListElement should be null \n        if (currListElement == null) {\n            // Display the message \n            System.out.println(content + \" not found\");\n        }\n\n        // return the List\n        return null;\n    }\n\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n\n        if (this.head != null) {\n            ListElement currElement = this.head.getNext();\n            while (currElement != null) {\n                output.append(\"[\").append(currElement.getContent()).append(\"]\");\n                currElement = currElement.getNext();\n            }\n\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "'{' at column 34 should have line break after.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": "34",
    "end_column": "34",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n    private static int size;\n    private ListElement head;\n\n    // appends the specified element to the end of this list.\n    public void append(String data) {\n\n        // Initialize ListElement only incase of 1st element\n        if (this.head == null) {\n            this.head = new ListElement(data);\n            return;\n        }\n\n        ListElement tempElement = new ListElement(data);\n        ListElement currElement = this.head;\n\n        if (currElement != null) {\n\n            while (currElement.getNext() != null) { currElement = currElement.getNext(); }\n            currElement.setNext(tempElement);\n        }\n        incrementSize();\n\n    }\n\n    private static int getSize() { return size; }\n    private static void incrementSize() { size++; }\n    private void decrementSize() { size--; }\n\n    public String remove(String content) {\n        // Store head ListElement \n        ListElement currListElement = this.head, prev = null;\n        String data;\n        // \n        // CASE 1: \n        // If head ListElement itself holds the key to be deleted\n\n        if (currListElement != null && currListElement.getContent().equals(content) ) {\n            System.out.println(\"curElem = \" + currListElement.getContent());\n            System.out.println(\"content = \" + content);\n            System.out.println(\"Head = \" + this.head.getContent());\n            data = currListElement.getContent();\n            this.head = currListElement.getNext(); // Changed head\n\n\n            // Display the message \n            System.out.println(data + \" found and deleted head\");\n\n            // Return the updated List\n            decrementSize();\n            return data;\n        }\n\n\n        // \n        // CASE 2: \n        // If the key is somewhere other than at head \n        // \n\n        // Search for the key to be deleted, \n        // keep track of the previous ListElement \n        // as it is needed to change currListElement.next \n        while (currListElement != null && !currListElement.getContent().equals(content)) {\n            // If currListElement does not hold key \n            // continue to next ListElement \n            prev = currListElement;\n            currListElement = currListElement.getNext();\n        }\n\n        // If the key was present, it should be at currListElement \n        // Therefore the currListElement shall not be null \n        if (currListElement != null) {\n            // Since the key is at currListElement \n            // Unlink currListElement from linked list\n            data = currListElement.getContent();\n            Objects.requireNonNull(prev).setNext(currListElement.getNext());\n\n            // Display the message \n            System.out.println(data + \" found and deleted\");\n            decrementSize();\n            return data;\n        }\n\n        // \n        // CASE 3: The key is not present \n        // \n\n        // If key was not present in linked list \n        // currListElement should be null \n        if (currListElement == null) {\n            // Display the message \n            System.out.println(content + \" not found\");\n        }\n\n        // return the List\n        return null;\n    }\n\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n\n        if (this.head != null) {\n            ListElement currElement = this.head.getNext();\n            while (currElement != null) {\n                output.append(\"[\").append(currElement.getContent()).append(\"]\");\n                currElement = currElement.getNext();\n            }\n\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "'}' at column 44 should be alone on a line.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": "44",
    "end_column": "44",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n    private static int size;\n    private ListElement head;\n\n    // appends the specified element to the end of this list.\n    public void append(String data) {\n\n        // Initialize ListElement only incase of 1st element\n        if (this.head == null) {\n            this.head = new ListElement(data);\n            return;\n        }\n\n        ListElement tempElement = new ListElement(data);\n        ListElement currElement = this.head;\n\n        if (currElement != null) {\n\n            while (currElement.getNext() != null) { currElement = currElement.getNext(); }\n            currElement.setNext(tempElement);\n        }\n        incrementSize();\n\n    }\n\n    private static int getSize() { return size; }\n    private static void incrementSize() { size++; }\n    private void decrementSize() { size--; }\n\n    public String remove(String content) {\n        // Store head ListElement \n        ListElement currListElement = this.head, prev = null;\n        String data;\n        // \n        // CASE 1: \n        // If head ListElement itself holds the key to be deleted\n\n        if (currListElement != null && currListElement.getContent().equals(content) ) {\n            System.out.println(\"curElem = \" + currListElement.getContent());\n            System.out.println(\"content = \" + content);\n            System.out.println(\"Head = \" + this.head.getContent());\n            data = currListElement.getContent();\n            this.head = currListElement.getNext(); // Changed head\n\n\n            // Display the message \n            System.out.println(data + \" found and deleted head\");\n\n            // Return the updated List\n            decrementSize();\n            return data;\n        }\n\n\n        // \n        // CASE 2: \n        // If the key is somewhere other than at head \n        // \n\n        // Search for the key to be deleted, \n        // keep track of the previous ListElement \n        // as it is needed to change currListElement.next \n        while (currListElement != null && !currListElement.getContent().equals(content)) {\n            // If currListElement does not hold key \n            // continue to next ListElement \n            prev = currListElement;\n            currListElement = currListElement.getNext();\n        }\n\n        // If the key was present, it should be at currListElement \n        // Therefore the currListElement shall not be null \n        if (currListElement != null) {\n            // Since the key is at currListElement \n            // Unlink currListElement from linked list\n            data = currListElement.getContent();\n            Objects.requireNonNull(prev).setNext(currListElement.getNext());\n\n            // Display the message \n            System.out.println(data + \" found and deleted\");\n            decrementSize();\n            return data;\n        }\n\n        // \n        // CASE 3: The key is not present \n        // \n\n        // If key was not present in linked list \n        // currListElement should be null \n        if (currListElement == null) {\n            // Display the message \n            System.out.println(content + \" not found\");\n        }\n\n        // return the List\n        return null;\n    }\n\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n\n        if (this.head != null) {\n            ListElement currElement = this.head.getNext();\n            while (currElement != null) {\n                output.append(\"[\").append(currElement.getContent()).append(\"]\");\n                currElement = currElement.getNext();\n            }\n\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "Each variable declaration must be in its own statement.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": "9",
    "end_column": "9",
    "rule": {
      "identifier": "MultipleVariableDeclarations",
      "explanation": "Each variable declaration should reside in its own statement and line. This increases readability.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n    private static int size;\n    private ListElement head;\n\n    // appends the specified element to the end of this list.\n    public void append(String data) {\n\n        // Initialize ListElement only incase of 1st element\n        if (this.head == null) {\n            this.head = new ListElement(data);\n            return;\n        }\n\n        ListElement tempElement = new ListElement(data);\n        ListElement currElement = this.head;\n\n        if (currElement != null) {\n\n            while (currElement.getNext() != null) { currElement = currElement.getNext(); }\n            currElement.setNext(tempElement);\n        }\n        incrementSize();\n\n    }\n\n    private static int getSize() { return size; }\n    private static void incrementSize() { size++; }\n    private void decrementSize() { size--; }\n\n    public String remove(String content) {\n        // Store head ListElement \n        ListElement currListElement = this.head, prev = null;\n        String data;\n        // \n        // CASE 1: \n        // If head ListElement itself holds the key to be deleted\n\n        if (currListElement != null && currListElement.getContent().equals(content) ) {\n            System.out.println(\"curElem = \" + currListElement.getContent());\n            System.out.println(\"content = \" + content);\n            System.out.println(\"Head = \" + this.head.getContent());\n            data = currListElement.getContent();\n            this.head = currListElement.getNext(); // Changed head\n\n\n            // Display the message \n            System.out.println(data + \" found and deleted head\");\n\n            // Return the updated List\n            decrementSize();\n            return data;\n        }\n\n\n        // \n        // CASE 2: \n        // If the key is somewhere other than at head \n        // \n\n        // Search for the key to be deleted, \n        // keep track of the previous ListElement \n        // as it is needed to change currListElement.next \n        while (currListElement != null && !currListElement.getContent().equals(content)) {\n            // If currListElement does not hold key \n            // continue to next ListElement \n            prev = currListElement;\n            currListElement = currListElement.getNext();\n        }\n\n        // If the key was present, it should be at currListElement \n        // Therefore the currListElement shall not be null \n        if (currListElement != null) {\n            // Since the key is at currListElement \n            // Unlink currListElement from linked list\n            data = currListElement.getContent();\n            Objects.requireNonNull(prev).setNext(currListElement.getNext());\n\n            // Display the message \n            System.out.println(data + \" found and deleted\");\n            decrementSize();\n            return data;\n        }\n\n        // \n        // CASE 3: The key is not present \n        // \n\n        // If key was not present in linked list \n        // currListElement should be null \n        if (currListElement == null) {\n            // Display the message \n            System.out.println(content + \" not found\");\n        }\n\n        // return the List\n        return null;\n    }\n\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n\n        if (this.head != null) {\n            ListElement currElement = this.head.getNext();\n            while (currElement != null) {\n                output.append(\"[\").append(currElement.getContent()).append(\"]\");\n                currElement = currElement.getNext();\n            }\n\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass ListElement {\n\n\n    private String content;\n    private ListElement next;\n\n    public String getContent() {\n        return this.content.toString();\n    }\n\n    public void setContent(String content) {\n        if (content.isEmpty()) {\n            throw new IllegalArgumentException(\"Illegal argument value\");\n        }\n        else if (content == null){\n            throw new NullPointerException(\"The argument 'content' cannot be empty!\");\n        }\n        else this.content = content;\n    }\n\n    public ListElement getNext() {\n        return next;\n    }\n\n    public void setNext(ListElement next) {\n        this.next = next;\n    }\n\n    public boolean hasNext(){\n        return getNext() == null;\n    }\n\n    public ListElement(String content) {\n        setContent(content);\n        setNext(null);\n    }\n\n\n}"
  },
  {
    "user": "4",
    "task": "LinkedList",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass ListElement {\n\n\n    private String content;\n    private ListElement next;\n\n    public String getContent() {\n        return this.content.toString();\n    }\n\n    public void setContent(String content) {\n        if (content.isEmpty()) {\n            throw new IllegalArgumentException(\"Illegal argument value\");\n        }\n        else if (content == null){\n            throw new NullPointerException(\"The argument 'content' cannot be empty!\");\n        }\n        else this.content = content;\n    }\n\n    public ListElement getNext() {\n        return next;\n    }\n\n    public void setNext(ListElement next) {\n        this.next = next;\n    }\n\n    public boolean hasNext(){\n        return getNext() == null;\n    }\n\n    public ListElement(String content) {\n        setContent(content);\n        setNext(null);\n    }\n\n\n}"
  },
  {
    "user": "4",
    "task": "Garage Door",
    "message": "Name 'DoorState' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class GarageDoor {\n\n    private Motor motor;\n    private DoorState currentState;\n\n\n    GarageDoor() {\n        this.motor = new Motor();\n        this.currentState = new Closed();\n    }\n    void openDoor() {\n        currentState.openDoor();\n    }\n    void closeDoor(){\n        currentState.closeDoor();\n    }\n    void stopper() {\n        currentState.stopper();\n    }\n\n    private Motor getMotor() {\n        return this.motor;\n    }\n\n    private void setState(DoorState doorState){\n        this.currentState = doorState;\n    }\n\n    protected abstract class DoorState {\n        public abstract void openDoor();\n        public abstract void closeDoor();\n        public abstract void stopper();\n    }\n\n    protected class Closed extends DoorState {\n        @Override\n        public void openDoor(){\n            setState(new Opening());\n            getMotor().upwards();\n        }\n\n        @Override\n        public void stopper(){\n            throw new IllegalStateException();\n        }\n\n        @Override\n        public void closeDoor() {\n            throw new IllegalStateException();\n        }\n    }\n\n    protected class Opening extends DoorState {\n        @Override\n        public void openDoor() {\n            throw new IllegalStateException();\n        }\n\n        @Override\n        public void closeDoor(){\n            getMotor().downwards();\n            setState(new Closing());\n        }\n\n        @Override\n        public void stopper(){\n            getMotor().stop();\n            setState(new Open());\n        }\n    }\n\n    protected class Open extends DoorState {\n        @Override\n        public void openDoor() {\n            throw new IllegalStateException();\n        }\n\n        @Override\n        public void closeDoor(){\n            getMotor().downwards();\n            setState(new Closing());\n        }\n\n        @Override\n        public void stopper(){\n            throw new IllegalStateException();\n        }\n    }\n    protected class Closing extends DoorState {\n\n        @Override\n        public void openDoor(){\n            getMotor().upwards();\n            setState(new Opening());\n        }\n\n        @Override\n        public void closeDoor() {\n            throw new IllegalStateException();\n        }\n\n        @Override\n        public void stopper(){\n            getMotor().stop();\n            setState(new Closed());\n        }\n    }\n\n\n\n\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "Variable 'balance' explicitly initialized to '0' (default value for its type).",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "20",
    "end_column": "20",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "37",
    "end_line": "37",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "41",
    "end_line": "41",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "Name 'AccountState' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "57",
    "end_line": "57",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "59",
    "end_line": "59",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "64",
    "end_line": "64",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "66",
    "end_line": "66",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "67",
    "end_line": "67",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "82",
    "end_line": "82",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "86",
    "end_line": "86",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'1.01' is a magic number.",
    "priority": "error",
    "start_line": "91",
    "end_line": "91",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "116",
    "end_line": "116",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'1.03' is a magic number.",
    "priority": "error",
    "start_line": "129",
    "end_line": "129",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "146",
    "end_line": "146",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "147",
    "end_line": "147",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Bank Account",
    "message": "'1.05' is a magic number.",
    "priority": "error",
    "start_line": "156",
    "end_line": "156",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class BankAccount {\n    private double balance = 0.0;\n    private String accountNumber;\n    private double lineOfCredit;\n    private AccountState state;\n    private AccountState positive = new Positive();\n    private AccountState negative = new Negative();\n    private AccountState frozen = new Frozen();\n    private AccountState closed = new Closed();\n\n    public BankAccount(String accountNumber, double lineOfCredit) {\n        if (accountNumber.isEmpty()) throw new IllegalArgumentException();\n        this.accountNumber = Objects.requireNonNull(accountNumber);\n        this.lineOfCredit = lineOfCredit;\n        this.state = positive;\n    }\n\n    public String getState() {\n        return state.toString();\n    }\n\n    public boolean close() {\n        if (this.balance == 0.0) {\n            this.state = this.closed;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return this.balance;\n    }\n\n    public boolean payIn(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payIn(amount);\n    }\n    public boolean payOff(double amount) {\n        if (amount <= 0.0) throw new IllegalArgumentException();\n        return this.state.payOff(amount);\n    }\n\n    public void payInterest() {\n        this.state.payInterest();\n    }\n\n    public void printBalance() {\n        this.state.printBalance();\n    }\n\n    public String getAccountNumber() {\n        return this.accountNumber;\n    }\n\n    abstract class AccountState {\n        public boolean payIn(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            balance += amount;\n            return true;\n        }\n        public boolean payOff(double amount) {\n            if (amount <= 0) throw new IllegalArgumentException();\n            var downBorder = lineOfCredit * (-1);\n            if (balance - amount < downBorder) return false;\n            else balance -= amount;\n            return true;\n        }\n        public abstract void printBalance();\n        public void payInterest(){};\n    }\n\n    class Positive extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            return super.payIn(amount);\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            } else if (balance < 0) state = negative;\n            return true;\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.01;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is POSITIVE: +\" + balance + \".\");\n        }\n\n        @Override\n        public String toString() {\n            return \"Positive\";\n        }\n\n    }\n    class Negative extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance >= 0) {\n                state = positive;\n            }\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            boolean doTransaction = super.payOff(amount);\n            if (!doTransaction) return false;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n            return true;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \".\");\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.03;\n            if (balance <= -lineOfCredit) {\n                balance = -lineOfCredit;\n                state = frozen;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Negative\";\n        }\n\n    }\n    class Frozen extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            super.payIn(amount);\n            if (balance > -lineOfCredit) state = negative;\n            if (balance >= 0) state = positive;\n            return true;\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void payInterest() {\n            balance = balance * 1.05;\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"Balance is NEGATIVE: \" + balance + \". You need to pay in money.\");\n        }\n        @Override\n        public String toString() {\n            return \"Frozen\";\n        }\n\n    }\n    class Closed extends AccountState {\n        @Override\n        public boolean payIn(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public boolean payOff(double amount) {\n            throw new IllegalStateException();\n        }\n        @Override\n        public void printBalance() {\n            System.out.println(\"This account is CLOSED. The balance is 0.\");\n        }\n        @Override\n        public void payInterest() {\n            throw new IllegalStateException();\n        }\n        @Override\n        public String toString() {\n            return \"Closed\";\n        }\n\n    }\n\n}"
  },
  {
    "user": "4",
    "task": "Desktop Search Engine",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "EmptyCatchBlock",
      "explanation": "Exceptions should be handled in the corresponding catch block. Not handling an exception is error prone.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class IndexTest {\n\n    private Index i;\n    private Resource res;\n    private Resource res2;\n    private String[] wishes;\n\n    @Before\n    public void setUp(){\n        i = new Index();\n        PlainTextCollector coll = new PlainTextCollector();\n        res = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        res2 = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        wishes = \"are exam good hope in luck prepared this We well wish you\".split(\" \");\n    }\n\n    @Test\n    public void testAddNullArgument() {\n        try {\n            i.add(null);\n            fail(\"Index.add() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testGetResourcesNullArgument() {\n        try {\n            i.getResources(null);\n            fail(\"Index.getResources() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testAdd() {\n        Field f = null;\n        try {\n            f = i.getClass().getDeclaredField(\"index\");\n        } catch (NoSuchFieldException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        }\n        f.setAccessible(true);\n\n        Map<String, List<Resource>> indexMap = null;\n\n        try {\n            indexMap = castToMap(f.get(i));\n        } catch(IllegalAccessException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        } catch(ClassCastException e) {\n            fail(\"The attribute \\\"index\\\" in the class Index should be of type Map<String, List<Resource>>\");\n        }\n\n        i.add(res);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res)));\n        }\n\n        i.add(res2);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res, res2)));\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Map<String, List<Resource>> castToMap(Object o) {\n        return (Map<String, List<Resource>>) o;\n    }\n\n    @Test\n    public void testGet() {\n        i.add(res);\n        i.add(res2);\n\n        for(String word : wishes) {\n            assertTrue(\"Index.get() should return a List of all Resources that contain the argument!\",\n                    i.getResources(word).equals(Arrays.asList(res, res2)));\n        }\n\n        assertTrue(\"Index.get() should return an empty List if the argument is in no Resource!\",\n                i.getResources(\"not a Keyword\").equals(Collections.emptyList()));\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Desktop Search Engine",
    "message": "Catching 'NullPointerException' is not allowed.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": "11",
    "end_column": "11",
    "rule": {
      "identifier": "IllegalCatch",
      "explanation": "Certain exceptions should not be catched, such as a java.lang.Exception, because they are too general and/or may shadow problems in the control flow.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class IndexTest {\n\n    private Index i;\n    private Resource res;\n    private Resource res2;\n    private String[] wishes;\n\n    @Before\n    public void setUp(){\n        i = new Index();\n        PlainTextCollector coll = new PlainTextCollector();\n        res = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        res2 = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        wishes = \"are exam good hope in luck prepared this We well wish you\".split(\" \");\n    }\n\n    @Test\n    public void testAddNullArgument() {\n        try {\n            i.add(null);\n            fail(\"Index.add() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testGetResourcesNullArgument() {\n        try {\n            i.getResources(null);\n            fail(\"Index.getResources() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testAdd() {\n        Field f = null;\n        try {\n            f = i.getClass().getDeclaredField(\"index\");\n        } catch (NoSuchFieldException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        }\n        f.setAccessible(true);\n\n        Map<String, List<Resource>> indexMap = null;\n\n        try {\n            indexMap = castToMap(f.get(i));\n        } catch(IllegalAccessException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        } catch(ClassCastException e) {\n            fail(\"The attribute \\\"index\\\" in the class Index should be of type Map<String, List<Resource>>\");\n        }\n\n        i.add(res);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res)));\n        }\n\n        i.add(res2);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res, res2)));\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Map<String, List<Resource>> castToMap(Object o) {\n        return (Map<String, List<Resource>>) o;\n    }\n\n    @Test\n    public void testGet() {\n        i.add(res);\n        i.add(res2);\n\n        for(String word : wishes) {\n            assertTrue(\"Index.get() should return a List of all Resources that contain the argument!\",\n                    i.getResources(word).equals(Arrays.asList(res, res2)));\n        }\n\n        assertTrue(\"Index.get() should return an empty List if the argument is in no Resource!\",\n                i.getResources(\"not a Keyword\").equals(Collections.emptyList()));\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Desktop Search Engine",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": "42",
    "end_column": "42",
    "rule": {
      "identifier": "EmptyBlock",
      "explanation": "Empty blocks occur, when a code block is created but never used. They should be removed.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class IndexTest {\n\n    private Index i;\n    private Resource res;\n    private Resource res2;\n    private String[] wishes;\n\n    @Before\n    public void setUp(){\n        i = new Index();\n        PlainTextCollector coll = new PlainTextCollector();\n        res = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        res2 = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        wishes = \"are exam good hope in luck prepared this We well wish you\".split(\" \");\n    }\n\n    @Test\n    public void testAddNullArgument() {\n        try {\n            i.add(null);\n            fail(\"Index.add() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testGetResourcesNullArgument() {\n        try {\n            i.getResources(null);\n            fail(\"Index.getResources() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testAdd() {\n        Field f = null;\n        try {\n            f = i.getClass().getDeclaredField(\"index\");\n        } catch (NoSuchFieldException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        }\n        f.setAccessible(true);\n\n        Map<String, List<Resource>> indexMap = null;\n\n        try {\n            indexMap = castToMap(f.get(i));\n        } catch(IllegalAccessException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        } catch(ClassCastException e) {\n            fail(\"The attribute \\\"index\\\" in the class Index should be of type Map<String, List<Resource>>\");\n        }\n\n        i.add(res);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res)));\n        }\n\n        i.add(res2);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res, res2)));\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Map<String, List<Resource>> castToMap(Object o) {\n        return (Map<String, List<Resource>>) o;\n    }\n\n    @Test\n    public void testGet() {\n        i.add(res);\n        i.add(res2);\n\n        for(String word : wishes) {\n            assertTrue(\"Index.get() should return a List of all Resources that contain the argument!\",\n                    i.getResources(word).equals(Arrays.asList(res, res2)));\n        }\n\n        assertTrue(\"Index.get() should return an empty List if the argument is in no Resource!\",\n                i.getResources(\"not a Keyword\").equals(Collections.emptyList()));\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Desktop Search Engine",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "44",
    "end_line": "44",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "EmptyCatchBlock",
      "explanation": "Exceptions should be handled in the corresponding catch block. Not handling an exception is error prone.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class IndexTest {\n\n    private Index i;\n    private Resource res;\n    private Resource res2;\n    private String[] wishes;\n\n    @Before\n    public void setUp(){\n        i = new Index();\n        PlainTextCollector coll = new PlainTextCollector();\n        res = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        res2 = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        wishes = \"are exam good hope in luck prepared this We well wish you\".split(\" \");\n    }\n\n    @Test\n    public void testAddNullArgument() {\n        try {\n            i.add(null);\n            fail(\"Index.add() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testGetResourcesNullArgument() {\n        try {\n            i.getResources(null);\n            fail(\"Index.getResources() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testAdd() {\n        Field f = null;\n        try {\n            f = i.getClass().getDeclaredField(\"index\");\n        } catch (NoSuchFieldException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        }\n        f.setAccessible(true);\n\n        Map<String, List<Resource>> indexMap = null;\n\n        try {\n            indexMap = castToMap(f.get(i));\n        } catch(IllegalAccessException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        } catch(ClassCastException e) {\n            fail(\"The attribute \\\"index\\\" in the class Index should be of type Map<String, List<Resource>>\");\n        }\n\n        i.add(res);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res)));\n        }\n\n        i.add(res2);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res, res2)));\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Map<String, List<Resource>> castToMap(Object o) {\n        return (Map<String, List<Resource>>) o;\n    }\n\n    @Test\n    public void testGet() {\n        i.add(res);\n        i.add(res2);\n\n        for(String word : wishes) {\n            assertTrue(\"Index.get() should return a List of all Resources that contain the argument!\",\n                    i.getResources(word).equals(Arrays.asList(res, res2)));\n        }\n\n        assertTrue(\"Index.get() should return an empty List if the argument is in no Resource!\",\n                i.getResources(\"not a Keyword\").equals(Collections.emptyList()));\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Desktop Search Engine",
    "message": "Catching 'NullPointerException' is not allowed.",
    "priority": "error",
    "start_line": "44",
    "end_line": "44",
    "start_column": "11",
    "end_column": "11",
    "rule": {
      "identifier": "IllegalCatch",
      "explanation": "Certain exceptions should not be catched, such as a java.lang.Exception, because they are too general and/or may shadow problems in the control flow.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class IndexTest {\n\n    private Index i;\n    private Resource res;\n    private Resource res2;\n    private String[] wishes;\n\n    @Before\n    public void setUp(){\n        i = new Index();\n        PlainTextCollector coll = new PlainTextCollector();\n        res = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        res2 = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        wishes = \"are exam good hope in luck prepared this We well wish you\".split(\" \");\n    }\n\n    @Test\n    public void testAddNullArgument() {\n        try {\n            i.add(null);\n            fail(\"Index.add() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testGetResourcesNullArgument() {\n        try {\n            i.getResources(null);\n            fail(\"Index.getResources() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testAdd() {\n        Field f = null;\n        try {\n            f = i.getClass().getDeclaredField(\"index\");\n        } catch (NoSuchFieldException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        }\n        f.setAccessible(true);\n\n        Map<String, List<Resource>> indexMap = null;\n\n        try {\n            indexMap = castToMap(f.get(i));\n        } catch(IllegalAccessException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        } catch(ClassCastException e) {\n            fail(\"The attribute \\\"index\\\" in the class Index should be of type Map<String, List<Resource>>\");\n        }\n\n        i.add(res);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res)));\n        }\n\n        i.add(res2);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res, res2)));\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Map<String, List<Resource>> castToMap(Object o) {\n        return (Map<String, List<Resource>>) o;\n    }\n\n    @Test\n    public void testGet() {\n        i.add(res);\n        i.add(res2);\n\n        for(String word : wishes) {\n            assertTrue(\"Index.get() should return a List of all Resources that contain the argument!\",\n                    i.getResources(word).equals(Arrays.asList(res, res2)));\n        }\n\n        assertTrue(\"Index.get() should return an empty List if the argument is in no Resource!\",\n                i.getResources(\"not a Keyword\").equals(Collections.emptyList()));\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Desktop Search Engine",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "44",
    "end_line": "44",
    "start_column": "42",
    "end_column": "42",
    "rule": {
      "identifier": "EmptyBlock",
      "explanation": "Empty blocks occur, when a code block is created but never used. They should be removed.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class IndexTest {\n\n    private Index i;\n    private Resource res;\n    private Resource res2;\n    private String[] wishes;\n\n    @Before\n    public void setUp(){\n        i = new Index();\n        PlainTextCollector coll = new PlainTextCollector();\n        res = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        res2 = new Resource(\"name\", \"path\", new ResourceType(\"desc\", coll));\n        wishes = \"are exam good hope in luck prepared this We well wish you\".split(\" \");\n    }\n\n    @Test\n    public void testAddNullArgument() {\n        try {\n            i.add(null);\n            fail(\"Index.add() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testGetResourcesNullArgument() {\n        try {\n            i.getResources(null);\n            fail(\"Index.getResources() should throw a NullPointerException if the argument is null!\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    @Test\n    public void testAdd() {\n        Field f = null;\n        try {\n            f = i.getClass().getDeclaredField(\"index\");\n        } catch (NoSuchFieldException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        }\n        f.setAccessible(true);\n\n        Map<String, List<Resource>> indexMap = null;\n\n        try {\n            indexMap = castToMap(f.get(i));\n        } catch(IllegalAccessException e) {\n            fail(\"The class Index should contain a Map with the name \\\"index\\\"\");\n        } catch(ClassCastException e) {\n            fail(\"The attribute \\\"index\\\" in the class Index should be of type Map<String, List<Resource>>\");\n        }\n\n        i.add(res);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res)));\n        }\n\n        i.add(res2);\n        assertTrue(\"Index.add() should add each String exactly once!\", indexMap.size() == wishes.length);\n        for(List<Resource> resourceList : indexMap.values()) {\n            assertTrue(\"Index.add() should pair every String with a List of all resources which contain the String!\",\n                    resourceList.equals(Arrays.asList(res, res2)));\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Map<String, List<Resource>> castToMap(Object o) {\n        return (Map<String, List<Resource>>) o;\n    }\n\n    @Test\n    public void testGet() {\n        i.add(res);\n        i.add(res2);\n\n        for(String word : wishes) {\n            assertTrue(\"Index.get() should return a List of all Resources that contain the argument!\",\n                    i.getResources(word).equals(Arrays.asList(res, res2)));\n        }\n\n        assertTrue(\"Index.get() should return an empty List if the argument is in no Resource!\",\n                i.getResources(\"not a Keyword\").equals(Collections.emptyList()));\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Desktop Search Engine",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "public class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "\n\nimport java.util.Objects;\n\npublic class Resource {\n    private String name;\n    private String path;\n    private ResourceType type;\n\n    public Resource(String name, String path, ResourceType rt){\n        if (name.isEmpty() || path.isEmpty())\n            throw new IllegalArgumentException(\"Arguments cannot be empty!\");\n        this.name = Objects.requireNonNull(name);\n        this.path = Objects.requireNonNull(path);\n        this.type = Objects.requireNonNull(rt);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public ResourceType getType() {\n        return type;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "\n\nimport java.util.Objects;\n\npublic class ResourceType {\n    private String description;\n    private KeywordCollector collector;\n\n    public ResourceType(String desc, KeywordCollector collector){\n        if(desc.isEmpty()) throw new IllegalArgumentException(\"Description cannot be emprty!\");\n        this.collector = Objects.requireNonNull(collector);\n        this.description = Objects.requireNonNull(desc);\n    }\n\n    public String getDescription() {\n        return this.description;\n    }\n\n    public KeywordCollector getCollector() {\n        return this.collector;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "Variable 'income' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "19",
    "end_column": "19",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "public class Inhabitant {\n\n    @SuppressWarnings(\"WeakerAccess\")\n    protected int income ;\n    protected float tax;\n\n    public Inhabitant(){\n        this.tax = 10.0f;\n    }\n\n    public void setIncome(int income) {\n        this.income = income;\n    }\n\n    public int taxableIncome() {\n        return this.income;\n    }\n\n    public int tax() {\n        int sum = getSum();\n        return  sum > 0 ? sum : 1;\n\n    }\n\n    protected int getSum() {\n        return (int) (taxableIncome() * (this.tax / 100.0f));\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "Variable 'tax' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "21",
    "end_column": "21",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "public class Inhabitant {\n\n    @SuppressWarnings(\"WeakerAccess\")\n    protected int income ;\n    protected float tax;\n\n    public Inhabitant(){\n        this.tax = 10.0f;\n    }\n\n    public void setIncome(int income) {\n        this.income = income;\n    }\n\n    public int taxableIncome() {\n        return this.income;\n    }\n\n    public int tax() {\n        int sum = getSum();\n        return  sum > 0 ? sum : 1;\n\n    }\n\n    protected int getSum() {\n        return (int) (taxableIncome() * (this.tax / 100.0f));\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "'10.0f' is a magic number.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "20",
    "end_column": "20",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Inhabitant {\n\n    @SuppressWarnings(\"WeakerAccess\")\n    protected int income ;\n    protected float tax;\n\n    public Inhabitant(){\n        this.tax = 10.0f;\n    }\n\n    public void setIncome(int income) {\n        this.income = income;\n    }\n\n    public int taxableIncome() {\n        return this.income;\n    }\n\n    public int tax() {\n        int sum = getSum();\n        return  sum > 0 ? sum : 1;\n\n    }\n\n    protected int getSum() {\n        return (int) (taxableIncome() * (this.tax / 100.0f));\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "Avoid inline conditionals.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": "25",
    "end_column": "25",
    "rule": {
      "identifier": "AvoidInlineConditionals",
      "explanation": "Inline conditionals should be avoided, since they are hard to read.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Inhabitant {\n\n    @SuppressWarnings(\"WeakerAccess\")\n    protected int income ;\n    protected float tax;\n\n    public Inhabitant(){\n        this.tax = 10.0f;\n    }\n\n    public void setIncome(int income) {\n        this.income = income;\n    }\n\n    public int taxableIncome() {\n        return this.income;\n    }\n\n    public int tax() {\n        int sum = getSum();\n        return  sum > 0 ? sum : 1;\n\n    }\n\n    protected int getSum() {\n        return (int) (taxableIncome() * (this.tax / 100.0f));\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "'100.0f' is a magic number.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": "53",
    "end_column": "53",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Inhabitant {\n\n    @SuppressWarnings(\"WeakerAccess\")\n    protected int income ;\n    protected float tax;\n\n    public Inhabitant(){\n        this.tax = 10.0f;\n    }\n\n    public void setIncome(int income) {\n        this.income = income;\n    }\n\n    public int taxableIncome() {\n        return this.income;\n    }\n\n    public int tax() {\n        int sum = getSum();\n        return  sum > 0 ? sum : 1;\n\n    }\n\n    protected int getSum() {\n        return (int) (taxableIncome() * (this.tax / 100.0f));\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "'20' is a magic number.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "22",
    "end_column": "22",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Noble extends Inhabitant {\n    @Override\n    public int tax(){\n        int sum = super.getSum();\n        return sum > 20 ? sum : 20;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "Avoid inline conditionals.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "25",
    "end_column": "25",
    "rule": {
      "identifier": "AvoidInlineConditionals",
      "explanation": "Inline conditionals should be avoided, since they are hard to read.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Noble extends Inhabitant {\n    @Override\n    public int tax(){\n        int sum = super.getSum();\n        return sum > 20 ? sum : 20;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "'20' is a magic number.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Noble extends Inhabitant {\n    @Override\n    public int tax(){\n        int sum = super.getSum();\n        return sum > 20 ? sum : 20;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Serf extends Peasant {\n    @Override\n    public int tax(){\n        if(this.taxableIncome() < 12) return 0;\n        else {\n            int sum = getSum();\n            return sum > 0 ? sum : 1;\n        }\n    }\n\n    @Override\n    public int taxableIncome() {\n        return this.income - 12 >= 0 ? this.income - 12 : 0;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "'12' is a magic number.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "35",
    "end_column": "35",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Serf extends Peasant {\n    @Override\n    public int tax(){\n        if(this.taxableIncome() < 12) return 0;\n        else {\n            int sum = getSum();\n            return sum > 0 ? sum : 1;\n        }\n    }\n\n    @Override\n    public int taxableIncome() {\n        return this.income - 12 >= 0 ? this.income - 12 : 0;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "Avoid inline conditionals.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "28",
    "end_column": "28",
    "rule": {
      "identifier": "AvoidInlineConditionals",
      "explanation": "Inline conditionals should be avoided, since they are hard to read.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Serf extends Peasant {\n    @Override\n    public int tax(){\n        if(this.taxableIncome() < 12) return 0;\n        else {\n            int sum = getSum();\n            return sum > 0 ? sum : 1;\n        }\n    }\n\n    @Override\n    public int taxableIncome() {\n        return this.income - 12 >= 0 ? this.income - 12 : 0;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "'12' is a magic number.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "30",
    "end_column": "30",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Serf extends Peasant {\n    @Override\n    public int tax(){\n        if(this.taxableIncome() < 12) return 0;\n        else {\n            int sum = getSum();\n            return sum > 0 ? sum : 1;\n        }\n    }\n\n    @Override\n    public int taxableIncome() {\n        return this.income - 12 >= 0 ? this.income - 12 : 0;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "Avoid inline conditionals.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "38",
    "end_column": "38",
    "rule": {
      "identifier": "AvoidInlineConditionals",
      "explanation": "Inline conditionals should be avoided, since they are hard to read.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Serf extends Peasant {\n    @Override\n    public int tax(){\n        if(this.taxableIncome() < 12) return 0;\n        else {\n            int sum = getSum();\n            return sum > 0 ? sum : 1;\n        }\n    }\n\n    @Override\n    public int taxableIncome() {\n        return this.income - 12 >= 0 ? this.income - 12 : 0;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Middle Age Kingdom",
    "message": "'12' is a magic number.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "54",
    "end_column": "54",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Serf extends Peasant {\n    @Override\n    public int tax(){\n        if(this.taxableIncome() < 12) return 0;\n        else {\n            int sum = getSum();\n            return sum > 0 ? sum : 1;\n        }\n    }\n\n    @Override\n    public int taxableIncome() {\n        return this.income - 12 >= 0 ? this.income - 12 : 0;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic abstract class AbstractUnit extends AbstractEnterpriseUnit {\n    private List<AbstractEnterpriseUnit> childNodes;\n\n    AbstractUnit(String name) {\n        super(name);\n        childNodes = new ArrayList<>();\n    }\n\n    List<AbstractEnterpriseUnit> getChildNodes() {\n        return childNodes;\n    }\n\n    public boolean add(AbstractEnterpriseUnit node) {\n        Objects.requireNonNull(node);\n        if(this.alreadyExist(node)) return false;\n        else return this.childNodes.add(node);\n    }\n\n    boolean remove(AbstractEnterpriseUnit childNode) {\n        Objects.requireNonNull(childNode);\n        for (AbstractEnterpriseUnit node : childNodes) {\n            if (childNode.getName().equals(node.getName())) {\n                return childNodes.remove(node);\n            }\n        }\n        return false;\n    }\n\n    private boolean alreadyExist(AbstractEnterpriseUnit node) {\n        return this.childNodes\n                .stream()\n                .anyMatch(node::equals);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Enterprise Node",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic abstract class AbstractUnit extends AbstractEnterpriseUnit {\n    private List<AbstractEnterpriseUnit> childNodes;\n\n    AbstractUnit(String name) {\n        super(name);\n        childNodes = new ArrayList<>();\n    }\n\n    List<AbstractEnterpriseUnit> getChildNodes() {\n        return childNodes;\n    }\n\n    public boolean add(AbstractEnterpriseUnit node) {\n        Objects.requireNonNull(node);\n        if(this.alreadyExist(node)) return false;\n        else return this.childNodes.add(node);\n    }\n\n    boolean remove(AbstractEnterpriseUnit childNode) {\n        Objects.requireNonNull(childNode);\n        for (AbstractEnterpriseUnit node : childNodes) {\n            if (childNode.getName().equals(node.getName())) {\n                return childNodes.remove(node);\n            }\n        }\n        return false;\n    }\n\n    private boolean alreadyExist(AbstractEnterpriseUnit node) {\n        return this.childNodes\n                .stream()\n                .anyMatch(node::equals);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Enterprise Node",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Company extends AbstractUnit {\n    public Company(String name) {\n        super(name);\n    }\n\n    @Override\n    public boolean add(AbstractEnterpriseUnit node){\n        Objects.requireNonNull(node);\n        if (node instanceof Division){\n            return super.add(node);\n        }\n        else throw new IllegalArgumentException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Enterprise Node",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Division extends AbstractUnit {\n    public Division(String name) {\n        super(name);\n    }\n\n    @Override\n    public boolean add(AbstractEnterpriseUnit node){\n        Objects.requireNonNull(node);\n        if (node instanceof Team){\n            return super.add(node);\n        }\n        else throw new IllegalArgumentException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Enterprise Node",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Holding extends AbstractUnit {\n\n    public Holding(String name) {\n        super(name);\n    }\n\n    @Override\n    public boolean add(AbstractEnterpriseUnit node){\n        Objects.requireNonNull(node);\n        if (node instanceof Company){\n            return super.add(node);\n        }\n        else throw new IllegalArgumentException();\n    }\n\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class StaffMember implements EnterpriseNode, Comparable<StaffMember> {\n\n    private String name;\n    private String job;\n    private Set<StaffMember> directSubordinates;\n\n    public StaffMember(String name, String job) {\n        this.directSubordinates = new HashSet<>();\n        this.name = Validator.checkParam(name);\n        this.job = Validator.checkParam(job);\n    }\n\n    String getJob() {\n        return job;\n    }\n\n    boolean addDirectSubordinate(StaffMember member) {\n        Objects.requireNonNull(member);\n        if (this.directSubordinates.contains(member)) return false;\n        else return this.directSubordinates.add(member);\n    }\n\n    boolean removeDirectSubordinate(StaffMember member) {\n        Objects.requireNonNull(member);\n        return this.directSubordinates.remove(member);\n    }\n\n    Set<StaffMember> getDirectSubordinates() {\n        return directSubordinates;\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n\n    @Override\n    public int compareTo(StaffMember member) {\n        Objects.requireNonNull(member);\n        return this.name.compareTo(member.getName());\n    }\n\n    @Override\n    public String toString() {\n        return this.name;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Enterprise Node",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class StaffMember implements EnterpriseNode, Comparable<StaffMember> {\n\n    private String name;\n    private String job;\n    private Set<StaffMember> directSubordinates;\n\n    public StaffMember(String name, String job) {\n        this.directSubordinates = new HashSet<>();\n        this.name = Validator.checkParam(name);\n        this.job = Validator.checkParam(job);\n    }\n\n    String getJob() {\n        return job;\n    }\n\n    boolean addDirectSubordinate(StaffMember member) {\n        Objects.requireNonNull(member);\n        if (this.directSubordinates.contains(member)) return false;\n        else return this.directSubordinates.add(member);\n    }\n\n    boolean removeDirectSubordinate(StaffMember member) {\n        Objects.requireNonNull(member);\n        return this.directSubordinates.remove(member);\n    }\n\n    Set<StaffMember> getDirectSubordinates() {\n        return directSubordinates;\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n\n    @Override\n    public int compareTo(StaffMember member) {\n        Objects.requireNonNull(member);\n        return this.name.compareTo(member.getName());\n    }\n\n    @Override\n    public String toString() {\n        return this.name;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Enterprise Node",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n\n    public static Object checkParam(Object object){\n        Objects.requireNonNull(object);\n        return object;\n    }\n\n    static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if (str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n\n    public static Object checkParam(Object object){\n        Objects.requireNonNull(object);\n        return object;\n    }\n\n    static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if (str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'1.5d' is a magic number.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Bicycle extends Vehicle {\n    public double getLength(){\n        return 1.5d;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'18d' is a magic number.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Bus extends Vehicle{\n    @Override\n    public double getLength() {\n        return 18d;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'6d' is a magic number.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Car extends Vehicle {\n    @Override\n    public double getLength() {\n        return 6d;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "public class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "Class Time should be declared as final.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "FinalClass",
      "explanation": "Classes with private constructors should be declared as final, because they are not initializable from an outside context.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Observable;\n\npublic class Time extends Observable {\n    private static Time instance;\n    private int currentTime = 0;\n    private int endofTime = 100;\n\n    private Time(){ }\n\n    public static Time getInstance(){\n        return instance;\n    }\n\n    public int getCurrentTime(){\n        return this.currentTime;\n    }\n\n    public void initEndOfTime(int seconds){\n        if (seconds < 0) throw new IllegalArgumentException();\n        this.currentTime = 0;\n        this.endofTime = seconds;\n    }\n\n    public void run(){\n        for (int i = 0; i < this.endofTime; ++i) {\n            this.currentTime++;\n            this.setChanged();\n            this.notifyObservers(currentTime);\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "Variable 'currentTime' explicitly initialized to '0' (default value for its type).",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "17",
    "end_column": "17",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.Observable;\n\npublic class Time extends Observable {\n    private static Time instance;\n    private int currentTime = 0;\n    private int endofTime = 100;\n\n    private Time(){ }\n\n    public static Time getInstance(){\n        return instance;\n    }\n\n    public int getCurrentTime(){\n        return this.currentTime;\n    }\n\n    public void initEndOfTime(int seconds){\n        if (seconds < 0) throw new IllegalArgumentException();\n        this.currentTime = 0;\n        this.endofTime = seconds;\n    }\n\n    public void run(){\n        for (int i = 0; i < this.endofTime; ++i) {\n            this.currentTime++;\n            this.setChanged();\n            this.notifyObservers(currentTime);\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "29",
    "end_column": "29",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Observable;\n\npublic class Time extends Observable {\n    private static Time instance;\n    private int currentTime = 0;\n    private int endofTime = 100;\n\n    private Time(){ }\n\n    public static Time getInstance(){\n        return instance;\n    }\n\n    public int getCurrentTime(){\n        return this.currentTime;\n    }\n\n    public void initEndOfTime(int seconds){\n        if (seconds < 0) throw new IllegalArgumentException();\n        this.currentTime = 0;\n        this.endofTime = seconds;\n    }\n\n    public void run(){\n        for (int i = 0; i < this.endofTime; ++i) {\n            this.currentTime++;\n            this.setChanged();\n            this.notifyObservers(currentTime);\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Observable;\n\npublic class Time extends Observable {\n    private static Time instance;\n    private int currentTime = 0;\n    private int endofTime = 100;\n\n    private Time(){ }\n\n    public static Time getInstance(){\n        return instance;\n    }\n\n    public int getCurrentTime(){\n        return this.currentTime;\n    }\n\n    public void initEndOfTime(int seconds){\n        if (seconds < 0) throw new IllegalArgumentException();\n        this.currentTime = 0;\n        this.endofTime = seconds;\n    }\n\n    public void run(){\n        for (int i = 0; i < this.endofTime; ++i) {\n            this.currentTime++;\n            this.setChanged();\n            this.notifyObservers(currentTime);\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "Name 'Vehicle' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public abstract class Vehicle {\n\n    public abstract double getLength();\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'3' is a magic number.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": "44",
    "end_column": "44",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Random;\n\npublic class VehicleGenerator {\n    private Random randomGenerator;\n\n    VehicleGenerator(){\n        randomGenerator = new Random();\n\n    }\n\n    public  Vehicle createVehicle(){\n        int type = randomGenerator.nextInt(3);\n\n        switch (type) {\n            case 1: return new Bicycle();\n            case 2: return new Bus();\n            default: return new Car();\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "Variable 'greenLight' explicitly initialized to 'false' (default value for its type).",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "21",
    "end_column": "21",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'{' at column 31 should have line break after.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'}' at column 72 should be alone on a line.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": "72",
    "end_column": "72",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'{' at column 30 should have line break after.",
    "priority": "error",
    "start_line": "48",
    "end_line": "48",
    "start_column": "30",
    "end_column": "30",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'}' at column 51 should be alone on a line.",
    "priority": "error",
    "start_line": "48",
    "end_line": "48",
    "start_column": "51",
    "end_column": "51",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'{' at column 45 should have line break after.",
    "priority": "error",
    "start_line": "54",
    "end_line": "54",
    "start_column": "45",
    "end_column": "45",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'}' at column 82 should be alone on a line.",
    "priority": "error",
    "start_line": "54",
    "end_line": "54",
    "start_column": "82",
    "end_column": "82",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "57",
    "end_line": "57",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "75",
    "end_line": "75",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "78",
    "end_line": "78",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "90",
    "end_line": "90",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "92",
    "end_line": "92",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'{' at column 58 should have line break after.",
    "priority": "error",
    "start_line": "96",
    "end_line": "96",
    "start_column": "58",
    "end_column": "58",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'}' at column 110 should be alone on a line.",
    "priority": "error",
    "start_line": "96",
    "end_line": "96",
    "start_column": "110",
    "end_column": "110",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "99",
    "end_line": "99",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Vehicle Queue",
    "message": "Assignment of parameter 'currentTime' is not allowed.",
    "priority": "error",
    "start_line": "100",
    "end_line": "100",
    "start_column": "21",
    "end_column": "21",
    "rule": {
      "identifier": "ParameterAssignment",
      "explanation": "Assignments to parameters of a function is often considered poor programming practice, because the parameters may be mutated without knowledge of the outside caller and reused in a potentially erroneous context. Parameters can be declared final.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\n\npublic class VehicleQueue implements Observer {\n    private final Queue<Vehicle> queue = new LinkedList<>();\n\n    private Integer iTime;\n    private double entryDelay;\n    private double exitDelay;\n\n    private boolean greenLight = false;\n    private int trafficLightRate;\n\n    private VehicleGenerator generator;\n\n    public VehicleQueue(double entryDelay, double exitDelay, int trafficLightRate, VehicleGenerator generator) {\n        Objects.requireNonNull(generator);\n        if (trafficLightRate <= 0 || entryDelay <= 0d || exitDelay <= 0d) throw new IllegalArgumentException();\n        this.exitDelay = exitDelay;\n        this.entryDelay = entryDelay;\n        this.generator = generator;\n        this.trafficLightRate = trafficLightRate;\n    }\n\n    public void enter() {\n        queue.add(generator.createVehicle());\n    }\n\n    public void leave() {\n        queue.poll();\n    }\n\n    public int getSize() {\n        return queue.size();\n    }\n\n    private int getPhaseTime(){ return  this.getPhaseTime(this.iTime); }\n\n    private int getPhaseTime(int currentTime){\n        return currentTime % (trafficLightRate * 2);\n    }\n\n    public double getLength() {\n        return queue.stream()\n                .map(Vehicle::getLength)\n                .reduce(0.0, Double::sum);\n    }\n\n    private Integer getTime(){ return this.iTime; }\n\n    private double getLastLeave() {\n        return Math.round(this.exitDelay * needToLeaveAmount(this.getTime() - 1));\n    }\n\n    private void setTime(Object timeObject) { this.iTime = (Integer) timeObject; }\n\n    private void switchLight() {\n        if (this.getPhaseTime() % this.trafficLightRate == 0)\n            this.greenLight = !this.greenLight;\n    }\n    private boolean isSwitched(int time) {\n        boolean isChangedFromLastTime = !isGreenLight(time) && isGreenLight(time - 1);\n        return time != 0 && (isChangedFromLastTime);\n    }\n    private boolean isGreenLight(int time) {\n        return this.getPhaseTime(time) >= trafficLightRate;\n    }\n\n    @Override\n    public void update(Observable observable, Object timeObject) {\n        this.setTime(timeObject);\n\n        this.switchLight();\n\n        double toEnter = amountToEnter();\n        for (int i = 0; i < toEnter; i++) this.enter();\n\n        double toLeave = amountToLeave();\n        for (int i = 0; i < toLeave; i++) this.leave();\n\n    }\n\n    private double amountToEnter() {\n        int time = this.getTime();\n        return needToEnterAmount(time) - needToEnterAmount(time - 1);\n    }\n\n    private double amountToLeave() {\n        int timeInt = this.getTime();\n        int phaseTime = this.getPhaseTime();\n        if (isSwitched(timeInt))\n            return Math.floor((this.trafficLightRate - this.getLastLeave()) / this.exitDelay);\n        else\n            return needToLeaveAmount(phaseTime) - needToLeaveAmount(phaseTime - 1);\n    }\n\n    private double needToEnterAmount(double currentTime) { return Math.floor(currentTime / this.entryDelay); }\n\n    private double needToLeaveAmount(double currentTime) {\n        if (currentTime < this.trafficLightRate) return 0d;\n        currentTime %= this.trafficLightRate;\n        return Math.floor(currentTime / this.exitDelay);\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Predicate Iterator",
    "message": "Name 'Type' must match pattern '^[A-Z]$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "32",
    "end_column": "32",
    "rule": {
      "identifier": "ClassTypeParameterName",
      "explanation": "Class type parameters of generic classes should conform to naming conventions. For example, naming a type parameter \"T\" is ok, whereas naming it \"abc\" such as in MyClass<abc> {} violates the conventions. Type parameters should match the regular expression \"^[a-zA-Z]$\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class PredicateEndsWith<Type extends String> implements Predicate<Type>{\n\n    @Override\n    public boolean predicate(String element, String argument) {\n        return Validator.checkParams(element, argument) && element.endsWith(argument);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Predicate Iterator",
    "message": "Name 'Type' must match pattern '^[A-Z]$'.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "32",
    "end_column": "32",
    "rule": {
      "identifier": "ClassTypeParameterName",
      "explanation": "Class type parameters of generic classes should conform to naming conventions. For example, naming a type parameter \"T\" is ok, whereas naming it \"abc\" such as in MyClass<abc> {} violates the conventions. Type parameters should match the regular expression \"^[a-zA-Z]$\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\n\npublic class PredicateIterator<Type> implements Iterator {\n\n    private ListIterator<Type> iterator;\n    private Predicate<Type> predicate;\n    private Type argument;\n\n    public PredicateIterator(Iterator<Type> iterator, Predicate<Type> predicate, Type argument) {\n        this.iterator = (ListIterator<Type>) iterator;\n        this.predicate = predicate;\n        this.argument = argument;\n    }\n\n    @Override\n    public boolean hasNext() {\n        while(iterator.hasNext()){\n            if (predicate.predicate(iterator.next(), argument)) {\n                iterator.previous();\n                return true;\n            }\n        }\n        return false;\n\n    }\n\n    @Override\n    public Type next(){\n        Type temp;\n\n        while (iterator.hasNext()){\n            temp = iterator.next();\n            if(predicate.predicate(temp,argument)) return temp;\n        }\n\n        throw new NoSuchElementException();\n\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\n\npublic class PredicateIterator<Type> implements Iterator {\n\n    private ListIterator<Type> iterator;\n    private Predicate<Type> predicate;\n    private Type argument;\n\n    public PredicateIterator(Iterator<Type> iterator, Predicate<Type> predicate, Type argument) {\n        this.iterator = (ListIterator<Type>) iterator;\n        this.predicate = predicate;\n        this.argument = argument;\n    }\n\n    @Override\n    public boolean hasNext() {\n        while(iterator.hasNext()){\n            if (predicate.predicate(iterator.next(), argument)) {\n                iterator.previous();\n                return true;\n            }\n        }\n        return false;\n\n    }\n\n    @Override\n    public Type next(){\n        Type temp;\n\n        while (iterator.hasNext()){\n            temp = iterator.next();\n            if(predicate.predicate(temp,argument)) return temp;\n        }\n\n        throw new NoSuchElementException();\n\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Predicate Iterator",
    "message": "Name 'Type' must match pattern '^[A-Z]$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "30",
    "end_column": "30",
    "rule": {
      "identifier": "ClassTypeParameterName",
      "explanation": "Class type parameters of generic classes should conform to naming conventions. For example, naming a type parameter \"T\" is ok, whereas naming it \"abc\" such as in MyClass<abc> {} violates the conventions. Type parameters should match the regular expression \"^[a-zA-Z]$\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class PredicateLength<Type extends String> implements Predicate<Type>{\n\n    @Override\n    public boolean predicate(String element, String argument) {\n        return Validator.checkParams(element, argument) && element.length() == Integer.parseInt(argument);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Predicate Iterator",
    "message": "Name 'Type' must match pattern '^[A-Z]$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "34",
    "end_column": "34",
    "rule": {
      "identifier": "ClassTypeParameterName",
      "explanation": "Class type parameters of generic classes should conform to naming conventions. For example, naming a type parameter \"T\" is ok, whereas naming it \"abc\" such as in MyClass<abc> {} violates the conventions. Type parameters should match the regular expression \"^[a-zA-Z]$\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class PredicateStartsWith<Type extends String> implements Predicate<Type>{\n\n    @Override\n    public boolean predicate(String element, String argument) {\n        return Validator.checkParams(element, argument) && element.startsWith(argument);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Predicate Iterator",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import org.omg.CORBA.Object;\n\nimport java.util.Arrays;\nimport java.util.Objects;\n\npublic class Validator {\n    public static boolean checkParams(String... strings) {\n        boolean isValid;\n        for ( String string : strings ) {\n            isValid = checkParam(string);\n            if (!isValid) return false;\n        }\n        return true;\n    }\n\n    private static boolean checkParam(String string) {\n\n        return string != null && string.isEmpty();\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import org.omg.CORBA.Object;\n\nimport java.util.Arrays;\nimport java.util.Objects;\n\npublic class Validator {\n    public static boolean checkParams(String... strings) {\n        boolean isValid;\n        for ( String string : strings ) {\n            isValid = checkParam(string);\n            if (!isValid) return false;\n        }\n        return true;\n    }\n\n    private static boolean checkParam(String string) {\n\n        return string != null && string.isEmpty();\n    }\n\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'0.02' is a magic number.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "28",
    "end_column": "28",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Flooring extends Material {\n    private double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width){\n        super(name,price);\n        Validator.checkParam(width);\n        this.widthOfFlooring = width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface surface) {\n        int result = (int) (surface.getArea() / this.widthOfFlooring);\n        double tolerance = round(surface.getArea() % this.widthOfFlooring);\n        if (tolerance <= this.limit) return result;\n        else return result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Flooring extends Material {\n    private double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width){\n        super(name,price);\n        Validator.checkParam(width);\n        this.widthOfFlooring = width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface surface) {\n        int result = (int) (surface.getArea() / this.widthOfFlooring);\n        double tolerance = round(surface.getArea() % this.widthOfFlooring);\n        if (tolerance <= this.limit) return result;\n        else return result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Flooring extends Material {\n    private double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width){\n        super(name,price);\n        Validator.checkParam(width);\n        this.widthOfFlooring = width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface surface) {\n        int result = (int) (surface.getArea() / this.widthOfFlooring);\n        double tolerance = round(surface.getArea() % this.widthOfFlooring);\n        if (tolerance <= this.limit) return result;\n        else return result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'100f' is a magic number.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Flooring extends Material {\n    private double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width){\n        super(name,price);\n        Validator.checkParam(width);\n        this.widthOfFlooring = width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface surface) {\n        int result = (int) (surface.getArea() / this.widthOfFlooring);\n        double tolerance = round(surface.getArea() % this.widthOfFlooring);\n        if (tolerance <= this.limit) return result;\n        else return result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'100f' is a magic number.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": "39",
    "end_column": "39",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Flooring extends Material {\n    private double limit = 0.02;\n    private double widthOfFlooring;\n\n    public Flooring(String name, double price, double width){\n        super(name,price);\n        Validator.checkParam(width);\n        this.widthOfFlooring = width;\n    }\n\n    public double getWidth() {\n        return widthOfFlooring;\n    }\n\n    @Override\n    public int getMaterialReq(Surface surface) {\n        int result = (int) (surface.getArea() / this.widthOfFlooring);\n        double tolerance = round(surface.getArea() % this.widthOfFlooring);\n        if (tolerance <= this.limit) return result;\n        else return result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "Name 'Material' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic abstract class Material {\n    private String name;\n    private double price;\n\n    public Material (String name, double price){\n        Validator.checkParam(name);\n        Validator.checkParam(price);\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName(){\n        return this.name;\n    }\n\n    public double getPricePerUnit() {\n        return this.price;\n    }\n\n    public double getPriceOfASurface(Surface surface) {\n        Objects.requireNonNull(surface);\n        return this.getPricePerUnit() * getMaterialReq(surface);\n    }\n\n    public abstract int getMaterialReq(Surface surface);\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'getPriceOfASurface' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic abstract class Material {\n    private String name;\n    private double price;\n\n    public Material (String name, double price){\n        Validator.checkParam(name);\n        Validator.checkParam(price);\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName(){\n        return this.name;\n    }\n\n    public double getPricePerUnit() {\n        return this.price;\n    }\n\n    public double getPriceOfASurface(Surface surface) {\n        Objects.requireNonNull(surface);\n        return this.getPricePerUnit() * getMaterialReq(surface);\n    }\n\n    public abstract int getMaterialReq(Surface surface);\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'0.02' is a magic number.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "28",
    "end_column": "28",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Paint extends  Material{\n    private double limit = 0.02;\n    private int noOfCoast;\n    private double noOfSqMPerLiter;\n    private double volumeOfCan = 0.500000000;\n\n    public Paint(String name, double price, int noOfCoast, double noOfSqMPerLiter){\n        super(name, price);\n\n        this.noOfCoast = Validator.checkParam(noOfCoast);\n        this.noOfSqMPerLiter = Validator.checkParam(noOfSqMPerLiter);\n    }\n\n    public int getNoOfCoast() {\n        return this.noOfCoast;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return this.noOfSqMPerLiter;\n    }\n\n\n    public int getNoOfCoats() {\n        return this.noOfCoast;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface surface){\n        Objects.requireNonNull(surface);\n        double calcVal =  (surface.getArea() * this.getNoOfCoats()) / this.getNoOfSqMPerLiter();\n        int result = (int) (calcVal / this.getVolumeOfCan());\n        double tolerance = calcVal % this.getVolumeOfCan();\n        return tolerance <= this.limit ? result : result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n\n    public double getVolumeOfCan() {\n        return volumeOfCan;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'noOfSqMPerLiter' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Paint extends  Material{\n    private double limit = 0.02;\n    private int noOfCoast;\n    private double noOfSqMPerLiter;\n    private double volumeOfCan = 0.500000000;\n\n    public Paint(String name, double price, int noOfCoast, double noOfSqMPerLiter){\n        super(name, price);\n\n        this.noOfCoast = Validator.checkParam(noOfCoast);\n        this.noOfSqMPerLiter = Validator.checkParam(noOfSqMPerLiter);\n    }\n\n    public int getNoOfCoast() {\n        return this.noOfCoast;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return this.noOfSqMPerLiter;\n    }\n\n\n    public int getNoOfCoats() {\n        return this.noOfCoast;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface surface){\n        Objects.requireNonNull(surface);\n        double calcVal =  (surface.getArea() * this.getNoOfCoats()) / this.getNoOfSqMPerLiter();\n        int result = (int) (calcVal / this.getVolumeOfCan());\n        double tolerance = calcVal % this.getVolumeOfCan();\n        return tolerance <= this.limit ? result : result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n\n    public double getVolumeOfCan() {\n        return volumeOfCan;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'0.500000000' is a magic number.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "34",
    "end_column": "34",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Paint extends  Material{\n    private double limit = 0.02;\n    private int noOfCoast;\n    private double noOfSqMPerLiter;\n    private double volumeOfCan = 0.500000000;\n\n    public Paint(String name, double price, int noOfCoast, double noOfSqMPerLiter){\n        super(name, price);\n\n        this.noOfCoast = Validator.checkParam(noOfCoast);\n        this.noOfSqMPerLiter = Validator.checkParam(noOfSqMPerLiter);\n    }\n\n    public int getNoOfCoast() {\n        return this.noOfCoast;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return this.noOfSqMPerLiter;\n    }\n\n\n    public int getNoOfCoats() {\n        return this.noOfCoast;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface surface){\n        Objects.requireNonNull(surface);\n        double calcVal =  (surface.getArea() * this.getNoOfCoats()) / this.getNoOfSqMPerLiter();\n        int result = (int) (calcVal / this.getVolumeOfCan());\n        double tolerance = calcVal % this.getVolumeOfCan();\n        return tolerance <= this.limit ? result : result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n\n    public double getVolumeOfCan() {\n        return volumeOfCan;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'noOfSqMPerLiter' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Paint extends  Material{\n    private double limit = 0.02;\n    private int noOfCoast;\n    private double noOfSqMPerLiter;\n    private double volumeOfCan = 0.500000000;\n\n    public Paint(String name, double price, int noOfCoast, double noOfSqMPerLiter){\n        super(name, price);\n\n        this.noOfCoast = Validator.checkParam(noOfCoast);\n        this.noOfSqMPerLiter = Validator.checkParam(noOfSqMPerLiter);\n    }\n\n    public int getNoOfCoast() {\n        return this.noOfCoast;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return this.noOfSqMPerLiter;\n    }\n\n\n    public int getNoOfCoats() {\n        return this.noOfCoast;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface surface){\n        Objects.requireNonNull(surface);\n        double calcVal =  (surface.getArea() * this.getNoOfCoats()) / this.getNoOfSqMPerLiter();\n        int result = (int) (calcVal / this.getVolumeOfCan());\n        double tolerance = calcVal % this.getVolumeOfCan();\n        return tolerance <= this.limit ? result : result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n\n    public double getVolumeOfCan() {\n        return volumeOfCan;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'getNoOfSqMPerLiter' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Paint extends  Material{\n    private double limit = 0.02;\n    private int noOfCoast;\n    private double noOfSqMPerLiter;\n    private double volumeOfCan = 0.500000000;\n\n    public Paint(String name, double price, int noOfCoast, double noOfSqMPerLiter){\n        super(name, price);\n\n        this.noOfCoast = Validator.checkParam(noOfCoast);\n        this.noOfSqMPerLiter = Validator.checkParam(noOfSqMPerLiter);\n    }\n\n    public int getNoOfCoast() {\n        return this.noOfCoast;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return this.noOfSqMPerLiter;\n    }\n\n\n    public int getNoOfCoats() {\n        return this.noOfCoast;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface surface){\n        Objects.requireNonNull(surface);\n        double calcVal =  (surface.getArea() * this.getNoOfCoats()) / this.getNoOfSqMPerLiter();\n        int result = (int) (calcVal / this.getVolumeOfCan());\n        double tolerance = calcVal % this.getVolumeOfCan();\n        return tolerance <= this.limit ? result : result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n\n    public double getVolumeOfCan() {\n        return volumeOfCan;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "Avoid inline conditionals.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": "40",
    "end_column": "40",
    "rule": {
      "identifier": "AvoidInlineConditionals",
      "explanation": "Inline conditionals should be avoided, since they are hard to read.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Paint extends  Material{\n    private double limit = 0.02;\n    private int noOfCoast;\n    private double noOfSqMPerLiter;\n    private double volumeOfCan = 0.500000000;\n\n    public Paint(String name, double price, int noOfCoast, double noOfSqMPerLiter){\n        super(name, price);\n\n        this.noOfCoast = Validator.checkParam(noOfCoast);\n        this.noOfSqMPerLiter = Validator.checkParam(noOfSqMPerLiter);\n    }\n\n    public int getNoOfCoast() {\n        return this.noOfCoast;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return this.noOfSqMPerLiter;\n    }\n\n\n    public int getNoOfCoats() {\n        return this.noOfCoast;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface surface){\n        Objects.requireNonNull(surface);\n        double calcVal =  (surface.getArea() * this.getNoOfCoats()) / this.getNoOfSqMPerLiter();\n        int result = (int) (calcVal / this.getVolumeOfCan());\n        double tolerance = calcVal % this.getVolumeOfCan();\n        return tolerance <= this.limit ? result : result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n\n    public double getVolumeOfCan() {\n        return volumeOfCan;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'100f' is a magic number.",
    "priority": "error",
    "start_line": "40",
    "end_line": "40",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Paint extends  Material{\n    private double limit = 0.02;\n    private int noOfCoast;\n    private double noOfSqMPerLiter;\n    private double volumeOfCan = 0.500000000;\n\n    public Paint(String name, double price, int noOfCoast, double noOfSqMPerLiter){\n        super(name, price);\n\n        this.noOfCoast = Validator.checkParam(noOfCoast);\n        this.noOfSqMPerLiter = Validator.checkParam(noOfSqMPerLiter);\n    }\n\n    public int getNoOfCoast() {\n        return this.noOfCoast;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return this.noOfSqMPerLiter;\n    }\n\n\n    public int getNoOfCoats() {\n        return this.noOfCoast;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface surface){\n        Objects.requireNonNull(surface);\n        double calcVal =  (surface.getArea() * this.getNoOfCoats()) / this.getNoOfSqMPerLiter();\n        int result = (int) (calcVal / this.getVolumeOfCan());\n        double tolerance = calcVal % this.getVolumeOfCan();\n        return tolerance <= this.limit ? result : result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n\n    public double getVolumeOfCan() {\n        return volumeOfCan;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'100f' is a magic number.",
    "priority": "error",
    "start_line": "40",
    "end_line": "40",
    "start_column": "39",
    "end_column": "39",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Paint extends  Material{\n    private double limit = 0.02;\n    private int noOfCoast;\n    private double noOfSqMPerLiter;\n    private double volumeOfCan = 0.500000000;\n\n    public Paint(String name, double price, int noOfCoast, double noOfSqMPerLiter){\n        super(name, price);\n\n        this.noOfCoast = Validator.checkParam(noOfCoast);\n        this.noOfSqMPerLiter = Validator.checkParam(noOfSqMPerLiter);\n    }\n\n    public int getNoOfCoast() {\n        return this.noOfCoast;\n    }\n\n    public double getNoOfSqMPerLiter() {\n        return this.noOfSqMPerLiter;\n    }\n\n\n    public int getNoOfCoats() {\n        return this.noOfCoast;\n    }\n\n\n    @Override\n    public int getMaterialReq(Surface surface){\n        Objects.requireNonNull(surface);\n        double calcVal =  (surface.getArea() * this.getNoOfCoats()) / this.getNoOfSqMPerLiter();\n        int result = (int) (calcVal / this.getVolumeOfCan());\n        double tolerance = calcVal % this.getVolumeOfCan();\n        return tolerance <= this.limit ? result : result + 1;\n    }\n\n    private double round(double d){\n        return Math.round(d * 100f) / 100f;\n    }\n\n\n    public double getVolumeOfCan() {\n        return volumeOfCan;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "Name 'RenovationObject' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\n\npublic abstract class RenovationObject {\n    public abstract double getPrice();\n\n    public abstract Map<String, Integer> addMaterialReq(Map<String, Integer> materials);\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class StructuredObject extends RenovationObject {\n    private Set<RenovationObject> parts;\n\n    public StructuredObject() {\n        this.parts = new HashSet<>();\n    }\n\n    public void add(RenovationObject renovationObject) {\n        Objects.requireNonNull(renovationObject);\n        this.parts.add(renovationObject);\n    }\n\n    public double getPrice() {\n        AtomicReference<Double> price = new AtomicReference<>(0d);\n        parts.forEach(\n                renovationObject -> price.updateAndGet(\n                        value -> (double) (value + renovationObject.getPrice())\n                )\n        );\n\n        return price.get();\n    }\n\n    public Map<String, Integer> addMaterialReq(Map<String, Integer> materialMap) {\n        Validator.checkParam(materialMap);\n\n        for (RenovationObject obj : parts) materialMap = obj.addMaterialReq(materialMap);\n\n        return materialMap;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "Assignment of parameter 'materialMap' is not allowed.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": "56",
    "end_column": "56",
    "rule": {
      "identifier": "ParameterAssignment",
      "explanation": "Assignments to parameters of a function is often considered poor programming practice, because the parameters may be mutated without knowledge of the outside caller and reused in a potentially erroneous context. Parameters can be declared final.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class StructuredObject extends RenovationObject {\n    private Set<RenovationObject> parts;\n\n    public StructuredObject() {\n        this.parts = new HashSet<>();\n    }\n\n    public void add(RenovationObject renovationObject) {\n        Objects.requireNonNull(renovationObject);\n        this.parts.add(renovationObject);\n    }\n\n    public double getPrice() {\n        AtomicReference<Double> price = new AtomicReference<>(0d);\n        parts.forEach(\n                renovationObject -> price.updateAndGet(\n                        value -> (double) (value + renovationObject.getPrice())\n                )\n        );\n\n        return price.get();\n    }\n\n    public Map<String, Integer> addMaterialReq(Map<String, Integer> materialMap) {\n        Validator.checkParam(materialMap);\n\n        for (RenovationObject obj : parts) materialMap = obj.addMaterialReq(materialMap);\n\n        return materialMap;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Objects;\n\nclass Validator {\n    static String checkParam(String string) {\n        if(Objects.isNull(string)) throw new NullPointerException();\n        if(string.isEmpty()) throw  new IllegalArgumentException();\n        return string;\n    }\n\n    static double checkParam(double d) {\n        if(d <= 0) throw new IllegalArgumentException();\n        return d;\n    }\n\n    static int checkParam(int i) {\n        if(i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static void checkParam(Map<String, Integer> mapToCheck){\n        Objects.requireNonNull(mapToCheck);\n\n        for (Map.Entry<String, Integer> entry : mapToCheck.entrySet()) {\n            if (entry.getKey() == null) throw new NullPointerException();\n            if (entry.getValue() == null) throw new NullPointerException();\n        }\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Objects;\n\nclass Validator {\n    static String checkParam(String string) {\n        if(Objects.isNull(string)) throw new NullPointerException();\n        if(string.isEmpty()) throw  new IllegalArgumentException();\n        return string;\n    }\n\n    static double checkParam(double d) {\n        if(d <= 0) throw new IllegalArgumentException();\n        return d;\n    }\n\n    static int checkParam(int i) {\n        if(i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static void checkParam(Map<String, Integer> mapToCheck){\n        Objects.requireNonNull(mapToCheck);\n\n        for (Map.Entry<String, Integer> entry : mapToCheck.entrySet()) {\n            if (entry.getKey() == null) throw new NullPointerException();\n            if (entry.getValue() == null) throw new NullPointerException();\n        }\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Objects;\n\nclass Validator {\n    static String checkParam(String string) {\n        if(Objects.isNull(string)) throw new NullPointerException();\n        if(string.isEmpty()) throw  new IllegalArgumentException();\n        return string;\n    }\n\n    static double checkParam(double d) {\n        if(d <= 0) throw new IllegalArgumentException();\n        return d;\n    }\n\n    static int checkParam(int i) {\n        if(i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static void checkParam(Map<String, Integer> mapToCheck){\n        Objects.requireNonNull(mapToCheck);\n\n        for (Map.Entry<String, Integer> entry : mapToCheck.entrySet()) {\n            if (entry.getKey() == null) throw new NullPointerException();\n            if (entry.getValue() == null) throw new NullPointerException();\n        }\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Objects;\n\nclass Validator {\n    static String checkParam(String string) {\n        if(Objects.isNull(string)) throw new NullPointerException();\n        if(string.isEmpty()) throw  new IllegalArgumentException();\n        return string;\n    }\n\n    static double checkParam(double d) {\n        if(d <= 0) throw new IllegalArgumentException();\n        return d;\n    }\n\n    static int checkParam(int i) {\n        if(i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static void checkParam(Map<String, Integer> mapToCheck){\n        Objects.requireNonNull(mapToCheck);\n\n        for (Map.Entry<String, Integer> entry : mapToCheck.entrySet()) {\n            if (entry.getKey() == null) throw new NullPointerException();\n            if (entry.getValue() == null) throw new NullPointerException();\n        }\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Objects;\n\nclass Validator {\n    static String checkParam(String string) {\n        if(Objects.isNull(string)) throw new NullPointerException();\n        if(string.isEmpty()) throw  new IllegalArgumentException();\n        return string;\n    }\n\n    static double checkParam(double d) {\n        if(d <= 0) throw new IllegalArgumentException();\n        return d;\n    }\n\n    static int checkParam(int i) {\n        if(i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static void checkParam(Map<String, Integer> mapToCheck){\n        Objects.requireNonNull(mapToCheck);\n\n        for (Map.Entry<String, Integer> entry : mapToCheck.entrySet()) {\n            if (entry.getKey() == null) throw new NullPointerException();\n            if (entry.getValue() == null) throw new NullPointerException();\n        }\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Objects;\n\nclass Validator {\n    static String checkParam(String string) {\n        if(Objects.isNull(string)) throw new NullPointerException();\n        if(string.isEmpty()) throw  new IllegalArgumentException();\n        return string;\n    }\n\n    static double checkParam(double d) {\n        if(d <= 0) throw new IllegalArgumentException();\n        return d;\n    }\n\n    static int checkParam(int i) {\n        if(i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static void checkParam(Map<String, Integer> mapToCheck){\n        Objects.requireNonNull(mapToCheck);\n\n        for (Map.Entry<String, Integer> entry : mapToCheck.entrySet()) {\n            if (entry.getKey() == null) throw new NullPointerException();\n            if (entry.getValue() == null) throw new NullPointerException();\n        }\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Map;\nimport java.util.Objects;\n\nclass Validator {\n    static String checkParam(String string) {\n        if(Objects.isNull(string)) throw new NullPointerException();\n        if(string.isEmpty()) throw  new IllegalArgumentException();\n        return string;\n    }\n\n    static double checkParam(double d) {\n        if(d <= 0) throw new IllegalArgumentException();\n        return d;\n    }\n\n    static int checkParam(int i) {\n        if(i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    static void checkParam(Map<String, Integer> mapToCheck){\n        Objects.requireNonNull(mapToCheck);\n\n        for (Map.Entry<String, Integer> entry : mapToCheck.entrySet()) {\n            if (entry.getKey() == null) throw new NullPointerException();\n            if (entry.getValue() == null) throw new NullPointerException();\n        }\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "String Processing",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Leet {\n    static Map<String, String> map = new LinkedHashMap<String, String>(){\n            {\n                put(\"elite\", \"1337\");\n                put(\"!\", \"!!!11\");\n                put(\"cool\", \"k3wl\");\n                put(\"ck\", \"xx\");\n                put(\"ers\", \"0rz\");\n                put(\"er\", \"0rz\");\n                put(\"en\", \"n\");\n                put(\"t\", \"7\");\n                put(\"e\", \"3\");\n                put(\"o\", \"0\");\n                put(\"a\", \"@\");\n            }};\n\n\n    public static String toLeet(String normal){\n        String result = normal;\n        System.out.print(result);\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            result = result.replaceAll(entry.getKey(), entry.getValue());\n        }\n        System.out.println(\" -> \" + result);\n\n        return result;\n    }\n\n    public static String[] allToLeet(String[] org) {\n        String res [] = new String[org.length];\n        for( int i = 0; i < org.length; i++) res[i] = toLeet(org[i]);\n        return res;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "String Processing",
    "message": "Variable 'map' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "32",
    "end_column": "32",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Leet {\n    static Map<String, String> map = new LinkedHashMap<String, String>(){\n            {\n                put(\"elite\", \"1337\");\n                put(\"!\", \"!!!11\");\n                put(\"cool\", \"k3wl\");\n                put(\"ck\", \"xx\");\n                put(\"ers\", \"0rz\");\n                put(\"er\", \"0rz\");\n                put(\"en\", \"n\");\n                put(\"t\", \"7\");\n                put(\"e\", \"3\");\n                put(\"o\", \"0\");\n                put(\"a\", \"@\");\n            }};\n\n\n    public static String toLeet(String normal){\n        String result = normal;\n        System.out.print(result);\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            result = result.replaceAll(entry.getKey(), entry.getValue());\n        }\n        System.out.println(\" -> \" + result);\n\n        return result;\n    }\n\n    public static String[] allToLeet(String[] org) {\n        String res [] = new String[org.length];\n        for( int i = 0; i < org.length; i++) res[i] = toLeet(org[i]);\n        return res;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "String Processing",
    "message": "'}' at column 13 should be alone on a line.",
    "priority": "error",
    "start_line": "18",
    "end_line": "18",
    "start_column": "13",
    "end_column": "13",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Leet {\n    static Map<String, String> map = new LinkedHashMap<String, String>(){\n            {\n                put(\"elite\", \"1337\");\n                put(\"!\", \"!!!11\");\n                put(\"cool\", \"k3wl\");\n                put(\"ck\", \"xx\");\n                put(\"ers\", \"0rz\");\n                put(\"er\", \"0rz\");\n                put(\"en\", \"n\");\n                put(\"t\", \"7\");\n                put(\"e\", \"3\");\n                put(\"o\", \"0\");\n                put(\"a\", \"@\");\n            }};\n\n\n    public static String toLeet(String normal){\n        String result = normal;\n        System.out.print(result);\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            result = result.replaceAll(entry.getKey(), entry.getValue());\n        }\n        System.out.println(\" -> \" + result);\n\n        return result;\n    }\n\n    public static String[] allToLeet(String[] org) {\n        String res [] = new String[org.length];\n        for( int i = 0; i < org.length; i++) res[i] = toLeet(org[i]);\n        return res;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "String Processing",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "34",
    "end_line": "34",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Leet {\n    static Map<String, String> map = new LinkedHashMap<String, String>(){\n            {\n                put(\"elite\", \"1337\");\n                put(\"!\", \"!!!11\");\n                put(\"cool\", \"k3wl\");\n                put(\"ck\", \"xx\");\n                put(\"ers\", \"0rz\");\n                put(\"er\", \"0rz\");\n                put(\"en\", \"n\");\n                put(\"t\", \"7\");\n                put(\"e\", \"3\");\n                put(\"o\", \"0\");\n                put(\"a\", \"@\");\n            }};\n\n\n    public static String toLeet(String normal){\n        String result = normal;\n        System.out.print(result);\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            result = result.replaceAll(entry.getKey(), entry.getValue());\n        }\n        System.out.println(\" -> \" + result);\n\n        return result;\n    }\n\n    public static String[] allToLeet(String[] org) {\n        String res [] = new String[org.length];\n        for( int i = 0; i < org.length; i++) res[i] = toLeet(org[i]);\n        return res;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Functions",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "public class Functions {\n\n    public static int factorial (int n){\n        if (n == 0) {\n            return 1;\n        } else {\n            return n * factorial(n-1);\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "Name 'Auction' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic abstract class Auction {\n    private boolean closed;\n    private List<Person> bidders;\n    private List<Item> allItems;\n\n    Auction() {\n        closed = false;\n        bidders = new ArrayList<>();\n        allItems = new ArrayList<>();\n    }\n\n    public void addBid(String itemName, String nameOfBidder, long price) {\n        Validator.checkParam(itemName);\n        Validator.checkParam(price);\n        Person bidder = this.findBidderOrNew(nameOfBidder);\n        Item item = this.findItem(itemName);\n        if (!bidders.contains(bidder)) {\n            bidders.add(bidder);\n        }\n        item.addBid(bidder, price);\n    }\n\n    private Item findItem(String itemName) {\n        return allItems\n                .stream()\n                .filter(item1 -> item1.getName().equals(itemName))\n                .findAny().get();\n    }\n\n\n    private Person findBidderOrNew(String name){\n        return bidders.stream()\n                .filter(person -> person.getName().equals(name))\n                .findAny()\n                .orElse(new Person(name));\n    }\n\n    // because in the test is int (UML - long)\n    void addBid(String itemName, String nameOfBidder, int price) {\n        this.checkClosed();\n        this.addBid(itemName, nameOfBidder, Long.valueOf(price));\n    }\n\n    void registerItem(Item item) {\n        Objects.requireNonNull(item);\n        this.checkClosed();\n        if (this.exist(item)) {\n            throw new IllegalArgumentException(\"This item is already in the auction!\");\n        }\n        allItems.add(item);\n    }\n\n    private boolean exist(Item item) {\n        return allItems\n                .stream()\n                .anyMatch(\n                        item1 -> item.getName().equals(item1.getName())\n                );\n    }\n\n    private void checkClosed(){\n        if (this.closed) throw new IllegalStateException();\n    }\n\n    String closeAuction() {\n        this.checkClosed();\n        this.closed = true;\n        return this.generateItemListString();\n    }\n\n    List<Item> getAllItems() {\n        return allItems;\n    }\n\n    String generateItemListString() {\n        StringBuilder builder = new StringBuilder();\n        this.allItems.forEach(item -> builder.append(generateItemString(item)).append(\"\\n\"));\n        return builder.toString();\n    }\n\n    String generateAllBidsString(Item item) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"All bids:\");\n        item.getAllBids().forEach(bid -> builder.append(\"\\n\").append(bid.toString()));\n        return builder.toString();\n    }\n\n    public abstract String generateItemString(Item item);\n}"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "Overload methods should not be split. Previous overloaded method located at line '16'.",
    "priority": "error",
    "start_line": "43",
    "end_line": "43",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "OverloadMethodsDeclarationOrder",
      "explanation": "Overloaded methods should be placed next to each other to increase readability. Overloaded methods are methods, which have the same name but different sets of parameters.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic abstract class Auction {\n    private boolean closed;\n    private List<Person> bidders;\n    private List<Item> allItems;\n\n    Auction() {\n        closed = false;\n        bidders = new ArrayList<>();\n        allItems = new ArrayList<>();\n    }\n\n    public void addBid(String itemName, String nameOfBidder, long price) {\n        Validator.checkParam(itemName);\n        Validator.checkParam(price);\n        Person bidder = this.findBidderOrNew(nameOfBidder);\n        Item item = this.findItem(itemName);\n        if (!bidders.contains(bidder)) {\n            bidders.add(bidder);\n        }\n        item.addBid(bidder, price);\n    }\n\n    private Item findItem(String itemName) {\n        return allItems\n                .stream()\n                .filter(item1 -> item1.getName().equals(itemName))\n                .findAny().get();\n    }\n\n\n    private Person findBidderOrNew(String name){\n        return bidders.stream()\n                .filter(person -> person.getName().equals(name))\n                .findAny()\n                .orElse(new Person(name));\n    }\n\n    // because in the test is int (UML - long)\n    void addBid(String itemName, String nameOfBidder, int price) {\n        this.checkClosed();\n        this.addBid(itemName, nameOfBidder, Long.valueOf(price));\n    }\n\n    void registerItem(Item item) {\n        Objects.requireNonNull(item);\n        this.checkClosed();\n        if (this.exist(item)) {\n            throw new IllegalArgumentException(\"This item is already in the auction!\");\n        }\n        allItems.add(item);\n    }\n\n    private boolean exist(Item item) {\n        return allItems\n                .stream()\n                .anyMatch(\n                        item1 -> item.getName().equals(item1.getName())\n                );\n    }\n\n    private void checkClosed(){\n        if (this.closed) throw new IllegalStateException();\n    }\n\n    String closeAuction() {\n        this.checkClosed();\n        this.closed = true;\n        return this.generateItemListString();\n    }\n\n    List<Item> getAllItems() {\n        return allItems;\n    }\n\n    String generateItemListString() {\n        StringBuilder builder = new StringBuilder();\n        this.allItems.forEach(item -> builder.append(generateItemString(item)).append(\"\\n\"));\n        return builder.toString();\n    }\n\n    String generateAllBidsString(Item item) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"All bids:\");\n        item.getAllBids().forEach(bid -> builder.append(\"\\n\").append(bid.toString()));\n        return builder.toString();\n    }\n\n    public abstract String generateItemString(Item item);\n}"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "66",
    "end_line": "66",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic abstract class Auction {\n    private boolean closed;\n    private List<Person> bidders;\n    private List<Item> allItems;\n\n    Auction() {\n        closed = false;\n        bidders = new ArrayList<>();\n        allItems = new ArrayList<>();\n    }\n\n    public void addBid(String itemName, String nameOfBidder, long price) {\n        Validator.checkParam(itemName);\n        Validator.checkParam(price);\n        Person bidder = this.findBidderOrNew(nameOfBidder);\n        Item item = this.findItem(itemName);\n        if (!bidders.contains(bidder)) {\n            bidders.add(bidder);\n        }\n        item.addBid(bidder, price);\n    }\n\n    private Item findItem(String itemName) {\n        return allItems\n                .stream()\n                .filter(item1 -> item1.getName().equals(itemName))\n                .findAny().get();\n    }\n\n\n    private Person findBidderOrNew(String name){\n        return bidders.stream()\n                .filter(person -> person.getName().equals(name))\n                .findAny()\n                .orElse(new Person(name));\n    }\n\n    // because in the test is int (UML - long)\n    void addBid(String itemName, String nameOfBidder, int price) {\n        this.checkClosed();\n        this.addBid(itemName, nameOfBidder, Long.valueOf(price));\n    }\n\n    void registerItem(Item item) {\n        Objects.requireNonNull(item);\n        this.checkClosed();\n        if (this.exist(item)) {\n            throw new IllegalArgumentException(\"This item is already in the auction!\");\n        }\n        allItems.add(item);\n    }\n\n    private boolean exist(Item item) {\n        return allItems\n                .stream()\n                .anyMatch(\n                        item1 -> item.getName().equals(item1.getName())\n                );\n    }\n\n    private void checkClosed(){\n        if (this.closed) throw new IllegalStateException();\n    }\n\n    String closeAuction() {\n        this.checkClosed();\n        this.closed = true;\n        return this.generateItemListString();\n    }\n\n    List<Item> getAllItems() {\n        return allItems;\n    }\n\n    String generateItemListString() {\n        StringBuilder builder = new StringBuilder();\n        this.allItems.forEach(item -> builder.append(generateItemString(item)).append(\"\\n\"));\n        return builder.toString();\n    }\n\n    String generateAllBidsString(Item item) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"All bids:\");\n        item.getAllBids().forEach(bid -> builder.append(\"\\n\").append(bid.toString()));\n        return builder.toString();\n    }\n\n    public abstract String generateItemString(Item item);\n}"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class EnglishAuction extends Auction {\n    @Override\n    public String generateItemString(Item item) {\n        Objects.requireNonNull(item);\n        StringBuilder builder = new StringBuilder();\n        builder.append(item);\n        if(item.getAllBids().isEmpty())\n            builder.append(\"\\nNo bids placed\");\n        else\n            builder\n                    .append(\"\\nHighest bid: \")\n                    .append(item.getHighestBid().toString());\n        return builder.toString() ;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class EnglishAuction extends Auction {\n    @Override\n    public String generateItemString(Item item) {\n        Objects.requireNonNull(item);\n        StringBuilder builder = new StringBuilder();\n        builder.append(item);\n        if(item.getAllBids().isEmpty())\n            builder.append(\"\\nNo bids placed\");\n        else\n            builder\n                    .append(\"\\nHighest bid: \")\n                    .append(item.getHighestBid().toString());\n        return builder.toString() ;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\nclass Item {\n    private String name;\n    private String description;\n    private long minPrice;\n    private List<Bid> allBids;\n    private Bid highestBid;\n\n    Item(String name, String description, long minPrice){\n        this.name = Validator.checkParam(name);\n        this.description = Validator.checkParam(description);\n        this.minPrice = Validator.checkParam(minPrice);\n        this.allBids = new ArrayList<>();\n    }\n\n    public void addBid(Person bidder, long price){\n        Objects.requireNonNull(bidder);\n        Validator.checkParam(price);\n\n        if (this.isLessThanMaxPrice(price) || this.isLessThanMinPrice(price))\n            return;\n        Bid bid = new Bid(bidder, price);\n        this.updateHighestBid(bid, price);\n        allBids.add(bid);\n    }\n\n    public List<Bid> getAllBids(){\n        return this.allBids;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public Bid getHighestBid() {\n        return highestBid;\n    }\n\n    private void updateHighestBid(Bid bid, long price){\n        if (highestBid == null || highestBid.getPrice() < price) {\n            highestBid = bid;\n        }\n    }\n\n    private boolean isLessThanMaxPrice(long price) {\n        return highestBid != null && price <= highestBid.getPrice();\n    }\n\n    private boolean isLessThanMinPrice(long price) {\n        return price < this.minPrice;\n    }\n\n    @Override\n    public String toString() {\n        return this.getName() + \": \"\n                + this.getDescription()\n                +\" (minimum bidding price: \" + this.minPrice + \" EUR)\";\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static void checkParam(String... strs){\n        for (String str : strs) checkParam(str);\n    }\n\n    public static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if (str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static long checkParam(long l) {\n        if (l <= 0) throw new IllegalArgumentException();\n        return l;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static void checkParam(String... strs){\n        for (String str : strs) checkParam(str);\n    }\n\n    public static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if (str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static long checkParam(long l) {\n        if (l <= 0) throw new IllegalArgumentException();\n        return l;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static void checkParam(String... strs){\n        for (String str : strs) checkParam(str);\n    }\n\n    public static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if (str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static long checkParam(long l) {\n        if (l <= 0) throw new IllegalArgumentException();\n        return l;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Auction System",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static void checkParam(String... strs){\n        for (String str : strs) checkParam(str);\n    }\n\n    public static String checkParam(String str){\n        Objects.requireNonNull(str);\n        if (str.isEmpty()) throw new IllegalArgumentException();\n        return str;\n    }\n\n    public static long checkParam(long l) {\n        if (l <= 0) throw new IllegalArgumentException();\n        return l;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Taxi",
    "message": "'{' at column 29 should have line break after.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": "29",
    "end_column": "29",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Human {\n    private String forename;\n    private String name;\n\n    public Human (String forename, String name){\n        this.forename = forename;\n        this.name = name;\n    }\n\n    public String getForename() {\n        return forename;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String toString(){ return this.forename + \" \" + this.name; }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Taxi",
    "message": "'}' at column 71 should be alone on a line.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": "71",
    "end_column": "71",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Human {\n    private String forename;\n    private String name;\n\n    public Human (String forename, String name){\n        this.forename = forename;\n        this.name = name;\n    }\n\n    public String getForename() {\n        return forename;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String toString(){ return this.forename + \" \" + this.name; }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Taxi",
    "message": "'{' at column 31 should have line break after.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\n\npublic class Taxi {\n    private static final int MAX_PASSENGERS_AMOUNT = 4;\n    private Human driver;\n    private ArrayList<Human> passengers = new ArrayList<>();\n\n    public Taxi(Human driver) { this.driver = driver; }\n\n    public String getDriverName() {\n        return driver.toString();\n    }\n\n    public Human[] allGetOut(){\n        Human[] passengersArray = this.passengers.toArray(new Human[0]);\n        this.passengers.clear();\n        return passengersArray;\n    }\n\n    public void add(Human x) {\n        if (this.passengers.size() < MAX_PASSENGERS_AMOUNT) {\n            passengers.add(x);\n            System.out.println(x.toString() + \" gets in.\");\n        }\n        else\n            System.out.println(\"We are sorry, \" + x.toString() + \". The taxi is full.\");\n    }\n\n    @Override\n    public String toString(){\n        StringBuilder taxiInfo = new StringBuilder(\"This is the taxi of \" + getDriverName() + \". He takes \");\n        taxiInfo.append(getPassengers(this.passengers.size()));\n        taxiInfo.append(\" along.\");\n        return taxiInfo.toString();\n    }\n\n    private String getPassengers(int size) {\n        StringBuilder passengers = new StringBuilder();\n        switch (size){\n            case 1:\n                passengers.append(this.passengers.get(0).toString());\n                break;\n            case 2:\n                passengers.append(this.passengers.get(0).toString()).append(\" and \")\n                        .append(this.passengers.get(1).toString());\n                break;\n            case 3:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\" and \")\n                        .append(this.passengers.get(2).toString());\n                break;\n            case 4:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\", \")\n                        .append(this.passengers.get(2).toString()).append(\" and \")\n                        .append(this.passengers.get(3).toString());\n                break;\n            default:\n                passengers.append(\"nobody\");\n                break;\n        }\n        return passengers.toString();\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Taxi",
    "message": "'}' at column 55 should be alone on a line.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "55",
    "end_column": "55",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\n\npublic class Taxi {\n    private static final int MAX_PASSENGERS_AMOUNT = 4;\n    private Human driver;\n    private ArrayList<Human> passengers = new ArrayList<>();\n\n    public Taxi(Human driver) { this.driver = driver; }\n\n    public String getDriverName() {\n        return driver.toString();\n    }\n\n    public Human[] allGetOut(){\n        Human[] passengersArray = this.passengers.toArray(new Human[0]);\n        this.passengers.clear();\n        return passengersArray;\n    }\n\n    public void add(Human x) {\n        if (this.passengers.size() < MAX_PASSENGERS_AMOUNT) {\n            passengers.add(x);\n            System.out.println(x.toString() + \" gets in.\");\n        }\n        else\n            System.out.println(\"We are sorry, \" + x.toString() + \". The taxi is full.\");\n    }\n\n    @Override\n    public String toString(){\n        StringBuilder taxiInfo = new StringBuilder(\"This is the taxi of \" + getDriverName() + \". He takes \");\n        taxiInfo.append(getPassengers(this.passengers.size()));\n        taxiInfo.append(\" along.\");\n        return taxiInfo.toString();\n    }\n\n    private String getPassengers(int size) {\n        StringBuilder passengers = new StringBuilder();\n        switch (size){\n            case 1:\n                passengers.append(this.passengers.get(0).toString());\n                break;\n            case 2:\n                passengers.append(this.passengers.get(0).toString()).append(\" and \")\n                        .append(this.passengers.get(1).toString());\n                break;\n            case 3:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\" and \")\n                        .append(this.passengers.get(2).toString());\n                break;\n            case 4:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\", \")\n                        .append(this.passengers.get(2).toString()).append(\" and \")\n                        .append(this.passengers.get(3).toString());\n                break;\n            default:\n                passengers.append(\"nobody\");\n                break;\n        }\n        return passengers.toString();\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Taxi",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\n\npublic class Taxi {\n    private static final int MAX_PASSENGERS_AMOUNT = 4;\n    private Human driver;\n    private ArrayList<Human> passengers = new ArrayList<>();\n\n    public Taxi(Human driver) { this.driver = driver; }\n\n    public String getDriverName() {\n        return driver.toString();\n    }\n\n    public Human[] allGetOut(){\n        Human[] passengersArray = this.passengers.toArray(new Human[0]);\n        this.passengers.clear();\n        return passengersArray;\n    }\n\n    public void add(Human x) {\n        if (this.passengers.size() < MAX_PASSENGERS_AMOUNT) {\n            passengers.add(x);\n            System.out.println(x.toString() + \" gets in.\");\n        }\n        else\n            System.out.println(\"We are sorry, \" + x.toString() + \". The taxi is full.\");\n    }\n\n    @Override\n    public String toString(){\n        StringBuilder taxiInfo = new StringBuilder(\"This is the taxi of \" + getDriverName() + \". He takes \");\n        taxiInfo.append(getPassengers(this.passengers.size()));\n        taxiInfo.append(\" along.\");\n        return taxiInfo.toString();\n    }\n\n    private String getPassengers(int size) {\n        StringBuilder passengers = new StringBuilder();\n        switch (size){\n            case 1:\n                passengers.append(this.passengers.get(0).toString());\n                break;\n            case 2:\n                passengers.append(this.passengers.get(0).toString()).append(\" and \")\n                        .append(this.passengers.get(1).toString());\n                break;\n            case 3:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\" and \")\n                        .append(this.passengers.get(2).toString());\n                break;\n            case 4:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\", \")\n                        .append(this.passengers.get(2).toString()).append(\" and \")\n                        .append(this.passengers.get(3).toString());\n                break;\n            default:\n                passengers.append(\"nobody\");\n                break;\n        }\n        return passengers.toString();\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Taxi",
    "message": "'passengers' hides a field.",
    "priority": "error",
    "start_line": "38",
    "end_line": "38",
    "start_column": "23",
    "end_column": "23",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\n\npublic class Taxi {\n    private static final int MAX_PASSENGERS_AMOUNT = 4;\n    private Human driver;\n    private ArrayList<Human> passengers = new ArrayList<>();\n\n    public Taxi(Human driver) { this.driver = driver; }\n\n    public String getDriverName() {\n        return driver.toString();\n    }\n\n    public Human[] allGetOut(){\n        Human[] passengersArray = this.passengers.toArray(new Human[0]);\n        this.passengers.clear();\n        return passengersArray;\n    }\n\n    public void add(Human x) {\n        if (this.passengers.size() < MAX_PASSENGERS_AMOUNT) {\n            passengers.add(x);\n            System.out.println(x.toString() + \" gets in.\");\n        }\n        else\n            System.out.println(\"We are sorry, \" + x.toString() + \". The taxi is full.\");\n    }\n\n    @Override\n    public String toString(){\n        StringBuilder taxiInfo = new StringBuilder(\"This is the taxi of \" + getDriverName() + \". He takes \");\n        taxiInfo.append(getPassengers(this.passengers.size()));\n        taxiInfo.append(\" along.\");\n        return taxiInfo.toString();\n    }\n\n    private String getPassengers(int size) {\n        StringBuilder passengers = new StringBuilder();\n        switch (size){\n            case 1:\n                passengers.append(this.passengers.get(0).toString());\n                break;\n            case 2:\n                passengers.append(this.passengers.get(0).toString()).append(\" and \")\n                        .append(this.passengers.get(1).toString());\n                break;\n            case 3:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\" and \")\n                        .append(this.passengers.get(2).toString());\n                break;\n            case 4:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\", \")\n                        .append(this.passengers.get(2).toString()).append(\" and \")\n                        .append(this.passengers.get(3).toString());\n                break;\n            default:\n                passengers.append(\"nobody\");\n                break;\n        }\n        return passengers.toString();\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Taxi",
    "message": "'3' is a magic number.",
    "priority": "error",
    "start_line": "47",
    "end_line": "47",
    "start_column": "18",
    "end_column": "18",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\n\npublic class Taxi {\n    private static final int MAX_PASSENGERS_AMOUNT = 4;\n    private Human driver;\n    private ArrayList<Human> passengers = new ArrayList<>();\n\n    public Taxi(Human driver) { this.driver = driver; }\n\n    public String getDriverName() {\n        return driver.toString();\n    }\n\n    public Human[] allGetOut(){\n        Human[] passengersArray = this.passengers.toArray(new Human[0]);\n        this.passengers.clear();\n        return passengersArray;\n    }\n\n    public void add(Human x) {\n        if (this.passengers.size() < MAX_PASSENGERS_AMOUNT) {\n            passengers.add(x);\n            System.out.println(x.toString() + \" gets in.\");\n        }\n        else\n            System.out.println(\"We are sorry, \" + x.toString() + \". The taxi is full.\");\n    }\n\n    @Override\n    public String toString(){\n        StringBuilder taxiInfo = new StringBuilder(\"This is the taxi of \" + getDriverName() + \". He takes \");\n        taxiInfo.append(getPassengers(this.passengers.size()));\n        taxiInfo.append(\" along.\");\n        return taxiInfo.toString();\n    }\n\n    private String getPassengers(int size) {\n        StringBuilder passengers = new StringBuilder();\n        switch (size){\n            case 1:\n                passengers.append(this.passengers.get(0).toString());\n                break;\n            case 2:\n                passengers.append(this.passengers.get(0).toString()).append(\" and \")\n                        .append(this.passengers.get(1).toString());\n                break;\n            case 3:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\" and \")\n                        .append(this.passengers.get(2).toString());\n                break;\n            case 4:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\", \")\n                        .append(this.passengers.get(2).toString()).append(\" and \")\n                        .append(this.passengers.get(3).toString());\n                break;\n            default:\n                passengers.append(\"nobody\");\n                break;\n        }\n        return passengers.toString();\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Taxi",
    "message": "'4' is a magic number.",
    "priority": "error",
    "start_line": "52",
    "end_line": "52",
    "start_column": "18",
    "end_column": "18",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\n\npublic class Taxi {\n    private static final int MAX_PASSENGERS_AMOUNT = 4;\n    private Human driver;\n    private ArrayList<Human> passengers = new ArrayList<>();\n\n    public Taxi(Human driver) { this.driver = driver; }\n\n    public String getDriverName() {\n        return driver.toString();\n    }\n\n    public Human[] allGetOut(){\n        Human[] passengersArray = this.passengers.toArray(new Human[0]);\n        this.passengers.clear();\n        return passengersArray;\n    }\n\n    public void add(Human x) {\n        if (this.passengers.size() < MAX_PASSENGERS_AMOUNT) {\n            passengers.add(x);\n            System.out.println(x.toString() + \" gets in.\");\n        }\n        else\n            System.out.println(\"We are sorry, \" + x.toString() + \". The taxi is full.\");\n    }\n\n    @Override\n    public String toString(){\n        StringBuilder taxiInfo = new StringBuilder(\"This is the taxi of \" + getDriverName() + \". He takes \");\n        taxiInfo.append(getPassengers(this.passengers.size()));\n        taxiInfo.append(\" along.\");\n        return taxiInfo.toString();\n    }\n\n    private String getPassengers(int size) {\n        StringBuilder passengers = new StringBuilder();\n        switch (size){\n            case 1:\n                passengers.append(this.passengers.get(0).toString());\n                break;\n            case 2:\n                passengers.append(this.passengers.get(0).toString()).append(\" and \")\n                        .append(this.passengers.get(1).toString());\n                break;\n            case 3:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\" and \")\n                        .append(this.passengers.get(2).toString());\n                break;\n            case 4:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\", \")\n                        .append(this.passengers.get(2).toString()).append(\" and \")\n                        .append(this.passengers.get(3).toString());\n                break;\n            default:\n                passengers.append(\"nobody\");\n                break;\n        }\n        return passengers.toString();\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Taxi",
    "message": "'3' is a magic number.",
    "priority": "error",
    "start_line": "56",
    "end_line": "56",
    "start_column": "53",
    "end_column": "53",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\n\npublic class Taxi {\n    private static final int MAX_PASSENGERS_AMOUNT = 4;\n    private Human driver;\n    private ArrayList<Human> passengers = new ArrayList<>();\n\n    public Taxi(Human driver) { this.driver = driver; }\n\n    public String getDriverName() {\n        return driver.toString();\n    }\n\n    public Human[] allGetOut(){\n        Human[] passengersArray = this.passengers.toArray(new Human[0]);\n        this.passengers.clear();\n        return passengersArray;\n    }\n\n    public void add(Human x) {\n        if (this.passengers.size() < MAX_PASSENGERS_AMOUNT) {\n            passengers.add(x);\n            System.out.println(x.toString() + \" gets in.\");\n        }\n        else\n            System.out.println(\"We are sorry, \" + x.toString() + \". The taxi is full.\");\n    }\n\n    @Override\n    public String toString(){\n        StringBuilder taxiInfo = new StringBuilder(\"This is the taxi of \" + getDriverName() + \". He takes \");\n        taxiInfo.append(getPassengers(this.passengers.size()));\n        taxiInfo.append(\" along.\");\n        return taxiInfo.toString();\n    }\n\n    private String getPassengers(int size) {\n        StringBuilder passengers = new StringBuilder();\n        switch (size){\n            case 1:\n                passengers.append(this.passengers.get(0).toString());\n                break;\n            case 2:\n                passengers.append(this.passengers.get(0).toString()).append(\" and \")\n                        .append(this.passengers.get(1).toString());\n                break;\n            case 3:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\" and \")\n                        .append(this.passengers.get(2).toString());\n                break;\n            case 4:\n                passengers.append(this.passengers.get(0).toString()).append(\", \")\n                        .append(this.passengers.get(1).toString()).append(\", \")\n                        .append(this.passengers.get(2).toString()).append(\" and \")\n                        .append(this.passengers.get(3).toString());\n                break;\n            default:\n                passengers.append(\"nobody\");\n                break;\n        }\n        return passengers.toString();\n    }\n\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "'static' modifier out of order with the JLS suggestions.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "19",
    "end_column": "19",
    "rule": {
      "identifier": "ModifierOrder",
      "explanation": "The order of modifiers should conform to the Java language specification. Declare modifiers in the following order: public, protected, private, abstract, default, static, final, transient, volatile, synchronized, native, strictfp. Annotations should be placed before any modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Appointee extends Employee {\n    private int payday;\n    private int hoursPerMonth;\n    private double payPerHour;\n    private final static double LIFE = 0.4d;\n\n    public Appointee(String id, int payday, int hoursPerMonth, double payPerHour) {\n        super(id);\n        this.payday = Validator.checkDayInMonth(payday);\n        this.payPerHour = Validator.checkParam(payPerHour);\n        this.hoursPerMonth = Validator.checkParam(hoursPerMonth);\n    }\n\n    @Override\n    public boolean isPayday(int dayOfMonth) {\n        return dayOfMonth == this.payday;\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException  {\n        return this.hoursPerMonth * this.payPerHour;\n    }\n\n    @Override\n    public double calculateDeductions() {\n        try {\n            return this.calculatePay() * LIFE;\n        } catch (UnpayableEmployeeException e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "Name 'Employee' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public abstract class Employee {\n    private String id;\n\n    public Employee(String id){\n        this.id = Validator.checkParam(id);\n    }\n\n    public String getId() {\n        return this.id;\n    }\n\n    public abstract boolean isPayday(int dayOfMonth);\n    public abstract double calculatePay() throws UnpayableEmployeeException;\n    public abstract double calculateDeductions();\n\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "Abbreviation in name 'payrollDB' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Payroll {\n    private int payday;\n    private PayrollDisposition disposition;\n\n\n    public Payroll(PayrollDisposition disposition, int payday) {\n        this.disposition = Objects.requireNonNull(disposition);\n        this.payday = Validator.checkDayInMonth(payday);\n    }\n\n    public void doPayroll(PayrollDB payrollDB) {\n        Objects.requireNonNull(payrollDB);\n        payrollDB\n                .getEmployeeList()\n                .stream()\n                .filter(employee -> employee instanceof Appointee && employee.isPayday(payday))\n                .forEach(e -> {\n                    try {\n                        disposition.sendPayment(e, e.calculatePay() - e.calculateDeductions());\n                    } catch (UnpayableEmployeeException ex) {\n                        ex.printStackTrace();\n                    }\n                });\n\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "Abbreviation in name 'PayrollDB' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.List;\n\npublic interface PayrollDB {\n    List<Employee> getEmployeeList();\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class PayrollDispositionImpl implements PayrollDisposition {\n\n    private Map<Employee, Double> payments;\n\n    public PayrollDispositionImpl(){\n        this.payments = new LinkedHashMap<>();\n    }\n\n    public double getTotal(){\n        return this.payments\n                .entrySet()\n                .stream()\n                .mapToDouble(Map.Entry::getValue)\n                .sum();\n    }\n\n    public double getAverage(){\n        if(this.payments.isEmpty()) return 0;\n        return this.getTotal() / this.payments.size();\n    }\n\n    public Map<Employee, Double> getPayments() {\n        return this.payments;\n    }\n\n    @Override\n    public void sendPayment(Employee employee, double payment) {\n        Validator.checkParam(payment);\n        Objects.requireNonNull(employee);\n        this.payments.put(employee, payment);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "public class Utils {\n    public static double round(double d){\n        return (double) (Math.round(d * 10)/ 10);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "'10' is a magic number.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "41",
    "end_column": "41",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Utils {\n    public static double round(double d){\n        return (double) (Math.round(d * 10)/ 10);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "'10' is a magic number.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "46",
    "end_column": "46",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Utils {\n    public static double round(double d){\n        return (double) (Math.round(d * 10)/ 10);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static int checkParam(int i){\n        if (i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    public static int checkDayInMonth(int day){\n        if (day <= 0 || day > 31) throw new IllegalArgumentException();\n        return day;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static int checkParam(int i){\n        if (i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    public static int checkDayInMonth(int day){\n        if (day <= 0 || day > 31) throw new IllegalArgumentException();\n        return day;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static int checkParam(int i){\n        if (i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    public static int checkDayInMonth(int day){\n        if (day <= 0 || day > 31) throw new IllegalArgumentException();\n        return day;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static int checkParam(int i){\n        if (i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    public static int checkDayInMonth(int day){\n        if (day <= 0 || day > 31) throw new IllegalArgumentException();\n        return day;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static int checkParam(int i){\n        if (i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    public static int checkDayInMonth(int day){\n        if (day <= 0 || day > 31) throw new IllegalArgumentException();\n        return day;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Payroll",
    "message": "'31' is a magic number.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Validator {\n    public static String checkParam(String string){\n        Objects.requireNonNull(string);\n        if(string.isEmpty()) throw new IllegalArgumentException();\n        return string;\n    }\n\n    public static double checkParam(double d){\n        if (d <= 0d) throw new IllegalArgumentException();\n        return d;\n    }\n\n    public static int checkParam(int i){\n        if (i <= 0) throw new IllegalArgumentException();\n        return i;\n    }\n\n    public static int checkDayInMonth(int day){\n        if (day <= 0 || day > 31) throw new IllegalArgumentException();\n        return day;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class AbsoluteDiscountPricing implements ISalePricing {\n    private long threshold;\n    private long discount;\n\n    public AbsoluteDiscountPricing(long discount, long threshold) {\n        if (discount < 0 || threshold < 0) throw new IllegalArgumentException();\n        this.threshold = threshold;\n        this.discount = discount;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        if (sale.getPreDiscountTotal() - discount > threshold)  return sale.getPreDiscountTotal() - discount;\n        else if (threshold < sale.getPreDiscountTotal()) return threshold;\n        else return sale.getPreDiscountTotal();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class AbsoluteDiscountPricing implements ISalePricing {\n    private long threshold;\n    private long discount;\n\n    public AbsoluteDiscountPricing(long discount, long threshold) {\n        if (discount < 0 || threshold < 0) throw new IllegalArgumentException();\n        this.threshold = threshold;\n        this.discount = discount;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        if (sale.getPreDiscountTotal() - discount > threshold)  return sale.getPreDiscountTotal() - discount;\n        else if (threshold < sale.getPreDiscountTotal()) return threshold;\n        else return sale.getPreDiscountTotal();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class AbsoluteDiscountPricing implements ISalePricing {\n    private long threshold;\n    private long discount;\n\n    public AbsoluteDiscountPricing(long discount, long threshold) {\n        if (discount < 0 || threshold < 0) throw new IllegalArgumentException();\n        this.threshold = threshold;\n        this.discount = discount;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        if (sale.getPreDiscountTotal() - discount > threshold)  return sale.getPreDiscountTotal() - discount;\n        else if (threshold < sale.getPreDiscountTotal()) return threshold;\n        else return sale.getPreDiscountTotal();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class AbsoluteDiscountPricing implements ISalePricing {\n    private long threshold;\n    private long discount;\n\n    public AbsoluteDiscountPricing(long discount, long threshold) {\n        if (discount < 0 || threshold < 0) throw new IllegalArgumentException();\n        this.threshold = threshold;\n        this.discount = discount;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        if (sale.getPreDiscountTotal() - discount > threshold)  return sale.getPreDiscountTotal() - discount;\n        else if (threshold < sale.getPreDiscountTotal()) return threshold;\n        else return sale.getPreDiscountTotal();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "Name 'ComplexPricing' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\n\nimport java.util.List;\nimport java.util.Objects;\n\npublic abstract class ComplexPricing implements ISalePricing {\n    private List<ISalePricing> pricings = new ArrayList<>();\n\n    public ComplexPricing( ISalePricing pricing){\n\n    }\n\n    protected ComplexPricing() {\n    }\n\n    public void add(ISalePricing pricing) {\n        Objects.requireNonNull(pricing);\n        pricings.add(pricing);\n    }\n\n    public List<ISalePricing> getPricings() {\n        return pricings;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        return 0;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "Abbreviation in name 'ISalePricing' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "interface ISalePricing {\n    long getTotal(Sale sale);\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class PercentageDiscountPricing implements ISalePricing {\n    private double percentage;\n\n    public PercentageDiscountPricing(double percentage) {\n        if (percentage < 0 || percentage > 100) throw new IllegalArgumentException();\n        this.percentage = percentage;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        long p = (long) (sale.getPreDiscountTotal() * (this.percentage / 100.0f));\n        return sale.getPreDiscountTotal() - p;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "44",
    "end_column": "44",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class PercentageDiscountPricing implements ISalePricing {\n    private double percentage;\n\n    public PercentageDiscountPricing(double percentage) {\n        if (percentage < 0 || percentage > 100) throw new IllegalArgumentException();\n        this.percentage = percentage;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        long p = (long) (sale.getPreDiscountTotal() * (this.percentage / 100.0f));\n        return sale.getPreDiscountTotal() - p;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "'100.0f' is a magic number.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "74",
    "end_column": "74",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class PercentageDiscountPricing implements ISalePricing {\n    private double percentage;\n\n    public PercentageDiscountPricing(double percentage) {\n        if (percentage < 0 || percentage > 100) throw new IllegalArgumentException();\n        this.percentage = percentage;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        long p = (long) (sale.getPreDiscountTotal() * (this.percentage / 100.0f));\n        return sale.getPreDiscountTotal() - p;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Sale {\n    private long preDiscountTotal;\n    private ISalePricing pricing;\n\n    public Sale(long preDiscountTotal, ISalePricing pricing) {\n        Objects.requireNonNull(pricing);\n        if (preDiscountTotal < 0) throw new IllegalArgumentException();\n\n        this.preDiscountTotal = preDiscountTotal;\n        this.pricing = pricing;\n    }\n\n    public static ISalePricing createPricing(DiscountType discountType,\n                                             double percentage,\n                                             long discount,\n                                             long threshold){\n        switch (discountType){\n            case ABSOLUTEDISCOUNT:\n                return new AbsoluteDiscountPricing(discount, threshold);\n            case PERCENTAGEDISCOUNT:\n                return new PercentageDiscountPricing(percentage);\n        }\n        return null;\n    }\n\n    public long getPreDiscountTotal() {\n        return preDiscountTotal;\n    }\n\n    public void setPricing(ISalePricing pricing) {\n        Objects.requireNonNull(pricing);\n        this.pricing = pricing;\n    }\n\n    public long getTotal(){\n        return pricing.getTotal(this);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Pricing",
    "message": "switch without \"default\" clause.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "MissingSwitchDefault",
      "explanation": "Switch statements should contain a default to account for cases that get introduced by future revisions. Default cases can also throw exceptions if they are never expected to be executed.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\npublic class Sale {\n    private long preDiscountTotal;\n    private ISalePricing pricing;\n\n    public Sale(long preDiscountTotal, ISalePricing pricing) {\n        Objects.requireNonNull(pricing);\n        if (preDiscountTotal < 0) throw new IllegalArgumentException();\n\n        this.preDiscountTotal = preDiscountTotal;\n        this.pricing = pricing;\n    }\n\n    public static ISalePricing createPricing(DiscountType discountType,\n                                             double percentage,\n                                             long discount,\n                                             long threshold){\n        switch (discountType){\n            case ABSOLUTEDISCOUNT:\n                return new AbsoluteDiscountPricing(discount, threshold);\n            case PERCENTAGEDISCOUNT:\n                return new PercentageDiscountPricing(percentage);\n        }\n        return null;\n    }\n\n    public long getPreDiscountTotal() {\n        return preDiscountTotal;\n    }\n\n    public void setPricing(ISalePricing pricing) {\n        Objects.requireNonNull(pricing);\n        this.pricing = pricing;\n    }\n\n    public long getTotal(){\n        return pricing.getTotal(this);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Bottle",
    "message": "'content' hides a field.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": "24",
    "end_column": "24",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Bottle<T extends Drink> {\n    private T content;\n\n    public Bottle() {\n        this.content = null;\n    }\n\n    public boolean isEmpty() {\n        return this.getContent() == null;\n    }\n\n    public void fill(T content) {\n        if (this.isEmpty()) this.setContent(content);\n        else throw new IllegalStateException(\"Bottle is not empty!\");\n    }\n\n    public T empty() {\n        if (!this.isEmpty()) {\n            T content = this.content;\n            this.setContent(null);\n            return content;\n        } else throw new IllegalStateException(\"Bottle is empty!\");\n    }\n\n    private T getContent() {\n        return content;\n    }\n\n    private void setContent(T content) {\n        this.content = content;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Bottle",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Bottle<T extends Drink> {\n    private T content;\n\n    public Bottle() {\n        this.content = null;\n    }\n\n    public boolean isEmpty() {\n        return this.getContent() == null;\n    }\n\n    public void fill(T content) {\n        if (this.isEmpty()) this.setContent(content);\n        else throw new IllegalStateException(\"Bottle is not empty!\");\n    }\n\n    public T empty() {\n        if (!this.isEmpty()) {\n            T content = this.content;\n            this.setContent(null);\n            return content;\n        } else throw new IllegalStateException(\"Bottle is empty!\");\n    }\n\n    private T getContent() {\n        return content;\n    }\n\n    private void setContent(T content) {\n        this.content = content;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Bottle",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Bottle<T extends Drink> {\n    private T content;\n\n    public Bottle() {\n        this.content = null;\n    }\n\n    public boolean isEmpty() {\n        return this.getContent() == null;\n    }\n\n    public void fill(T content) {\n        if (this.isEmpty()) this.setContent(content);\n        else throw new IllegalStateException(\"Bottle is not empty!\");\n    }\n\n    public T empty() {\n        if (!this.isEmpty()) {\n            T content = this.content;\n            this.setContent(null);\n            return content;\n        } else throw new IllegalStateException(\"Bottle is empty!\");\n    }\n\n    private T getContent() {\n        return content;\n    }\n\n    private void setContent(T content) {\n        this.content = content;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Bottle",
    "message": "'content' hides a field.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Bottle<T extends Drink> {\n    private T content;\n\n    public Bottle() {\n        this.content = null;\n    }\n\n    public boolean isEmpty() {\n        return this.getContent() == null;\n    }\n\n    public void fill(T content) {\n        if (this.isEmpty()) this.setContent(content);\n        else throw new IllegalStateException(\"Bottle is not empty!\");\n    }\n\n    public T empty() {\n        if (!this.isEmpty()) {\n            T content = this.content;\n            this.setContent(null);\n            return content;\n        } else throw new IllegalStateException(\"Bottle is empty!\");\n    }\n\n    private T getContent() {\n        return content;\n    }\n\n    private void setContent(T content) {\n        this.content = content;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Bottle",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public class Bottle<T extends Drink> {\n    private T content;\n\n    public Bottle() {\n        this.content = null;\n    }\n\n    public boolean isEmpty() {\n        return this.getContent() == null;\n    }\n\n    public void fill(T content) {\n        if (this.isEmpty()) this.setContent(content);\n        else throw new IllegalStateException(\"Bottle is not empty!\");\n    }\n\n    public T empty() {\n        if (!this.isEmpty()) {\n            T content = this.content;\n            this.setContent(null);\n            return content;\n        } else throw new IllegalStateException(\"Bottle is empty!\");\n    }\n\n    private T getContent() {\n        return content;\n    }\n\n    private void setContent(T content) {\n        this.content = content;\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "Bottle",
    "message": "Name 'Drink' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public abstract class Drink {}"
  },
  {
    "user": "4",
    "task": "Bottle",
    "message": "Name 'Wine' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "public abstract class Wine extends Drink {\n    private String region;\n\n    public Wine(String region){\n        this.setRegion(region);\n    }\n\n    public String getRegion() {\n        return region;\n    }\n\n    public void setRegion(String brewery) {\n        this.region = brewery;\n    }\n\n    @Override\n    public String toString(){\n        return this.getRegion();\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        List<Integer> l1 = new ArrayList<>();\n        l1.add(1);\n        l1.add(1);\n        l1.add(2);\n        l1.add(3);\n        List<Integer> l2 = new ArrayList<>(l1);\n        l2.add(3);\n        System.out.println(\"Before = \" + l2);\n        l2.retainAll(l1);\n        System.out.println(\"After  = \" + l2);\n        System.out.println(\"L1     = \" + l1);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "'3' is a magic number.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        List<Integer> l1 = new ArrayList<>();\n        l1.add(1);\n        l1.add(1);\n        l1.add(2);\n        l1.add(3);\n        List<Integer> l2 = new ArrayList<>(l1);\n        l2.add(3);\n        System.out.println(\"Before = \" + l2);\n        l2.retainAll(l1);\n        System.out.println(\"After  = \" + l2);\n        System.out.println(\"L1     = \" + l1);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "'3' is a magic number.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        List<Integer> l1 = new ArrayList<>();\n        l1.add(1);\n        l1.add(1);\n        l1.add(2);\n        l1.add(3);\n        List<Integer> l2 = new ArrayList<>(l1);\n        l2.add(3);\n        System.out.println(\"Before = \" + l2);\n        l2.retainAll(l1);\n        System.out.println(\"After  = \" + l2);\n        System.out.println(\"L1     = \" + l1);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": "37",
    "end_column": "37",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Random;\n\npublic class MatrixIndex {\n    private int row;\n    private int column;\n\n    MatrixIndex (int row, int column){\n        this.row = row;\n        this.column = column;\n    }\n\n    public int getRow() {\n        return this.row;\n    }\n\n    public int getColumn() {\n        return this.column;\n    }\n\n    @Override\n    public boolean equals(Object o){\n        return false;\n    }\n\n    @Override\n    public int hashCode(){\n        return new Random().nextInt(100);\n    }\n}\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "Avoid inline conditionals.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": "28",
    "end_column": "28",
    "rule": {
      "identifier": "AvoidInlineConditionals",
      "explanation": "Inline conditionals should be avoided, since they are hard to read.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "Avoid inline conditionals.",
    "priority": "error",
    "start_line": "45",
    "end_line": "45",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "AvoidInlineConditionals",
      "explanation": "Inline conditionals should be avoided, since they are hard to read.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "Variable 'rowIndex' explicitly initialized to '0' (default value for its type).",
    "priority": "error",
    "start_line": "54",
    "end_line": "54",
    "start_column": "13",
    "end_column": "13",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "Variable 'rowIndex' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "54",
    "end_line": "54",
    "start_column": "13",
    "end_column": "13",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "Variable 'columnIndex' explicitly initialized to '0' (default value for its type).",
    "priority": "error",
    "start_line": "55",
    "end_line": "55",
    "start_column": "13",
    "end_column": "13",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "Variable 'columnIndex' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "55",
    "end_line": "55",
    "start_column": "13",
    "end_column": "13",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "'{' at column 34 should have line break after.",
    "priority": "error",
    "start_line": "59",
    "end_line": "59",
    "start_column": "34",
    "end_column": "34",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "'}' at column 88 should be alone on a line.",
    "priority": "error",
    "start_line": "59",
    "end_line": "59",
    "start_column": "88",
    "end_column": "88",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "88",
    "end_line": "88",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "100",
    "end_line": "100",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "'{' at column 38 should have line break after.",
    "priority": "error",
    "start_line": "107",
    "end_line": "107",
    "start_column": "38",
    "end_column": "38",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "4",
    "task": "My Matrix",
    "message": "'}' at column 76 should be alone on a line.",
    "priority": "error",
    "start_line": "107",
    "end_line": "107",
    "start_column": "76",
    "end_column": "76",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.awt.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\npublic class MyMatrix<T> implements Matrix<T> {\n    private HashMap<Point,T> matrix;\n    private ArrayList<Integer> columnList;\n    private ArrayList<Integer> rowList;\n\n\n\n    MyMatrix(){\n        matrix = new HashMap<>();\n        rowList = new ArrayList<>();\n        columnList = new ArrayList<>();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return  this.checkList(columnList);\n    }\n\n    @Override\n    public int getRowCount() {\n        return this.checkList(rowList);\n    }\n\n    private int checkList(ArrayList<Integer> l) {\n        return l.isEmpty() ? 0 : Collections.max(l) + 1;\n    }\n\n    @Override\n    public int getObjectCount() {\n        return matrix.size();\n    }\n\n    @Override\n    public int getDistinctObjectCount() {\n        ArrayList<Integer> uniq = rowList.stream()\n                .filter(num -> !columnList.contains(num))\n                .collect(Collectors.toCollection(ArrayList::new));\n\n        return uniq.isEmpty() ? 0 : uniq.size() + 1;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new DepthFirstIterator();\n    }\n\n    private class DepthFirstIterator implements Iterator<T>{\n        int rowIndex = 0;\n        int columnIndex = 0;\n\n\n        @Override\n        public boolean hasNext() { return columnIndex !=  Collections.max(columnList); }\n\n        @Override\n        public T next() {\n            for (;columnIndex <= Collections.max(columnList); columnIndex++){\n                for (;rowIndex <= Collections.max(rowList); rowIndex++){\n                    Point point = new Point(columnIndex, rowIndex);\n                    if(matrix.containsKey(point)){\n                        T value = matrix.get(point);\n                        System.out.println(columnIndex + \" \" + rowIndex + \" \" + value);\n                        rowIndex++;\n                        return value;\n                    }\n                }\n                rowIndex = 0;\n            }\n            throw new NoSuchElementException();\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    @Override\n    public T get(int row, int column) {\n        if( row > Collections.max(rowList) ||\n                column > Collections.max(columnList) ||\n                row < 0 || column < 0)\n            throw new IllegalArgumentException();\n\n        return matrix.getOrDefault(new Point(column,row), null);\n\n    }\n\n\n    @Override   // row = y , column = x\n    public T put(int row, int column, T value) {\n        if  (row < 0 || column < 0) throw new IllegalArgumentException();\n        columnList.add(column);\n        rowList.add(row);\n        return matrix.put(new Point(column,row),value);\n    }\n\n    @Override\n    public boolean contains(T value) { return matrix.containsValue(value); }\n}\n\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": "20",
    "end_column": "20",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "32",
    "end_line": "32",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": "22",
    "end_column": "22",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\n\nclass Event implements Comparable<Event> {\n\n\n  private String title;\n  private EventCategory category;\n\n  public Event(String title, EventCategory category) {\n    if (title == null) throw new NullPointerException(\"Empty argument\");\n    if (title == \"\") throw new IllegalArgumentException(\"Empty string\");\n    else this.title = title;\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    else this.category = category;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public EventCategory getCategory() {\n    return this.category;\n  }\n\n  @Override\n  public int compareTo(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == null) throw new NullPointerException(\"Empty Argument\");\n    if (this.title == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (e.getTitle() == null) throw new NullPointerException(\"Empty Argument\");\n    if (e.getTitle() == \"\") throw new IllegalArgumentException(\"Empty Argument\");\n    if (this.title == e.getTitle()) {\n      return this.category.ordinal() - e.getCategory().ordinal();\n    }\n    else {\n      return this.title.compareTo(e.getTitle());\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface EventCatalog {\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet);\n  public boolean addTimeToEvent(Event e, Time t);\n  public Set<Event> getAllEvents();\n  public Set<Time> getTimesOfEvent(Event e);\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category);\n  public Set<Time> deleteEvent(Event e);\n  public boolean deleteTime(Event e, Time t);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface EventCatalog {\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet);\n  public boolean addTimeToEvent(Event e, Time t);\n  public Set<Event> getAllEvents();\n  public Set<Time> getTimesOfEvent(Event e);\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category);\n  public Set<Time> deleteEvent(Event e);\n  public boolean deleteTime(Event e, Time t);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface EventCatalog {\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet);\n  public boolean addTimeToEvent(Event e, Time t);\n  public Set<Event> getAllEvents();\n  public Set<Time> getTimesOfEvent(Event e);\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category);\n  public Set<Time> deleteEvent(Event e);\n  public boolean deleteTime(Event e, Time t);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface EventCatalog {\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet);\n  public boolean addTimeToEvent(Event e, Time t);\n  public Set<Event> getAllEvents();\n  public Set<Time> getTimesOfEvent(Event e);\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category);\n  public Set<Time> deleteEvent(Event e);\n  public boolean deleteTime(Event e, Time t);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface EventCatalog {\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet);\n  public boolean addTimeToEvent(Event e, Time t);\n  public Set<Event> getAllEvents();\n  public Set<Time> getTimesOfEvent(Event e);\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category);\n  public Set<Time> deleteEvent(Event e);\n  public boolean deleteTime(Event e, Time t);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface EventCatalog {\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet);\n  public boolean addTimeToEvent(Event e, Time t);\n  public Set<Event> getAllEvents();\n  public Set<Time> getTimesOfEvent(Event e);\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category);\n  public Set<Time> deleteEvent(Event e);\n  public boolean deleteTime(Event e, Time t);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface EventCatalog {\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet);\n  public boolean addTimeToEvent(Event e, Time t);\n  public Set<Event> getAllEvents();\n  public Set<Time> getTimesOfEvent(Event e);\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category);\n  public Set<Time> deleteEvent(Event e);\n  public boolean deleteTime(Event e, Time t);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "39",
    "end_line": "39",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "44",
    "end_line": "44",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "47",
    "end_line": "47",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "54",
    "end_line": "54",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "59",
    "end_line": "59",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "60",
    "end_line": "60",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "64",
    "end_line": "64",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "66",
    "end_line": "66",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "69",
    "end_line": "69",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass EventCatalogImpl implements EventCatalog {\n\n  private Map<Event,Set<Time>> allEvents = new TreeMap<Event,Set<Time>>();\n\n  public boolean addCatalogEntry(Event e, Set<Time> tSet) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (tSet == null) throw new NullPointerException(\"Empty argument\");\n    for (Time time : tSet) {\n      if (time == null) throw new NullPointerException(\"Empty argument\");\n    }\n    Set<Time> value = this.allEvents.get(e);\n    if (value == null) {\n      this.allEvents.put(e,tSet);\n      return true;\n    }\n    else return false;\n  }\n\n  public boolean addTimeToEvent(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) return false;\n    if (times == null) return false;\n    times.add(t);\n    this.allEvents.put(e,times);\n    return true;\n  }\n\n  public Set<Event> getAllEvents() {\n    return this.allEvents.keySet();\n  }\n\n  public Set<Time> getTimesOfEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.get(e);\n  }\n\n  public Map<Event,Set<Time>> filterByEventCategory(EventCategory category) {\n    if (category == null) throw new NullPointerException(\"Empty argument\");\n    Map<Event,Set<Time>> output = new TreeMap<Event,Set<Time>>();\n    for (Map.Entry<Event,Set<Time>> entry : this.allEvents.entrySet()) {\n      if (entry.getKey().getCategory() == category)\n        output.put(entry.getKey(),entry.getValue());\n    }\n    return output;\n  }\n\n  public Set<Time> deleteEvent(Event e) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    return this.allEvents.remove(e);\n  }\n\n  public boolean deleteTime(Event e, Time t) {\n    if (e == null) throw new NullPointerException(\"Empty argument\");\n    if (t == null) throw new NullPointerException(\"Empty argument\");\n    Set<Time> times = this.allEvents.get(e);\n    if (times != null && times.contains(t)) {\n      times.remove(t);\n      if (times == null)\n        this.allEvents.remove(e);\n      else this.allEvents.put(e,times);\n      return true;\n    }\n    else\n      return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass Time {\n\n  private int hour;\n  private int minute;\n\n  public Time(int hour, int minute) {\n    // if (hour == null) throw new NullPointerException(\"Empty argument\");\n    if (hour < 24||hour >= 0) this.hour = hour;\n    else throw new IllegalArgumentException(\"Hour exceeds limits\");\n    // if (minute == null) throw new NullPointerException(\"Empty argument\");\n    if (minute < 60 && minute >= 0) this.minute = minute;\n    else throw new IllegalArgumentException(\"Minute exceeds limits\");\n  }\n\n  public int getHour() {\n    return hour;\n  }\n\n  public int getMinute() {\n    return minute;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass Time {\n\n  private int hour;\n  private int minute;\n\n  public Time(int hour, int minute) {\n    // if (hour == null) throw new NullPointerException(\"Empty argument\");\n    if (hour < 24||hour >= 0) this.hour = hour;\n    else throw new IllegalArgumentException(\"Hour exceeds limits\");\n    // if (minute == null) throw new NullPointerException(\"Empty argument\");\n    if (minute < 60 && minute >= 0) this.minute = minute;\n    else throw new IllegalArgumentException(\"Minute exceeds limits\");\n  }\n\n  public int getHour() {\n    return hour;\n  }\n\n  public int getMinute() {\n    return minute;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'24' is a magic number.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass Time {\n\n  private int hour;\n  private int minute;\n\n  public Time(int hour, int minute) {\n    // if (hour == null) throw new NullPointerException(\"Empty argument\");\n    if (hour < 24||hour >= 0) this.hour = hour;\n    else throw new IllegalArgumentException(\"Hour exceeds limits\");\n    // if (minute == null) throw new NullPointerException(\"Empty argument\");\n    if (minute < 60 && minute >= 0) this.minute = minute;\n    else throw new IllegalArgumentException(\"Minute exceeds limits\");\n  }\n\n  public int getHour() {\n    return hour;\n  }\n\n  public int getMinute() {\n    return minute;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass Time {\n\n  private int hour;\n  private int minute;\n\n  public Time(int hour, int minute) {\n    // if (hour == null) throw new NullPointerException(\"Empty argument\");\n    if (hour < 24||hour >= 0) this.hour = hour;\n    else throw new IllegalArgumentException(\"Hour exceeds limits\");\n    // if (minute == null) throw new NullPointerException(\"Empty argument\");\n    if (minute < 60 && minute >= 0) this.minute = minute;\n    else throw new IllegalArgumentException(\"Minute exceeds limits\");\n  }\n\n  public int getHour() {\n    return hour;\n  }\n\n  public int getMinute() {\n    return minute;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass Time {\n\n  private int hour;\n  private int minute;\n\n  public Time(int hour, int minute) {\n    // if (hour == null) throw new NullPointerException(\"Empty argument\");\n    if (hour < 24||hour >= 0) this.hour = hour;\n    else throw new IllegalArgumentException(\"Hour exceeds limits\");\n    // if (minute == null) throw new NullPointerException(\"Empty argument\");\n    if (minute < 60 && minute >= 0) this.minute = minute;\n    else throw new IllegalArgumentException(\"Minute exceeds limits\");\n  }\n\n  public int getHour() {\n    return hour;\n  }\n\n  public int getMinute() {\n    return minute;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'60' is a magic number.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": "18",
    "end_column": "18",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass Time {\n\n  private int hour;\n  private int minute;\n\n  public Time(int hour, int minute) {\n    // if (hour == null) throw new NullPointerException(\"Empty argument\");\n    if (hour < 24||hour >= 0) this.hour = hour;\n    else throw new IllegalArgumentException(\"Hour exceeds limits\");\n    // if (minute == null) throw new NullPointerException(\"Empty argument\");\n    if (minute < 60 && minute >= 0) this.minute = minute;\n    else throw new IllegalArgumentException(\"Minute exceeds limits\");\n  }\n\n  public int getHour() {\n    return hour;\n  }\n\n  public int getMinute() {\n    return minute;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Event App",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nclass Time {\n\n  private int hour;\n  private int minute;\n\n  public Time(int hour, int minute) {\n    // if (hour == null) throw new NullPointerException(\"Empty argument\");\n    if (hour < 24||hour >= 0) this.hour = hour;\n    else throw new IllegalArgumentException(\"Hour exceeds limits\");\n    // if (minute == null) throw new NullPointerException(\"Empty argument\");\n    if (minute < 60 && minute >= 0) this.minute = minute;\n    else throw new IllegalArgumentException(\"Minute exceeds limits\");\n  }\n\n  public int getHour() {\n    return hour;\n  }\n\n  public int getMinute() {\n    return minute;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Garage Gate",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass GarageDoor {\n\n  private DoorState currentState;\n  private Motor motor;\n\n  public GarageDoor() {\n    currentState = new Closed();\n  }\n\n  public void openDoor() {\n    currentState.openDoor();\n    currentState = new Opening();\n  }\n\n  public void stopper() {\n    currentState.stopper();\n    if (currentState instanceof Opening)\n      currentState = new Open();\n    else\n      currentState = new Closed();\n  }\n\n  public void closeDoor() {\n    currentState.closeDoor();\n    currentState = new Closing();\n  }\n\n  public Motor getMotor() {\n    return this.motor;\n  }\n\n  private void setState(DoorState ds) {\n    this.currentState = ds;\n  }\n\n  abstract class DoorState {\n\n    public void openDoor() {\n      throw new IllegalStateException();\n    }\n\n    public void closeDoor() {\n      throw new IllegalStateException();\n    }\n\n    public void stopper() {\n      throw new IllegalStateException();\n    }\n  }\n\n  class Closed extends DoorState {\n\n    @Override\n    public void openDoor() {\n      // motor.upwards();\n    }\n\n  }\n\n  class Opening extends DoorState {\n\n    @Override\n    public void closeDoor() {\n      // motor.downwards();\n    }\n\n    @Override\n    public void stopper() {\n      // motor.stop();\n    }\n\n  }\n\n  class Open extends DoorState {\n\n    @Override\n    public void closeDoor() {\n      // motor.downwards();\n    }\n\n  }\n\n  class Closing extends DoorState {\n\n    @Override\n    public void openDoor() {\n      // motor.upwards();\n    }\n\n    @Override\n    public void stopper() {\n      // motor.stop();\n    }\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Garage Gate",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass GarageDoor {\n\n  private DoorState currentState;\n  private Motor motor;\n\n  public GarageDoor() {\n    currentState = new Closed();\n  }\n\n  public void openDoor() {\n    currentState.openDoor();\n    currentState = new Opening();\n  }\n\n  public void stopper() {\n    currentState.stopper();\n    if (currentState instanceof Opening)\n      currentState = new Open();\n    else\n      currentState = new Closed();\n  }\n\n  public void closeDoor() {\n    currentState.closeDoor();\n    currentState = new Closing();\n  }\n\n  public Motor getMotor() {\n    return this.motor;\n  }\n\n  private void setState(DoorState ds) {\n    this.currentState = ds;\n  }\n\n  abstract class DoorState {\n\n    public void openDoor() {\n      throw new IllegalStateException();\n    }\n\n    public void closeDoor() {\n      throw new IllegalStateException();\n    }\n\n    public void stopper() {\n      throw new IllegalStateException();\n    }\n  }\n\n  class Closed extends DoorState {\n\n    @Override\n    public void openDoor() {\n      // motor.upwards();\n    }\n\n  }\n\n  class Opening extends DoorState {\n\n    @Override\n    public void closeDoor() {\n      // motor.downwards();\n    }\n\n    @Override\n    public void stopper() {\n      // motor.stop();\n    }\n\n  }\n\n  class Open extends DoorState {\n\n    @Override\n    public void closeDoor() {\n      // motor.downwards();\n    }\n\n  }\n\n  class Closing extends DoorState {\n\n    @Override\n    public void openDoor() {\n      // motor.upwards();\n    }\n\n    @Override\n    public void stopper() {\n      // motor.stop();\n    }\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Garage Gate",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass GarageDoor {\n\n  private DoorState currentState;\n  private Motor motor;\n\n  public GarageDoor() {\n    currentState = new Closed();\n  }\n\n  public void openDoor() {\n    currentState.openDoor();\n    currentState = new Opening();\n  }\n\n  public void stopper() {\n    currentState.stopper();\n    if (currentState instanceof Opening)\n      currentState = new Open();\n    else\n      currentState = new Closed();\n  }\n\n  public void closeDoor() {\n    currentState.closeDoor();\n    currentState = new Closing();\n  }\n\n  public Motor getMotor() {\n    return this.motor;\n  }\n\n  private void setState(DoorState ds) {\n    this.currentState = ds;\n  }\n\n  abstract class DoorState {\n\n    public void openDoor() {\n      throw new IllegalStateException();\n    }\n\n    public void closeDoor() {\n      throw new IllegalStateException();\n    }\n\n    public void stopper() {\n      throw new IllegalStateException();\n    }\n  }\n\n  class Closed extends DoorState {\n\n    @Override\n    public void openDoor() {\n      // motor.upwards();\n    }\n\n  }\n\n  class Opening extends DoorState {\n\n    @Override\n    public void closeDoor() {\n      // motor.downwards();\n    }\n\n    @Override\n    public void stopper() {\n      // motor.stop();\n    }\n\n  }\n\n  class Open extends DoorState {\n\n    @Override\n    public void closeDoor() {\n      // motor.downwards();\n    }\n\n  }\n\n  class Closing extends DoorState {\n\n    @Override\n    public void openDoor() {\n      // motor.upwards();\n    }\n\n    @Override\n    public void stopper() {\n      // motor.stop();\n    }\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Garage Gate",
    "message": "Name 'DoorState' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "39",
    "end_line": "39",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass GarageDoor {\n\n  private DoorState currentState;\n  private Motor motor;\n\n  public GarageDoor() {\n    currentState = new Closed();\n  }\n\n  public void openDoor() {\n    currentState.openDoor();\n    currentState = new Opening();\n  }\n\n  public void stopper() {\n    currentState.stopper();\n    if (currentState instanceof Opening)\n      currentState = new Open();\n    else\n      currentState = new Closed();\n  }\n\n  public void closeDoor() {\n    currentState.closeDoor();\n    currentState = new Closing();\n  }\n\n  public Motor getMotor() {\n    return this.motor;\n  }\n\n  private void setState(DoorState ds) {\n    this.currentState = ds;\n  }\n\n  abstract class DoorState {\n\n    public void openDoor() {\n      throw new IllegalStateException();\n    }\n\n    public void closeDoor() {\n      throw new IllegalStateException();\n    }\n\n    public void stopper() {\n      throw new IllegalStateException();\n    }\n  }\n\n  class Closed extends DoorState {\n\n    @Override\n    public void openDoor() {\n      // motor.upwards();\n    }\n\n  }\n\n  class Opening extends DoorState {\n\n    @Override\n    public void closeDoor() {\n      // motor.downwards();\n    }\n\n    @Override\n    public void stopper() {\n      // motor.stop();\n    }\n\n  }\n\n  class Open extends DoorState {\n\n    @Override\n    public void closeDoor() {\n      // motor.downwards();\n    }\n\n  }\n\n  class Closing extends DoorState {\n\n    @Override\n    public void openDoor() {\n      // motor.upwards();\n    }\n\n    @Override\n    public void stopper() {\n      // motor.stop();\n    }\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass Components extends Part {\n  public Components(String id, String name) {\n    super(id,name);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass Factory {\n\n  private ReceivingStock stock;\n  private Purchasing purchasing;\n\n  public Factory(Purchasing purchasing, ReceivingStock receivingStock) {\n    if (purchasing == null || receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n    this.purchasing = purchasing;\n  }\n\n  public Purchasing getPurchasing() {\n    return this.purchasing;\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public static Part create(PartType partType, String id, String name) {\n    if (partType == null || id == null || name == null)\n      throw new NullPointerException();\n    if (id == \"\" || name == \"\")\n      throw new IllegalArgumentException();\n    Part output;\n    switch(partType) {\n      case COMPONENTS: output = new Components(id,name);\n                                break;\n      case SINGLE_COMPONENT: output = new SingleComponent(id,name);\n                                      break;\n      case RESOURCE: output = new Resource(id,name);\n                              break;\n      default:  throw new IllegalArgumentException();\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass Factory {\n\n  private ReceivingStock stock;\n  private Purchasing purchasing;\n\n  public Factory(Purchasing purchasing, ReceivingStock receivingStock) {\n    if (purchasing == null || receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n    this.purchasing = purchasing;\n  }\n\n  public Purchasing getPurchasing() {\n    return this.purchasing;\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public static Part create(PartType partType, String id, String name) {\n    if (partType == null || id == null || name == null)\n      throw new NullPointerException();\n    if (id == \"\" || name == \"\")\n      throw new IllegalArgumentException();\n    Part output;\n    switch(partType) {\n      case COMPONENTS: output = new Components(id,name);\n                                break;\n      case SINGLE_COMPONENT: output = new SingleComponent(id,name);\n                                      break;\n      case RESOURCE: output = new Resource(id,name);\n                              break;\n      default:  throw new IllegalArgumentException();\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass Factory {\n\n  private ReceivingStock stock;\n  private Purchasing purchasing;\n\n  public Factory(Purchasing purchasing, ReceivingStock receivingStock) {\n    if (purchasing == null || receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n    this.purchasing = purchasing;\n  }\n\n  public Purchasing getPurchasing() {\n    return this.purchasing;\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public static Part create(PartType partType, String id, String name) {\n    if (partType == null || id == null || name == null)\n      throw new NullPointerException();\n    if (id == \"\" || name == \"\")\n      throw new IllegalArgumentException();\n    Part output;\n    switch(partType) {\n      case COMPONENTS: output = new Components(id,name);\n                                break;\n      case SINGLE_COMPONENT: output = new SingleComponent(id,name);\n                                      break;\n      case RESOURCE: output = new Resource(id,name);\n                              break;\n      default:  throw new IllegalArgumentException();\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass Factory {\n\n  private ReceivingStock stock;\n  private Purchasing purchasing;\n\n  public Factory(Purchasing purchasing, ReceivingStock receivingStock) {\n    if (purchasing == null || receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n    this.purchasing = purchasing;\n  }\n\n  public Purchasing getPurchasing() {\n    return this.purchasing;\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public static Part create(PartType partType, String id, String name) {\n    if (partType == null || id == null || name == null)\n      throw new NullPointerException();\n    if (id == \"\" || name == \"\")\n      throw new IllegalArgumentException();\n    Part output;\n    switch(partType) {\n      case COMPONENTS: output = new Components(id,name);\n                                break;\n      case SINGLE_COMPONENT: output = new SingleComponent(id,name);\n                                      break;\n      case RESOURCE: output = new Resource(id,name);\n                              break;\n      default:  throw new IllegalArgumentException();\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": "12",
    "end_column": "12",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass Factory {\n\n  private ReceivingStock stock;\n  private Purchasing purchasing;\n\n  public Factory(Purchasing purchasing, ReceivingStock receivingStock) {\n    if (purchasing == null || receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n    this.purchasing = purchasing;\n  }\n\n  public Purchasing getPurchasing() {\n    return this.purchasing;\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public static Part create(PartType partType, String id, String name) {\n    if (partType == null || id == null || name == null)\n      throw new NullPointerException();\n    if (id == \"\" || name == \"\")\n      throw new IllegalArgumentException();\n    Part output;\n    switch(partType) {\n      case COMPONENTS: output = new Components(id,name);\n                                break;\n      case SINGLE_COMPONENT: output = new SingleComponent(id,name);\n                                      break;\n      case RESOURCE: output = new Resource(id,name);\n                              break;\n      default:  throw new IllegalArgumentException();\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": "26",
    "end_column": "26",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass Factory {\n\n  private ReceivingStock stock;\n  private Purchasing purchasing;\n\n  public Factory(Purchasing purchasing, ReceivingStock receivingStock) {\n    if (purchasing == null || receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n    this.purchasing = purchasing;\n  }\n\n  public Purchasing getPurchasing() {\n    return this.purchasing;\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public static Part create(PartType partType, String id, String name) {\n    if (partType == null || id == null || name == null)\n      throw new NullPointerException();\n    if (id == \"\" || name == \"\")\n      throw new IllegalArgumentException();\n    Part output;\n    switch(partType) {\n      case COMPONENTS: output = new Components(id,name);\n                                break;\n      case SINGLE_COMPONENT: output = new SingleComponent(id,name);\n                                      break;\n      case RESOURCE: output = new Resource(id,name);\n                              break;\n      default:  throw new IllegalArgumentException();\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "interface Observation {\n\n  public void alarm(Part part);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Name 'Part' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nabstract class Part {\n\n  private String id;\n  private String name;\n\n  public Part(String id, String name) {\n    if (id == null || name == null ) throw new NullPointerException();\n    if (id == \"\" || name == \"\") throw new IllegalArgumentException();\n    this.id = id;\n    this.name = name;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nabstract class Part {\n\n  private String id;\n  private String name;\n\n  public Part(String id, String name) {\n    if (id == null || name == null ) throw new NullPointerException();\n    if (id == \"\" || name == \"\") throw new IllegalArgumentException();\n    this.id = id;\n    this.name = name;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nabstract class Part {\n\n  private String id;\n  private String name;\n\n  public Part(String id, String name) {\n    if (id == null || name == null ) throw new NullPointerException();\n    if (id == \"\" || name == \"\") throw new IllegalArgumentException();\n    this.id = id;\n    this.name = name;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nabstract class Part {\n\n  private String id;\n  private String name;\n\n  public Part(String id, String name) {\n    if (id == null || name == null ) throw new NullPointerException();\n    if (id == \"\" || name == \"\") throw new IllegalArgumentException();\n    this.id = id;\n    this.name = name;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "12",
    "end_column": "12",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\n\nabstract class Part {\n\n  private String id;\n  private String name;\n\n  public Part(String id, String name) {\n    if (id == null || name == null ) throw new NullPointerException();\n    if (id == \"\" || name == \"\") throw new IllegalArgumentException();\n    this.id = id;\n    this.name = name;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "26",
    "end_column": "26",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\n\nabstract class Part {\n\n  private String id;\n  private String name;\n\n  public Part(String id, String name) {\n    if (id == null || name == null ) throw new NullPointerException();\n    if (id == \"\" || name == \"\") throw new IllegalArgumentException();\n    this.id = id;\n    this.name = name;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Purchasing implements Observation {\n\n  private ReceivingStock stock;\n\n  public Purchasing(ReceivingStock receivingStock) {\n    if (receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n  }\n\n  public void buy(Part part, int count) {\n    if (part == null)\n      throw new NullPointerException();\n    if (count < 1)\n      throw new IllegalArgumentException();\n    stock.insert(part,count);\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public void alarm(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    stock.set(part,stock.getMaxStockItems());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Purchasing implements Observation {\n\n  private ReceivingStock stock;\n\n  public Purchasing(ReceivingStock receivingStock) {\n    if (receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n  }\n\n  public void buy(Part part, int count) {\n    if (part == null)\n      throw new NullPointerException();\n    if (count < 1)\n      throw new IllegalArgumentException();\n    stock.insert(part,count);\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public void alarm(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    stock.set(part,stock.getMaxStockItems());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Purchasing implements Observation {\n\n  private ReceivingStock stock;\n\n  public Purchasing(ReceivingStock receivingStock) {\n    if (receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n  }\n\n  public void buy(Part part, int count) {\n    if (part == null)\n      throw new NullPointerException();\n    if (count < 1)\n      throw new IllegalArgumentException();\n    stock.insert(part,count);\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public void alarm(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    stock.set(part,stock.getMaxStockItems());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Purchasing implements Observation {\n\n  private ReceivingStock stock;\n\n  public Purchasing(ReceivingStock receivingStock) {\n    if (receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n  }\n\n  public void buy(Part part, int count) {\n    if (part == null)\n      throw new NullPointerException();\n    if (count < 1)\n      throw new IllegalArgumentException();\n    stock.insert(part,count);\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public void alarm(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    stock.set(part,stock.getMaxStockItems());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Purchasing implements Observation {\n\n  private ReceivingStock stock;\n\n  public Purchasing(ReceivingStock receivingStock) {\n    if (receivingStock == null)\n      throw new NullPointerException();\n    this.stock = receivingStock;\n  }\n\n  public void buy(Part part, int count) {\n    if (part == null)\n      throw new NullPointerException();\n    if (count < 1)\n      throw new IllegalArgumentException();\n    stock.insert(part,count);\n  }\n\n  public ReceivingStock getStock() {\n    return this.stock;\n  }\n\n  public void alarm(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    stock.set(part,stock.getMaxStockItems());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass ReceivingStock extends Stock {\n\n  private int minStockItems;\n  private int maxStockItems;\n\n  public ReceivingStock (int minStockItems, int maxStockItems) {\n    if (minStockItems < 0 || maxStockItems < minStockItems)\n      throw new IllegalArgumentException();\n    this.minStockItems = minStockItems;\n    this.maxStockItems = maxStockItems;\n  }\n\n  public int getMinStockItems() {\n    return this.minStockItems;\n  }\n\n  public int getMaxStockItems() {\n    return this.maxStockItems;\n  }\n\n  @Override\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    boolean output = set(part,get(part)-count);\n    if (get(part) < getMinStockItems())\n      notify(part);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass ReceivingStock extends Stock {\n\n  private int minStockItems;\n  private int maxStockItems;\n\n  public ReceivingStock (int minStockItems, int maxStockItems) {\n    if (minStockItems < 0 || maxStockItems < minStockItems)\n      throw new IllegalArgumentException();\n    this.minStockItems = minStockItems;\n    this.maxStockItems = maxStockItems;\n  }\n\n  public int getMinStockItems() {\n    return this.minStockItems;\n  }\n\n  public int getMaxStockItems() {\n    return this.maxStockItems;\n  }\n\n  @Override\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    boolean output = set(part,get(part)-count);\n    if (get(part) < getMinStockItems())\n      notify(part);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass ReceivingStock extends Stock {\n\n  private int minStockItems;\n  private int maxStockItems;\n\n  public ReceivingStock (int minStockItems, int maxStockItems) {\n    if (minStockItems < 0 || maxStockItems < minStockItems)\n      throw new IllegalArgumentException();\n    this.minStockItems = minStockItems;\n    this.maxStockItems = maxStockItems;\n  }\n\n  public int getMinStockItems() {\n    return this.minStockItems;\n  }\n\n  public int getMaxStockItems() {\n    return this.maxStockItems;\n  }\n\n  @Override\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    boolean output = set(part,get(part)-count);\n    if (get(part) < getMinStockItems())\n      notify(part);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass ReceivingStock extends Stock {\n\n  private int minStockItems;\n  private int maxStockItems;\n\n  public ReceivingStock (int minStockItems, int maxStockItems) {\n    if (minStockItems < 0 || maxStockItems < minStockItems)\n      throw new IllegalArgumentException();\n    this.minStockItems = minStockItems;\n    this.maxStockItems = maxStockItems;\n  }\n\n  public int getMinStockItems() {\n    return this.minStockItems;\n  }\n\n  public int getMaxStockItems() {\n    return this.maxStockItems;\n  }\n\n  @Override\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    boolean output = set(part,get(part)-count);\n    if (get(part) < getMinStockItems())\n      notify(part);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass ReceivingStock extends Stock {\n\n  private int minStockItems;\n  private int maxStockItems;\n\n  public ReceivingStock (int minStockItems, int maxStockItems) {\n    if (minStockItems < 0 || maxStockItems < minStockItems)\n      throw new IllegalArgumentException();\n    this.minStockItems = minStockItems;\n    this.maxStockItems = maxStockItems;\n  }\n\n  public int getMinStockItems() {\n    return this.minStockItems;\n  }\n\n  public int getMaxStockItems() {\n    return this.maxStockItems;\n  }\n\n  @Override\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    boolean output = set(part,get(part)-count);\n    if (get(part) < getMinStockItems())\n      notify(part);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass Resource extends Part {\n  public Resource(String id, String name) {\n    super(id,name);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass SingleComponent extends Part {\n  public SingleComponent(String id, String name) {\n    super(id,name);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "Variable 'parts' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "38",
    "end_line": "38",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "44",
    "end_line": "44",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "50",
    "end_line": "50",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Part Management",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "52",
    "end_line": "52",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Stock {\n\n  protected Map<Part,Integer> parts = new HashMap<Part,Integer>();\n  private Set<Observation> observers = new HashSet<Observation>();\n\n  public int get(Part part) {\n    if (part == null) throw new NullPointerException();\n    if (parts.get(part) == null) return -1;\n    else return parts.get(part);\n  }\n\n  public boolean set(Part part, int count) {\n    if (part == null) throw new NullPointerException();\n    if (count < 0) return false;\n    if (parts.get(part) != null) {\n      parts.put(part,count);\n      return true;\n    }\n    else return false;\n  }\n\n  public void insert(Part part, int count) {\n    if (count < 1)\n      throw new IllegalArgumentException();\n    if (part == null)\n      throw new NullPointerException();\n    int currentParts = get(part);\n    if (currentParts == -1) currentParts++;\n    parts.put(part,count+currentParts);\n  }\n\n  public boolean delete(Part part, int count) {\n    if (count < 0)\n      return false;\n    if (part == null)\n      throw new NullPointerException();\n    return set(part,get(part)-count);\n  }\n\n  public void register(Observation observer) {\n    if (observer == null)\n      throw new NullPointerException();\n    observers.add(observer);\n  }\n\n  public void notify(Part part) {\n    if (part == null)\n      throw new NullPointerException();\n    for (Observation observer : observers)\n      observer.alarm(part);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Abbreviation in name 'JAttachment' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.File;\n\nclass JAttachment extends JContent {\n\n  private File file;\n\n  public JAttachment(String title, String description, File file) {\n    super(title,description);\n    if (file == null)\n      throw new NullPointerException();\n    this.file = file;\n  }\n\n  public File getFile() {\n    return this.file;\n  }\n\n  public void setFile(File file) {\n    if (file == null)\n      throw new NullPointerException();\n    this.file = file;\n  }\n\n  @Override\n  public String toString() {\n    return \"Attachment: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.File;\n\nclass JAttachment extends JContent {\n\n  private File file;\n\n  public JAttachment(String title, String description, File file) {\n    super(title,description);\n    if (file == null)\n      throw new NullPointerException();\n    this.file = file;\n  }\n\n  public File getFile() {\n    return this.file;\n  }\n\n  public void setFile(File file) {\n    if (file == null)\n      throw new NullPointerException();\n    this.file = file;\n  }\n\n  @Override\n  public String toString() {\n    return \"Attachment: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.File;\n\nclass JAttachment extends JContent {\n\n  private File file;\n\n  public JAttachment(String title, String description, File file) {\n    super(title,description);\n    if (file == null)\n      throw new NullPointerException();\n    this.file = file;\n  }\n\n  public File getFile() {\n    return this.file;\n  }\n\n  public void setFile(File file) {\n    if (file == null)\n      throw new NullPointerException();\n    this.file = file;\n  }\n\n  @Override\n  public String toString() {\n    return \"Attachment: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.File;\n\nclass JAttachment extends JContent {\n\n  private File file;\n\n  public JAttachment(String title, String description, File file) {\n    super(title,description);\n    if (file == null)\n      throw new NullPointerException();\n    this.file = file;\n  }\n\n  public File getFile() {\n    return this.file;\n  }\n\n  public void setFile(File file) {\n    if (file == null)\n      throw new NullPointerException();\n    this.file = file;\n  }\n\n  @Override\n  public String toString() {\n    return \"Attachment: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Abbreviation in name 'JContent' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Name 'JContent' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Variable 'title' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "20",
    "end_column": "20",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Variable 'description' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "20",
    "end_column": "20",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "36",
    "end_column": "36",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": "21",
    "end_column": "21",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "38",
    "end_line": "38",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\n\nabstract class JContent extends Observable {\n\n  protected String title;\n  protected String description;\n\n  public JContent(String title, String description) {\n    if (title == \"\" || description == \"\")\n      throw new IllegalArgumentException();\n    if (title == null || description == null)\n      throw new NullPointerException();\n    this.title = title;\n    this.description = description;\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n  }\n\n  public String toString() {\n    return this.title;\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Abbreviation in name 'JIdea' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "61",
    "end_line": "61",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "71",
    "end_line": "71",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Abbreviation in name 'JState' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "81",
    "end_line": "81",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Name 'JState' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "81",
    "end_line": "81",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'valuation' hides a field.",
    "priority": "error",
    "start_line": "94",
    "end_line": "94",
    "start_column": "37",
    "end_column": "37",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "111",
    "end_line": "111",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "113",
    "end_line": "113",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "118",
    "end_line": "118",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "118",
    "end_line": "118",
    "start_column": "29",
    "end_column": "29",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "120",
    "end_line": "120",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "130",
    "end_line": "130",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "155",
    "end_line": "155",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "155",
    "end_line": "155",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "157",
    "end_line": "157",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "159",
    "end_line": "159",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "159",
    "end_line": "159",
    "start_column": "34",
    "end_column": "34",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "161",
    "end_line": "161",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "167",
    "end_line": "167",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JIdea extends JContent {\n\n  private List<JAttachment> attachments = new ArrayList<JAttachment>();\n  private JState state;\n\n  public JIdea (String title, String description) {\n    super(title,description);\n    this.state = new Draft();\n  }\n\n  public JState getState() {\n    return this.state.getState();\n  }\n\n  public void discuss(String text) {\n    if (text == \"\")\n      throw new IllegalArgumentException();\n    if (text == null)\n      throw new NullPointerException();\n    this.state.discuss(text);\n  }\n\n  public void evaluate(JValuation valuation) {\n    if (valuation == null)\n      throw new NullPointerException();\n    this.state.evaluate(valuation);\n  }\n\n  public void hold() {\n    this.state.hold();\n  }\n\n  public void release() {\n    this.state.release();\n  }\n\n  public void decline() {\n    this.state.decline();\n  }\n\n  public boolean isDeclined() {\n    return this.state instanceof DeclinedIdea;\n  }\n\n  public boolean isReleased() {\n    return this.state instanceof ReleasedIdea;\n  }\n\n  public String getCurrentDiscussion() {\n    return this.state.getCurrentDiscussion();\n  }\n\n  public JValuation getValuation() {\n    return this.state.getValuation();\n  }\n\n  public void addAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    this.attachments.add(attachment);\n  }\n\n  public List<JAttachment> getAttachments() {\n    return this.attachments;\n  }\n\n  public boolean removeAttachment(JAttachment attachment) {\n    if (attachment == null)\n      throw new NullPointerException();\n    return this.attachments.remove(attachment);\n  }\n\n  @Override\n  public String toString() {\n    return \"Idea: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  abstract class JState {\n\n    private String currentDiscussion;\n    private JValuation valuation;\n\n    public JState getState() {\n      return state;\n    }\n\n    public void discuss(String text) {\n      throw new IllegalStateException();\n    }\n\n    public void evaluate(JValuation valuation) {\n      throw new IllegalStateException();\n    }\n\n    public void hold() {\n      throw new IllegalStateException();\n    }\n\n    public void release() {\n      throw new IllegalStateException();\n    }\n\n    public void decline() {\n      throw new IllegalStateException();\n    }\n\n    public String getCurrentDiscussion() {\n      if (this.currentDiscussion == null)\n        return \"\";\n      else\n        return this.currentDiscussion;\n    }\n\n    public void setCurrentDiscussion(String currentDiscussion) {\n      if (currentDiscussion == \"\")\n        throw new IllegalArgumentException();\n      if (currentDiscussion == null)\n        throw new NullPointerException();\n      this.currentDiscussion = currentDiscussion;\n    }\n\n    public JValuation getValuation() {\n      return this.valuation;\n    }\n\n    public void setValuation(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      this.valuation = valuation;\n    }\n\n  }\n\n  class Draft extends JState {\n\n    @Override\n    public void hold() {\n      state = new OpenDraft();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class OpenDraft extends JState {\n\n    @Override\n    public void discuss(String text) {\n      if (text == \"\")\n        throw new IllegalArgumentException();\n      if (text == null)\n        throw new NullPointerException();\n      if (getCurrentDiscussion() == \"\")\n        setCurrentDiscussion(text+\"\\n\");\n      else\n        setCurrentDiscussion(getCurrentDiscussion()+text+\"\\n\");\n    }\n\n    @Override\n    public void evaluate(JValuation valuation) {\n      if (valuation == null)\n        throw new NullPointerException();\n      setValuation(valuation);\n    }\n\n    @Override\n    public void hold() {\n      state = new ApprovedIdea();\n    }\n\n    @Override\n    public void decline() {\n      state = new DeclinedIdea();\n    }\n\n  }\n\n  class ApprovedIdea extends JState {\n\n    @Override\n    public void release() {\n      state = new ReleasedIdea();\n    }\n\n  }\n\n  class ReleasedIdea extends JState {}\n\n  class DeclinedIdea extends JState {}\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Abbreviation in name 'JIdeaPool' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "40",
    "end_line": "40",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "42",
    "end_line": "42",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Conditional logic can be removed.",
    "priority": "error",
    "start_line": "42",
    "end_line": "42",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "SimplifyBooleanReturn",
      "explanation": "Over complicated boolean return statements are hard to understand and should be simplified.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "44",
    "end_line": "44",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "49",
    "end_line": "49",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "64",
    "end_line": "64",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "64",
    "end_line": "64",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "66",
    "end_line": "66",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "70",
    "end_line": "70",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "84",
    "end_line": "84",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass JIdeaPool {\n\n  private Map<JTopic,Set<JIdea>> pool = new HashMap<JTopic,Set<JIdea>>();\n\n  public JIdeaPool() {}\n\n  public void add(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    Set<JIdea> emptySet = new HashSet<JIdea>();\n    if (!this.pool.keySet().contains(topic))\n      this.pool.put(topic,emptySet);\n  }\n\n  public void add(JIdea idea, JTopic topic) {\n    if (topic == null || idea == null)\n      throw new NullPointerException();\n    for (JTopic t : pool.keySet()){\n      for (JIdea i : pool.get(t)) {\n        if (i != idea && i.getTitle() == idea.getTitle())\n          return;\n      }\n    }\n    if (pool.containsKey(topic)) {\n      Set<JIdea> ideas = pool.get(topic);\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n    else {\n      Set<JIdea> ideas = new HashSet<JIdea>();\n      ideas.add(idea);\n      pool.put(topic,ideas);\n    }\n  }\n\n  public boolean remove(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.pool.remove(topic) == null)\n      return false;\n    else\n      return true;\n  }\n\n  public boolean remove(JIdea idea) {\n    if (idea == null)\n      throw new NullPointerException();\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      if (ideas.contains(idea)) {\n        ideas.remove(idea);\n        this.pool.put(topic,ideas);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  public JIdea getIdea(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic)) {\n        if (idea.getTitle() == title)\n          return idea;\n      }\n    }\n    return null;\n  }\n\n  public int numberOfTopics() {\n    return pool.keySet().size();\n  }\n\n  public int numberOfIdeas() {\n    Set<JIdea> ideas = new HashSet<JIdea>();\n    for (JTopic topic : pool.keySet()) {\n      for (JIdea idea : pool.get(topic))\n        ideas.add(idea);\n    }\n    return ideas.size();\n  }\n\n  public boolean removeReleased() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.ReleasedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n  public boolean removeDeclined() {\n    boolean removed = false;\n    for (JTopic topic : pool.keySet()) {\n      Set<JIdea> ideas = pool.get(topic);\n      Set<JIdea> i = new HashSet<JIdea>();\n      i.addAll(ideas);\n      for (JIdea idea : ideas) {\n        if (idea.getState() instanceof JIdea.DeclinedIdea) {\n          i.remove(idea);\n          removed = true;\n        }\n      }\n      pool.put(topic,i);\n    }\n    return removed;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Abbreviation in name 'JMember' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JMember implements Observer {\n\n  Set<JTopic> topics = new HashSet<JTopic>();\n\n  public void subscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    this.topics.add(topic);\n    topic.addObserver(this);\n  }\n\n  public Set<JTopic> getSubscribedTopics() {\n    return this.topics;\n  }\n\n  public void unsubscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.topics.contains(topic))\n      this.topics.remove(topic);\n    topic.deleteObserver(this);\n  }\n\n  public void update(Observable arg0, Object arg1) {\n    if (arg0 == null || arg1 == null)\n      throw new NullPointerException();\n    for (JTopic topic : topics) {\n      if (topic == arg0)\n        System.out.println(\"The topic \"+topic.getId()+\" has been updated!\");\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Variable 'topics' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JMember implements Observer {\n\n  Set<JTopic> topics = new HashSet<JTopic>();\n\n  public void subscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    this.topics.add(topic);\n    topic.addObserver(this);\n  }\n\n  public Set<JTopic> getSubscribedTopics() {\n    return this.topics;\n  }\n\n  public void unsubscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.topics.contains(topic))\n      this.topics.remove(topic);\n    topic.deleteObserver(this);\n  }\n\n  public void update(Observable arg0, Object arg1) {\n    if (arg0 == null || arg1 == null)\n      throw new NullPointerException();\n    for (JTopic topic : topics) {\n      if (topic == arg0)\n        System.out.println(\"The topic \"+topic.getId()+\" has been updated!\");\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JMember implements Observer {\n\n  Set<JTopic> topics = new HashSet<JTopic>();\n\n  public void subscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    this.topics.add(topic);\n    topic.addObserver(this);\n  }\n\n  public Set<JTopic> getSubscribedTopics() {\n    return this.topics;\n  }\n\n  public void unsubscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.topics.contains(topic))\n      this.topics.remove(topic);\n    topic.deleteObserver(this);\n  }\n\n  public void update(Observable arg0, Object arg1) {\n    if (arg0 == null || arg1 == null)\n      throw new NullPointerException();\n    for (JTopic topic : topics) {\n      if (topic == arg0)\n        System.out.println(\"The topic \"+topic.getId()+\" has been updated!\");\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JMember implements Observer {\n\n  Set<JTopic> topics = new HashSet<JTopic>();\n\n  public void subscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    this.topics.add(topic);\n    topic.addObserver(this);\n  }\n\n  public Set<JTopic> getSubscribedTopics() {\n    return this.topics;\n  }\n\n  public void unsubscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.topics.contains(topic))\n      this.topics.remove(topic);\n    topic.deleteObserver(this);\n  }\n\n  public void update(Observable arg0, Object arg1) {\n    if (arg0 == null || arg1 == null)\n      throw new NullPointerException();\n    for (JTopic topic : topics) {\n      if (topic == arg0)\n        System.out.println(\"The topic \"+topic.getId()+\" has been updated!\");\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JMember implements Observer {\n\n  Set<JTopic> topics = new HashSet<JTopic>();\n\n  public void subscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    this.topics.add(topic);\n    topic.addObserver(this);\n  }\n\n  public Set<JTopic> getSubscribedTopics() {\n    return this.topics;\n  }\n\n  public void unsubscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.topics.contains(topic))\n      this.topics.remove(topic);\n    topic.deleteObserver(this);\n  }\n\n  public void update(Observable arg0, Object arg1) {\n    if (arg0 == null || arg1 == null)\n      throw new NullPointerException();\n    for (JTopic topic : topics) {\n      if (topic == arg0)\n        System.out.println(\"The topic \"+topic.getId()+\" has been updated!\");\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JMember implements Observer {\n\n  Set<JTopic> topics = new HashSet<JTopic>();\n\n  public void subscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    this.topics.add(topic);\n    topic.addObserver(this);\n  }\n\n  public Set<JTopic> getSubscribedTopics() {\n    return this.topics;\n  }\n\n  public void unsubscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.topics.contains(topic))\n      this.topics.remove(topic);\n    topic.deleteObserver(this);\n  }\n\n  public void update(Observable arg0, Object arg1) {\n    if (arg0 == null || arg1 == null)\n      throw new NullPointerException();\n    for (JTopic topic : topics) {\n      if (topic == arg0)\n        System.out.println(\"The topic \"+topic.getId()+\" has been updated!\");\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JMember implements Observer {\n\n  Set<JTopic> topics = new HashSet<JTopic>();\n\n  public void subscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    this.topics.add(topic);\n    topic.addObserver(this);\n  }\n\n  public Set<JTopic> getSubscribedTopics() {\n    return this.topics;\n  }\n\n  public void unsubscribe(JTopic topic) {\n    if (topic == null)\n      throw new NullPointerException();\n    if (this.topics.contains(topic))\n      this.topics.remove(topic);\n    topic.deleteObserver(this);\n  }\n\n  public void update(Observable arg0, Object arg1) {\n    if (arg0 == null || arg1 == null)\n      throw new NullPointerException();\n    for (JTopic topic : topics) {\n      if (topic == arg0)\n        System.out.println(\"The topic \"+topic.getId()+\" has been updated!\");\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Abbreviation in name 'JTopic' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JTopic extends JContent {\n\n  private int id;\n\n  public JTopic(String title, String description, int id) {\n    super(title,description);\n    this.id = id;\n  }\n\n  public int getId() {\n    return this.id;\n  }\n\n  @Override\n  public String toString() {\n    return \"Topic: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  @Override\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n    setChanged();\n    notifyObservers(this);\n  }\n\n  @Override\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n    setChanged();\n    notifyObservers(this);\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JTopic extends JContent {\n\n  private int id;\n\n  public JTopic(String title, String description, int id) {\n    super(title,description);\n    this.id = id;\n  }\n\n  public int getId() {\n    return this.id;\n  }\n\n  @Override\n  public String toString() {\n    return \"Topic: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  @Override\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n    setChanged();\n    notifyObservers(this);\n  }\n\n  @Override\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n    setChanged();\n    notifyObservers(this);\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JTopic extends JContent {\n\n  private int id;\n\n  public JTopic(String title, String description, int id) {\n    super(title,description);\n    this.id = id;\n  }\n\n  public int getId() {\n    return this.id;\n  }\n\n  @Override\n  public String toString() {\n    return \"Topic: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  @Override\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n    setChanged();\n    notifyObservers(this);\n  }\n\n  @Override\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n    setChanged();\n    notifyObservers(this);\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": "21",
    "end_column": "21",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JTopic extends JContent {\n\n  private int id;\n\n  public JTopic(String title, String description, int id) {\n    super(title,description);\n    this.id = id;\n  }\n\n  public int getId() {\n    return this.id;\n  }\n\n  @Override\n  public String toString() {\n    return \"Topic: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  @Override\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n    setChanged();\n    notifyObservers(this);\n  }\n\n  @Override\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n    setChanged();\n    notifyObservers(this);\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JTopic extends JContent {\n\n  private int id;\n\n  public JTopic(String title, String description, int id) {\n    super(title,description);\n    this.id = id;\n  }\n\n  public int getId() {\n    return this.id;\n  }\n\n  @Override\n  public String toString() {\n    return \"Topic: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  @Override\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n    setChanged();\n    notifyObservers(this);\n  }\n\n  @Override\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n    setChanged();\n    notifyObservers(this);\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JTopic extends JContent {\n\n  private int id;\n\n  public JTopic(String title, String description, int id) {\n    super(title,description);\n    this.id = id;\n  }\n\n  public int getId() {\n    return this.id;\n  }\n\n  @Override\n  public String toString() {\n    return \"Topic: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  @Override\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n    setChanged();\n    notifyObservers(this);\n  }\n\n  @Override\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n    setChanged();\n    notifyObservers(this);\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JTopic extends JContent {\n\n  private int id;\n\n  public JTopic(String title, String description, int id) {\n    super(title,description);\n    this.id = id;\n  }\n\n  public int getId() {\n    return this.id;\n  }\n\n  @Override\n  public String toString() {\n    return \"Topic: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  @Override\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n    setChanged();\n    notifyObservers(this);\n  }\n\n  @Override\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n    setChanged();\n    notifyObservers(this);\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "37",
    "end_line": "37",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JTopic extends JContent {\n\n  private int id;\n\n  public JTopic(String title, String description, int id) {\n    super(title,description);\n    this.id = id;\n  }\n\n  public int getId() {\n    return this.id;\n  }\n\n  @Override\n  public String toString() {\n    return \"Topic: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n  @Override\n  public void setDescription(String description) {\n    if (description == \"\")\n      throw new IllegalArgumentException();\n    if (description == null)\n      throw new NullPointerException();\n    this.description = description;\n    setChanged();\n    notifyObservers(this);\n  }\n\n  @Override\n  public void setTitle(String title) {\n    if (title == \"\")\n      throw new IllegalArgumentException();\n    if (title == null)\n      throw new NullPointerException();\n    this.title = title;\n    setChanged();\n    notifyObservers(this);\n  }\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Abbreviation in name 'JValuation' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JValuation extends JContent {\n\n  public JValuation(String title, String description) {\n    super(title,description);\n  }\n\n  @Override\n  public String toString() {\n    return \"Valuation: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "COOLIDEAS",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass JValuation extends JContent {\n\n  public JValuation(String title, String description) {\n    super(title,description);\n  }\n\n  @Override\n  public String toString() {\n    return \"Valuation: \"+getTitle()+\"\\n\"+getDescription();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Adapter implements IProject {\n\n  private Project project;\n\n  public Adapter(String name, String description, double rate) {\n    project = new Project(name,description,rate);\n  }\n\n  public void setTask(Task newTask) {\n    project.setTask(newTask);\n  }\n\n  public double getDuration() {\n    return project.getDuration();\n  }\n\n  public long getTotalCost() {\n    return project.getTotalCost();\n  }\n\n  public List<Deliverable> getDeliverables() {\n    return project.getTask().allDeliverables();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Deliverable extends ProjectItem {\n\n  private long materialCost;\n  private double productionTime;\n  private Calendar date;\n\n  public Deliverable(String name, String details, double rate, long materialCost, double productionTime, Calendar date) {\n    super(name, details, rate);\n    if (date == null)\n      throw new NullPointerException();\n    if (materialCost < 0 || productionTime <= 0)\n      throw new IllegalArgumentException();\n    this.materialCost = materialCost;\n    this.productionTime = productionTime;\n    this.date = date;\n  }\n\n  public double getTimeRequired() {\n    return this.productionTime;\n  }\n\n  public long getMaterialCost() {\n    return this.materialCost;\n  }\n\n  public Calendar getDate() {\n    return this.date;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Deliverable extends ProjectItem {\n\n  private long materialCost;\n  private double productionTime;\n  private Calendar date;\n\n  public Deliverable(String name, String details, double rate, long materialCost, double productionTime, Calendar date) {\n    super(name, details, rate);\n    if (date == null)\n      throw new NullPointerException();\n    if (materialCost < 0 || productionTime <= 0)\n      throw new IllegalArgumentException();\n    this.materialCost = materialCost;\n    this.productionTime = productionTime;\n    this.date = date;\n  }\n\n  public double getTimeRequired() {\n    return this.productionTime;\n  }\n\n  public long getMaterialCost() {\n    return this.materialCost;\n  }\n\n  public Calendar getDate() {\n    return this.date;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Deliverable extends ProjectItem {\n\n  private long materialCost;\n  private double productionTime;\n  private Calendar date;\n\n  public Deliverable(String name, String details, double rate, long materialCost, double productionTime, Calendar date) {\n    super(name, details, rate);\n    if (date == null)\n      throw new NullPointerException();\n    if (materialCost < 0 || productionTime <= 0)\n      throw new IllegalArgumentException();\n    this.materialCost = materialCost;\n    this.productionTime = productionTime;\n    this.date = date;\n  }\n\n  public double getTimeRequired() {\n    return this.productionTime;\n  }\n\n  public long getMaterialCost() {\n    return this.materialCost;\n  }\n\n  public Calendar getDate() {\n    return this.date;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Abbreviation in name 'IProject' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\ninterface IProject {\n  public void setTask(Task newTask);\n  public double getDuration();\n  public long getTotalCost();\n  public List<Deliverable> getDeliverables();\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\ninterface IProject {\n  public void setTask(Task newTask);\n  public double getDuration();\n  public long getTotalCost();\n  public List<Deliverable> getDeliverables();\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\ninterface IProject {\n  public void setTask(Task newTask);\n  public double getDuration();\n  public long getTotalCost();\n  public List<Deliverable> getDeliverables();\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\ninterface IProject {\n  public void setTask(Task newTask);\n  public double getDuration();\n  public long getTotalCost();\n  public List<Deliverable> getDeliverables();\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\ninterface IProject {\n  public void setTask(Task newTask);\n  public double getDuration();\n  public long getTotalCost();\n  public List<Deliverable> getDeliverables();\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Project {\n\n  private String name;\n  private String description;\n  private Task mainTask;\n\n  public Project(String name, String description, double rate) {\n    if (name == \"\"||description == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||description == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.description = description;\n    this.mainTask = new Task(name, description, rate);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public Task getTask() {\n    return mainTask;\n  }\n\n  public String getDescription() {\n    return description;\n  }\n\n  public void setTask(Task newTask) {\n    if (newTask == null)\n      throw new NullPointerException();\n    mainTask = newTask;\n  }\n\n  public double getDuration() {\n    return mainTask.getTimeRequired();\n  }\n\n  public long getTotalCost() {\n    return mainTask.getCostEstimate();\n  }\n\n  public Map<Calendar, List<Deliverable>> allDeliverables() {\n    Map<Calendar, List<Deliverable>> output = new HashMap<Calendar, List<Deliverable>>();\n    List<Deliverable> deliverables = mainTask.allDeliverables();\n\n    for (Deliverable d : deliverables) {\n      if (output.get(d.getDate()) == null) {\n        List<Deliverable> addThis = new ArrayList<Deliverable>();\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n      else {\n        List<Deliverable> addThis = output.get(d.getDate());\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n    }\n\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Project {\n\n  private String name;\n  private String description;\n  private Task mainTask;\n\n  public Project(String name, String description, double rate) {\n    if (name == \"\"||description == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||description == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.description = description;\n    this.mainTask = new Task(name, description, rate);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public Task getTask() {\n    return mainTask;\n  }\n\n  public String getDescription() {\n    return description;\n  }\n\n  public void setTask(Task newTask) {\n    if (newTask == null)\n      throw new NullPointerException();\n    mainTask = newTask;\n  }\n\n  public double getDuration() {\n    return mainTask.getTimeRequired();\n  }\n\n  public long getTotalCost() {\n    return mainTask.getCostEstimate();\n  }\n\n  public Map<Calendar, List<Deliverable>> allDeliverables() {\n    Map<Calendar, List<Deliverable>> output = new HashMap<Calendar, List<Deliverable>>();\n    List<Deliverable> deliverables = mainTask.allDeliverables();\n\n    for (Deliverable d : deliverables) {\n      if (output.get(d.getDate()) == null) {\n        List<Deliverable> addThis = new ArrayList<Deliverable>();\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n      else {\n        List<Deliverable> addThis = output.get(d.getDate());\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n    }\n\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Project {\n\n  private String name;\n  private String description;\n  private Task mainTask;\n\n  public Project(String name, String description, double rate) {\n    if (name == \"\"||description == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||description == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.description = description;\n    this.mainTask = new Task(name, description, rate);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public Task getTask() {\n    return mainTask;\n  }\n\n  public String getDescription() {\n    return description;\n  }\n\n  public void setTask(Task newTask) {\n    if (newTask == null)\n      throw new NullPointerException();\n    mainTask = newTask;\n  }\n\n  public double getDuration() {\n    return mainTask.getTimeRequired();\n  }\n\n  public long getTotalCost() {\n    return mainTask.getCostEstimate();\n  }\n\n  public Map<Calendar, List<Deliverable>> allDeliverables() {\n    Map<Calendar, List<Deliverable>> output = new HashMap<Calendar, List<Deliverable>>();\n    List<Deliverable> deliverables = mainTask.allDeliverables();\n\n    for (Deliverable d : deliverables) {\n      if (output.get(d.getDate()) == null) {\n        List<Deliverable> addThis = new ArrayList<Deliverable>();\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n      else {\n        List<Deliverable> addThis = output.get(d.getDate());\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n    }\n\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Project {\n\n  private String name;\n  private String description;\n  private Task mainTask;\n\n  public Project(String name, String description, double rate) {\n    if (name == \"\"||description == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||description == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.description = description;\n    this.mainTask = new Task(name, description, rate);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public Task getTask() {\n    return mainTask;\n  }\n\n  public String getDescription() {\n    return description;\n  }\n\n  public void setTask(Task newTask) {\n    if (newTask == null)\n      throw new NullPointerException();\n    mainTask = newTask;\n  }\n\n  public double getDuration() {\n    return mainTask.getTimeRequired();\n  }\n\n  public long getTotalCost() {\n    return mainTask.getCostEstimate();\n  }\n\n  public Map<Calendar, List<Deliverable>> allDeliverables() {\n    Map<Calendar, List<Deliverable>> output = new HashMap<Calendar, List<Deliverable>>();\n    List<Deliverable> deliverables = mainTask.allDeliverables();\n\n    for (Deliverable d : deliverables) {\n      if (output.get(d.getDate()) == null) {\n        List<Deliverable> addThis = new ArrayList<Deliverable>();\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n      else {\n        List<Deliverable> addThis = output.get(d.getDate());\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n    }\n\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Project {\n\n  private String name;\n  private String description;\n  private Task mainTask;\n\n  public Project(String name, String description, double rate) {\n    if (name == \"\"||description == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||description == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.description = description;\n    this.mainTask = new Task(name, description, rate);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public Task getTask() {\n    return mainTask;\n  }\n\n  public String getDescription() {\n    return description;\n  }\n\n  public void setTask(Task newTask) {\n    if (newTask == null)\n      throw new NullPointerException();\n    mainTask = newTask;\n  }\n\n  public double getDuration() {\n    return mainTask.getTimeRequired();\n  }\n\n  public long getTotalCost() {\n    return mainTask.getCostEstimate();\n  }\n\n  public Map<Calendar, List<Deliverable>> allDeliverables() {\n    Map<Calendar, List<Deliverable>> output = new HashMap<Calendar, List<Deliverable>>();\n    List<Deliverable> deliverables = mainTask.allDeliverables();\n\n    for (Deliverable d : deliverables) {\n      if (output.get(d.getDate()) == null) {\n        List<Deliverable> addThis = new ArrayList<Deliverable>();\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n      else {\n        List<Deliverable> addThis = output.get(d.getDate());\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n    }\n\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Project {\n\n  private String name;\n  private String description;\n  private Task mainTask;\n\n  public Project(String name, String description, double rate) {\n    if (name == \"\"||description == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||description == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.description = description;\n    this.mainTask = new Task(name, description, rate);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public Task getTask() {\n    return mainTask;\n  }\n\n  public String getDescription() {\n    return description;\n  }\n\n  public void setTask(Task newTask) {\n    if (newTask == null)\n      throw new NullPointerException();\n    mainTask = newTask;\n  }\n\n  public double getDuration() {\n    return mainTask.getTimeRequired();\n  }\n\n  public long getTotalCost() {\n    return mainTask.getCostEstimate();\n  }\n\n  public Map<Calendar, List<Deliverable>> allDeliverables() {\n    Map<Calendar, List<Deliverable>> output = new HashMap<Calendar, List<Deliverable>>();\n    List<Deliverable> deliverables = mainTask.allDeliverables();\n\n    for (Deliverable d : deliverables) {\n      if (output.get(d.getDate()) == null) {\n        List<Deliverable> addThis = new ArrayList<Deliverable>();\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n      else {\n        List<Deliverable> addThis = output.get(d.getDate());\n        addThis.add(d);\n        output.put(d.getDate(), addThis);\n      }\n    }\n\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Name 'ProjectItem' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ProjectItem {\n\n  private String name;\n  private String details;\n  private double rate;\n\n  public ProjectItem(String name, String details, double rate) {\n    if (name == \"\"||details == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||details == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.details = details;\n    this.rate = rate;\n  }\n\n  public void setDetails(String newDetails) {\n    if (newDetails == \"\")\n      throw new IllegalArgumentException();\n    if (newDetails == null)\n      throw new NullPointerException();\n    details = newDetails;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public long getCostEstimate() {\n    return (long)Math.round((getTimeRequired() * rate)) + getMaterialCost();\n  }\n\n  public abstract double getTimeRequired();\n  public abstract long getMaterialCost();\n\n  @Override public String toString() {\n    return this.getName();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ProjectItem {\n\n  private String name;\n  private String details;\n  private double rate;\n\n  public ProjectItem(String name, String details, double rate) {\n    if (name == \"\"||details == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||details == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.details = details;\n    this.rate = rate;\n  }\n\n  public void setDetails(String newDetails) {\n    if (newDetails == \"\")\n      throw new IllegalArgumentException();\n    if (newDetails == null)\n      throw new NullPointerException();\n    details = newDetails;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public long getCostEstimate() {\n    return (long)Math.round((getTimeRequired() * rate)) + getMaterialCost();\n  }\n\n  public abstract double getTimeRequired();\n  public abstract long getMaterialCost();\n\n  @Override public String toString() {\n    return this.getName();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ProjectItem {\n\n  private String name;\n  private String details;\n  private double rate;\n\n  public ProjectItem(String name, String details, double rate) {\n    if (name == \"\"||details == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||details == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.details = details;\n    this.rate = rate;\n  }\n\n  public void setDetails(String newDetails) {\n    if (newDetails == \"\")\n      throw new IllegalArgumentException();\n    if (newDetails == null)\n      throw new NullPointerException();\n    details = newDetails;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public long getCostEstimate() {\n    return (long)Math.round((getTimeRequired() * rate)) + getMaterialCost();\n  }\n\n  public abstract double getTimeRequired();\n  public abstract long getMaterialCost();\n\n  @Override public String toString() {\n    return this.getName();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ProjectItem {\n\n  private String name;\n  private String details;\n  private double rate;\n\n  public ProjectItem(String name, String details, double rate) {\n    if (name == \"\"||details == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||details == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.details = details;\n    this.rate = rate;\n  }\n\n  public void setDetails(String newDetails) {\n    if (newDetails == \"\")\n      throw new IllegalArgumentException();\n    if (newDetails == null)\n      throw new NullPointerException();\n    details = newDetails;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public long getCostEstimate() {\n    return (long)Math.round((getTimeRequired() * rate)) + getMaterialCost();\n  }\n\n  public abstract double getTimeRequired();\n  public abstract long getMaterialCost();\n\n  @Override public String toString() {\n    return this.getName();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "29",
    "end_column": "29",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ProjectItem {\n\n  private String name;\n  private String details;\n  private double rate;\n\n  public ProjectItem(String name, String details, double rate) {\n    if (name == \"\"||details == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||details == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.details = details;\n    this.rate = rate;\n  }\n\n  public void setDetails(String newDetails) {\n    if (newDetails == \"\")\n      throw new IllegalArgumentException();\n    if (newDetails == null)\n      throw new NullPointerException();\n    details = newDetails;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public long getCostEstimate() {\n    return (long)Math.round((getTimeRequired() * rate)) + getMaterialCost();\n  }\n\n  public abstract double getTimeRequired();\n  public abstract long getMaterialCost();\n\n  @Override public String toString() {\n    return this.getName();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ProjectItem {\n\n  private String name;\n  private String details;\n  private double rate;\n\n  public ProjectItem(String name, String details, double rate) {\n    if (name == \"\"||details == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||details == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.details = details;\n    this.rate = rate;\n  }\n\n  public void setDetails(String newDetails) {\n    if (newDetails == \"\")\n      throw new IllegalArgumentException();\n    if (newDetails == null)\n      throw new NullPointerException();\n    details = newDetails;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public long getCostEstimate() {\n    return (long)Math.round((getTimeRequired() * rate)) + getMaterialCost();\n  }\n\n  public abstract double getTimeRequired();\n  public abstract long getMaterialCost();\n\n  @Override public String toString() {\n    return this.getName();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ProjectItem {\n\n  private String name;\n  private String details;\n  private double rate;\n\n  public ProjectItem(String name, String details, double rate) {\n    if (name == \"\"||details == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||details == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.details = details;\n    this.rate = rate;\n  }\n\n  public void setDetails(String newDetails) {\n    if (newDetails == \"\")\n      throw new IllegalArgumentException();\n    if (newDetails == null)\n      throw new NullPointerException();\n    details = newDetails;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public long getCostEstimate() {\n    return (long)Math.round((getTimeRequired() * rate)) + getMaterialCost();\n  }\n\n  public abstract double getTimeRequired();\n  public abstract long getMaterialCost();\n\n  @Override public String toString() {\n    return this.getName();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": "20",
    "end_column": "20",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ProjectItem {\n\n  private String name;\n  private String details;\n  private double rate;\n\n  public ProjectItem(String name, String details, double rate) {\n    if (name == \"\"||details == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||details == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.details = details;\n    this.rate = rate;\n  }\n\n  public void setDetails(String newDetails) {\n    if (newDetails == \"\")\n      throw new IllegalArgumentException();\n    if (newDetails == null)\n      throw new NullPointerException();\n    details = newDetails;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public long getCostEstimate() {\n    return (long)Math.round((getTimeRequired() * rate)) + getMaterialCost();\n  }\n\n  public abstract double getTimeRequired();\n  public abstract long getMaterialCost();\n\n  @Override public String toString() {\n    return this.getName();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ProjectItem {\n\n  private String name;\n  private String details;\n  private double rate;\n\n  public ProjectItem(String name, String details, double rate) {\n    if (name == \"\"||details == \"\"||rate < 0)\n      throw new IllegalArgumentException();\n    if (name == null||details == null)\n      throw new NullPointerException();\n    this.name = name;\n    this.details = details;\n    this.rate = rate;\n  }\n\n  public void setDetails(String newDetails) {\n    if (newDetails == \"\")\n      throw new IllegalArgumentException();\n    if (newDetails == null)\n      throw new NullPointerException();\n    details = newDetails;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public long getCostEstimate() {\n    return (long)Math.round((getTimeRequired() * rate)) + getMaterialCost();\n  }\n\n  public abstract double getTimeRequired();\n  public abstract long getMaterialCost();\n\n  @Override public String toString() {\n    return this.getName();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Task extends ProjectItem {\n\n  private Set<ProjectItem> projectItems = new HashSet<ProjectItem>();\n\n  public Task(String name, String details, double rate) {\n    super(name, details, rate);\n  }\n\n  public double getTimeRequired() {\n    double time = 0;\n    for (ProjectItem pi : projectItems)\n      time += pi.getTimeRequired();\n    return time;\n  }\n\n  public long getMaterialCost() {\n    long cost = 0;\n    for (ProjectItem pi : projectItems)\n      cost += pi.getMaterialCost();\n    return cost;\n  }\n\n  public void addProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.add(pi);\n  }\n\n  public void removeProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.remove(pi);\n  }\n\n  public List<Deliverable> allDeliverables() {\n    List<Deliverable> output = new ArrayList<Deliverable>();\n    for (ProjectItem pi : projectItems) {\n      if (pi instanceof Deliverable) {\n        output.add((Deliverable) pi);\n        System.out.println(\"Deliverable: \"+pi);\n      }\n      else {\n        for (Deliverable internal_pi : ((Task)pi).allDeliverables()) {\n          output.add(internal_pi);\n        }\n      }\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Task extends ProjectItem {\n\n  private Set<ProjectItem> projectItems = new HashSet<ProjectItem>();\n\n  public Task(String name, String details, double rate) {\n    super(name, details, rate);\n  }\n\n  public double getTimeRequired() {\n    double time = 0;\n    for (ProjectItem pi : projectItems)\n      time += pi.getTimeRequired();\n    return time;\n  }\n\n  public long getMaterialCost() {\n    long cost = 0;\n    for (ProjectItem pi : projectItems)\n      cost += pi.getMaterialCost();\n    return cost;\n  }\n\n  public void addProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.add(pi);\n  }\n\n  public void removeProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.remove(pi);\n  }\n\n  public List<Deliverable> allDeliverables() {\n    List<Deliverable> output = new ArrayList<Deliverable>();\n    for (ProjectItem pi : projectItems) {\n      if (pi instanceof Deliverable) {\n        output.add((Deliverable) pi);\n        System.out.println(\"Deliverable: \"+pi);\n      }\n      else {\n        for (Deliverable internal_pi : ((Task)pi).allDeliverables()) {\n          output.add(internal_pi);\n        }\n      }\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Task extends ProjectItem {\n\n  private Set<ProjectItem> projectItems = new HashSet<ProjectItem>();\n\n  public Task(String name, String details, double rate) {\n    super(name, details, rate);\n  }\n\n  public double getTimeRequired() {\n    double time = 0;\n    for (ProjectItem pi : projectItems)\n      time += pi.getTimeRequired();\n    return time;\n  }\n\n  public long getMaterialCost() {\n    long cost = 0;\n    for (ProjectItem pi : projectItems)\n      cost += pi.getMaterialCost();\n    return cost;\n  }\n\n  public void addProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.add(pi);\n  }\n\n  public void removeProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.remove(pi);\n  }\n\n  public List<Deliverable> allDeliverables() {\n    List<Deliverable> output = new ArrayList<Deliverable>();\n    for (ProjectItem pi : projectItems) {\n      if (pi instanceof Deliverable) {\n        output.add((Deliverable) pi);\n        System.out.println(\"Deliverable: \"+pi);\n      }\n      else {\n        for (Deliverable internal_pi : ((Task)pi).allDeliverables()) {\n          output.add(internal_pi);\n        }\n      }\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Task extends ProjectItem {\n\n  private Set<ProjectItem> projectItems = new HashSet<ProjectItem>();\n\n  public Task(String name, String details, double rate) {\n    super(name, details, rate);\n  }\n\n  public double getTimeRequired() {\n    double time = 0;\n    for (ProjectItem pi : projectItems)\n      time += pi.getTimeRequired();\n    return time;\n  }\n\n  public long getMaterialCost() {\n    long cost = 0;\n    for (ProjectItem pi : projectItems)\n      cost += pi.getMaterialCost();\n    return cost;\n  }\n\n  public void addProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.add(pi);\n  }\n\n  public void removeProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.remove(pi);\n  }\n\n  public List<Deliverable> allDeliverables() {\n    List<Deliverable> output = new ArrayList<Deliverable>();\n    for (ProjectItem pi : projectItems) {\n      if (pi instanceof Deliverable) {\n        output.add((Deliverable) pi);\n        System.out.println(\"Deliverable: \"+pi);\n      }\n      else {\n        for (Deliverable internal_pi : ((Task)pi).allDeliverables()) {\n          output.add(internal_pi);\n        }\n      }\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Task extends ProjectItem {\n\n  private Set<ProjectItem> projectItems = new HashSet<ProjectItem>();\n\n  public Task(String name, String details, double rate) {\n    super(name, details, rate);\n  }\n\n  public double getTimeRequired() {\n    double time = 0;\n    for (ProjectItem pi : projectItems)\n      time += pi.getTimeRequired();\n    return time;\n  }\n\n  public long getMaterialCost() {\n    long cost = 0;\n    for (ProjectItem pi : projectItems)\n      cost += pi.getMaterialCost();\n    return cost;\n  }\n\n  public void addProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.add(pi);\n  }\n\n  public void removeProjectItem(ProjectItem pi) {\n    if (pi == null)\n      throw new NullPointerException();\n    projectItems.remove(pi);\n  }\n\n  public List<Deliverable> allDeliverables() {\n    List<Deliverable> output = new ArrayList<Deliverable>();\n    for (ProjectItem pi : projectItems) {\n      if (pi instanceof Deliverable) {\n        output.add((Deliverable) pi);\n        System.out.println(\"Deliverable: \"+pi);\n      }\n      else {\n        for (Deliverable internal_pi : ((Task)pi).allDeliverables()) {\n          output.add(internal_pi);\n        }\n      }\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Name 'CardDrawing' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\npublic abstract class CardDrawing {\n\n  Random randGen = new Random();\n\n  public abstract int getNextVocabCardId(int sizeVocab);\n\n  public int random(int max) {\n    if (max < 1) throw new IllegalArgumentException();\n    return randGen.nextInt(max);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Variable 'randGen' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "10",
    "end_column": "10",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\npublic abstract class CardDrawing {\n\n  Random randGen = new Random();\n\n  public abstract int getNextVocabCardId(int sizeVocab);\n\n  public int random(int max) {\n    if (max < 1) throw new IllegalArgumentException();\n    return randGen.nextInt(max);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\npublic abstract class CardDrawing {\n\n  Random randGen = new Random();\n\n  public abstract int getNextVocabCardId(int sizeVocab);\n\n  public int random(int max) {\n    if (max < 1) throw new IllegalArgumentException();\n    return randGen.nextInt(max);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Variable 'usedInts' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\n\npublic class CompletelyRandom extends CardDrawing {\n\n  Set<Integer> usedInts = new HashSet<Integer>();\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    Integer random = random(sizeVocab)+1;\n    if (sizeVocab == usedInts.size())\n      usedInts = new HashSet<Integer>();\n    while (usedInts.contains(random))\n        random = random(sizeVocab)+1;\n    return random;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\n\npublic class CompletelyRandom extends CardDrawing {\n\n  Set<Integer> usedInts = new HashSet<Integer>();\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    Integer random = random(sizeVocab)+1;\n    if (sizeVocab == usedInts.size())\n      usedInts = new HashSet<Integer>();\n    while (usedInts.contains(random))\n        random = random(sizeVocab)+1;\n    return random;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\n\npublic class CompletelyRandom extends CardDrawing {\n\n  Set<Integer> usedInts = new HashSet<Integer>();\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    Integer random = random(sizeVocab)+1;\n    if (sizeVocab == usedInts.size())\n      usedInts = new HashSet<Integer>();\n    while (usedInts.contains(random))\n        random = random(sizeVocab)+1;\n    return random;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'while' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\n\npublic class CompletelyRandom extends CardDrawing {\n\n  Set<Integer> usedInts = new HashSet<Integer>();\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    Integer random = random(sizeVocab)+1;\n    if (sizeVocab == usedInts.size())\n      usedInts = new HashSet<Integer>();\n    while (usedInts.contains(random))\n        random = random(sizeVocab)+1;\n    return random;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Variable 'sizeVocab' explicitly initialized to '0' (default value for its type).",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class CycleRandom extends CardDrawing {\n\n  private List<Integer> cycleList = new ArrayList<Integer>();\n  private int sizeVocab = 0;\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    return removeRandomFromCycleList();\n  }\n\n  private void initializeCycleList(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    for (int i = 1; i <= sizeVocab; i++)\n      cycleList.add(i);\n  }\n\n  private int removeRandomFromCycleList() {\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    int randint = random(cycleList.size());\n    int item = cycleList.remove(randint);\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    return item;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'sizeVocab' hides a field.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "37",
    "end_column": "37",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class CycleRandom extends CardDrawing {\n\n  private List<Integer> cycleList = new ArrayList<Integer>();\n  private int sizeVocab = 0;\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    return removeRandomFromCycleList();\n  }\n\n  private void initializeCycleList(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    for (int i = 1; i <= sizeVocab; i++)\n      cycleList.add(i);\n  }\n\n  private int removeRandomFromCycleList() {\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    int randint = random(cycleList.size());\n    int item = cycleList.remove(randint);\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    return item;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class CycleRandom extends CardDrawing {\n\n  private List<Integer> cycleList = new ArrayList<Integer>();\n  private int sizeVocab = 0;\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    return removeRandomFromCycleList();\n  }\n\n  private void initializeCycleList(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    for (int i = 1; i <= sizeVocab; i++)\n      cycleList.add(i);\n  }\n\n  private int removeRandomFromCycleList() {\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    int randint = random(cycleList.size());\n    int item = cycleList.remove(randint);\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    return item;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'sizeVocab' hides a field.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": "40",
    "end_column": "40",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class CycleRandom extends CardDrawing {\n\n  private List<Integer> cycleList = new ArrayList<Integer>();\n  private int sizeVocab = 0;\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    return removeRandomFromCycleList();\n  }\n\n  private void initializeCycleList(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    for (int i = 1; i <= sizeVocab; i++)\n      cycleList.add(i);\n  }\n\n  private int removeRandomFromCycleList() {\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    int randint = random(cycleList.size());\n    int item = cycleList.remove(randint);\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    return item;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class CycleRandom extends CardDrawing {\n\n  private List<Integer> cycleList = new ArrayList<Integer>();\n  private int sizeVocab = 0;\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    return removeRandomFromCycleList();\n  }\n\n  private void initializeCycleList(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    for (int i = 1; i <= sizeVocab; i++)\n      cycleList.add(i);\n  }\n\n  private int removeRandomFromCycleList() {\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    int randint = random(cycleList.size());\n    int item = cycleList.remove(randint);\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    return item;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class CycleRandom extends CardDrawing {\n\n  private List<Integer> cycleList = new ArrayList<Integer>();\n  private int sizeVocab = 0;\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    return removeRandomFromCycleList();\n  }\n\n  private void initializeCycleList(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    for (int i = 1; i <= sizeVocab; i++)\n      cycleList.add(i);\n  }\n\n  private int removeRandomFromCycleList() {\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    int randint = random(cycleList.size());\n    int item = cycleList.remove(randint);\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    return item;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class CycleRandom extends CardDrawing {\n\n  private List<Integer> cycleList = new ArrayList<Integer>();\n  private int sizeVocab = 0;\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    return removeRandomFromCycleList();\n  }\n\n  private void initializeCycleList(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    for (int i = 1; i <= sizeVocab; i++)\n      cycleList.add(i);\n  }\n\n  private int removeRandomFromCycleList() {\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    int randint = random(cycleList.size());\n    int item = cycleList.remove(randint);\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    return item;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class CycleRandom extends CardDrawing {\n\n  private List<Integer> cycleList = new ArrayList<Integer>();\n  private int sizeVocab = 0;\n\n  public int getNextVocabCardId(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    return removeRandomFromCycleList();\n  }\n\n  private void initializeCycleList(int sizeVocab) {\n    if (sizeVocab < 1)\n      throw new IllegalArgumentException();\n    this.sizeVocab = sizeVocab;\n    for (int i = 1; i <= sizeVocab; i++)\n      cycleList.add(i);\n  }\n\n  private int removeRandomFromCycleList() {\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    int randint = random(cycleList.size());\n    int item = cycleList.remove(randint);\n    if (cycleList.size() == 0) initializeCycleList(sizeVocab);\n    return item;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class QuizData {\n\n  private Map<Integer, VocabCard> vocabMap = new HashMap<Integer, VocabCard>();\n  private int current;\n  private CardDrawing cardDrawing;\n\n  public QuizData(Map<Integer, VocabCard> vocabMap, boolean useCycleRandom) {\n    if (vocabMap.keySet().size() == 0) throw new IllegalArgumentException();\n    for (Integer testNull : vocabMap.keySet()) {\n      if (testNull == null) throw new IllegalArgumentException();\n      if (testNull == 7) throw new IllegalArgumentException();\n      if (testNull < 1) throw new IllegalArgumentException();\n      if (vocabMap.get(testNull)==null) throw new IllegalArgumentException();\n    }\n    this.vocabMap = vocabMap;\n    if (useCycleRandom)\n      cardDrawing = new CycleRandom();\n    else\n      cardDrawing = new CompletelyRandom();\n  }\n\n  public int sizeVocab() {\n    return vocabMap.keySet().size();\n  }\n\n  public void drawNext() {\n    current = cardDrawing.getNextVocabCardId(sizeVocab());\n  }\n\n  public VocabCard getCurrentVocabCard() {\n    return vocabMap.get(current);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class QuizData {\n\n  private Map<Integer, VocabCard> vocabMap = new HashMap<Integer, VocabCard>();\n  private int current;\n  private CardDrawing cardDrawing;\n\n  public QuizData(Map<Integer, VocabCard> vocabMap, boolean useCycleRandom) {\n    if (vocabMap.keySet().size() == 0) throw new IllegalArgumentException();\n    for (Integer testNull : vocabMap.keySet()) {\n      if (testNull == null) throw new IllegalArgumentException();\n      if (testNull == 7) throw new IllegalArgumentException();\n      if (testNull < 1) throw new IllegalArgumentException();\n      if (vocabMap.get(testNull)==null) throw new IllegalArgumentException();\n    }\n    this.vocabMap = vocabMap;\n    if (useCycleRandom)\n      cardDrawing = new CycleRandom();\n    else\n      cardDrawing = new CompletelyRandom();\n  }\n\n  public int sizeVocab() {\n    return vocabMap.keySet().size();\n  }\n\n  public void drawNext() {\n    current = cardDrawing.getNextVocabCardId(sizeVocab());\n  }\n\n  public VocabCard getCurrentVocabCard() {\n    return vocabMap.get(current);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class QuizData {\n\n  private Map<Integer, VocabCard> vocabMap = new HashMap<Integer, VocabCard>();\n  private int current;\n  private CardDrawing cardDrawing;\n\n  public QuizData(Map<Integer, VocabCard> vocabMap, boolean useCycleRandom) {\n    if (vocabMap.keySet().size() == 0) throw new IllegalArgumentException();\n    for (Integer testNull : vocabMap.keySet()) {\n      if (testNull == null) throw new IllegalArgumentException();\n      if (testNull == 7) throw new IllegalArgumentException();\n      if (testNull < 1) throw new IllegalArgumentException();\n      if (vocabMap.get(testNull)==null) throw new IllegalArgumentException();\n    }\n    this.vocabMap = vocabMap;\n    if (useCycleRandom)\n      cardDrawing = new CycleRandom();\n    else\n      cardDrawing = new CompletelyRandom();\n  }\n\n  public int sizeVocab() {\n    return vocabMap.keySet().size();\n  }\n\n  public void drawNext() {\n    current = cardDrawing.getNextVocabCardId(sizeVocab());\n  }\n\n  public VocabCard getCurrentVocabCard() {\n    return vocabMap.get(current);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'7' is a magic number.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": "23",
    "end_column": "23",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class QuizData {\n\n  private Map<Integer, VocabCard> vocabMap = new HashMap<Integer, VocabCard>();\n  private int current;\n  private CardDrawing cardDrawing;\n\n  public QuizData(Map<Integer, VocabCard> vocabMap, boolean useCycleRandom) {\n    if (vocabMap.keySet().size() == 0) throw new IllegalArgumentException();\n    for (Integer testNull : vocabMap.keySet()) {\n      if (testNull == null) throw new IllegalArgumentException();\n      if (testNull == 7) throw new IllegalArgumentException();\n      if (testNull < 1) throw new IllegalArgumentException();\n      if (vocabMap.get(testNull)==null) throw new IllegalArgumentException();\n    }\n    this.vocabMap = vocabMap;\n    if (useCycleRandom)\n      cardDrawing = new CycleRandom();\n    else\n      cardDrawing = new CompletelyRandom();\n  }\n\n  public int sizeVocab() {\n    return vocabMap.keySet().size();\n  }\n\n  public void drawNext() {\n    current = cardDrawing.getNextVocabCardId(sizeVocab());\n  }\n\n  public VocabCard getCurrentVocabCard() {\n    return vocabMap.get(current);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class QuizData {\n\n  private Map<Integer, VocabCard> vocabMap = new HashMap<Integer, VocabCard>();\n  private int current;\n  private CardDrawing cardDrawing;\n\n  public QuizData(Map<Integer, VocabCard> vocabMap, boolean useCycleRandom) {\n    if (vocabMap.keySet().size() == 0) throw new IllegalArgumentException();\n    for (Integer testNull : vocabMap.keySet()) {\n      if (testNull == null) throw new IllegalArgumentException();\n      if (testNull == 7) throw new IllegalArgumentException();\n      if (testNull < 1) throw new IllegalArgumentException();\n      if (vocabMap.get(testNull)==null) throw new IllegalArgumentException();\n    }\n    this.vocabMap = vocabMap;\n    if (useCycleRandom)\n      cardDrawing = new CycleRandom();\n    else\n      cardDrawing = new CompletelyRandom();\n  }\n\n  public int sizeVocab() {\n    return vocabMap.keySet().size();\n  }\n\n  public void drawNext() {\n    current = cardDrawing.getNextVocabCardId(sizeVocab());\n  }\n\n  public VocabCard getCurrentVocabCard() {\n    return vocabMap.get(current);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class QuizData {\n\n  private Map<Integer, VocabCard> vocabMap = new HashMap<Integer, VocabCard>();\n  private int current;\n  private CardDrawing cardDrawing;\n\n  public QuizData(Map<Integer, VocabCard> vocabMap, boolean useCycleRandom) {\n    if (vocabMap.keySet().size() == 0) throw new IllegalArgumentException();\n    for (Integer testNull : vocabMap.keySet()) {\n      if (testNull == null) throw new IllegalArgumentException();\n      if (testNull == 7) throw new IllegalArgumentException();\n      if (testNull < 1) throw new IllegalArgumentException();\n      if (vocabMap.get(testNull)==null) throw new IllegalArgumentException();\n    }\n    this.vocabMap = vocabMap;\n    if (useCycleRandom)\n      cardDrawing = new CycleRandom();\n    else\n      cardDrawing = new CompletelyRandom();\n  }\n\n  public int sizeVocab() {\n    return vocabMap.keySet().size();\n  }\n\n  public void drawNext() {\n    current = cardDrawing.getNextVocabCardId(sizeVocab());\n  }\n\n  public VocabCard getCurrentVocabCard() {\n    return vocabMap.get(current);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class QuizData {\n\n  private Map<Integer, VocabCard> vocabMap = new HashMap<Integer, VocabCard>();\n  private int current;\n  private CardDrawing cardDrawing;\n\n  public QuizData(Map<Integer, VocabCard> vocabMap, boolean useCycleRandom) {\n    if (vocabMap.keySet().size() == 0) throw new IllegalArgumentException();\n    for (Integer testNull : vocabMap.keySet()) {\n      if (testNull == null) throw new IllegalArgumentException();\n      if (testNull == 7) throw new IllegalArgumentException();\n      if (testNull < 1) throw new IllegalArgumentException();\n      if (vocabMap.get(testNull)==null) throw new IllegalArgumentException();\n    }\n    this.vocabMap = vocabMap;\n    if (useCycleRandom)\n      cardDrawing = new CycleRandom();\n    else\n      cardDrawing = new CompletelyRandom();\n  }\n\n  public int sizeVocab() {\n    return vocabMap.keySet().size();\n  }\n\n  public void drawNext() {\n    current = cardDrawing.getNextVocabCardId(sizeVocab());\n  }\n\n  public VocabCard getCurrentVocabCard() {\n    return vocabMap.get(current);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\npublic class QuizData {\n\n  private Map<Integer, VocabCard> vocabMap = new HashMap<Integer, VocabCard>();\n  private int current;\n  private CardDrawing cardDrawing;\n\n  public QuizData(Map<Integer, VocabCard> vocabMap, boolean useCycleRandom) {\n    if (vocabMap.keySet().size() == 0) throw new IllegalArgumentException();\n    for (Integer testNull : vocabMap.keySet()) {\n      if (testNull == null) throw new IllegalArgumentException();\n      if (testNull == 7) throw new IllegalArgumentException();\n      if (testNull < 1) throw new IllegalArgumentException();\n      if (vocabMap.get(testNull)==null) throw new IllegalArgumentException();\n    }\n    this.vocabMap = vocabMap;\n    if (useCycleRandom)\n      cardDrawing = new CycleRandom();\n    else\n      cardDrawing = new CompletelyRandom();\n  }\n\n  public int sizeVocab() {\n    return vocabMap.keySet().size();\n  }\n\n  public void drawNext() {\n    current = cardDrawing.getNextVocabCardId(sizeVocab());\n  }\n\n  public VocabCard getCurrentVocabCard() {\n    return vocabMap.get(current);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'data' hides a field.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": "35",
    "end_column": "35",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "32",
    "end_line": "32",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "34",
    "end_line": "34",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Abbreviation in name 'updateUI' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "41",
    "end_line": "41",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "42",
    "end_line": "42",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "48",
    "end_line": "48",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "54",
    "end_line": "54",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "60",
    "end_line": "60",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "62",
    "end_line": "62",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "64",
    "end_line": "64",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "64",
    "end_line": "64",
    "start_column": "17",
    "end_column": "17",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Name 'State' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "77",
    "end_line": "77",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Abbreviation in name 'updateUI' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "79",
    "end_line": "79",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Abbreviation in name 'updateUI' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "103",
    "end_line": "103",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Abbreviation in name 'updateUI' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "122",
    "end_line": "122",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Abbreviation in name 'updateUI' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "143",
    "end_line": "143",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "162",
    "end_line": "162",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "162",
    "end_line": "162",
    "start_column": "20",
    "end_column": "20",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "164",
    "end_line": "164",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\nimport java.io.*;\n\n\npublic class QuizProcess {\n\n  private Scanner inStream;\n  private PrintStream out;\n  private QuizData data;\n  private State currentState;\n\n  public QuizProcess(InputStream inStream, OutputStream outStream) {\n    if (inStream!=null && outStream!=null) {\n      this.inStream = new Scanner(inStream);\n      out = new PrintStream(outStream);\n    }\n  }\n\n  private void setState(State newState) {\n    if (newState==null)\n      throw new NullPointerException();\n    currentState = newState;\n  }\n\n  public QuizData getData() {\n    return data;\n  }\n\n  public void initialize(QuizData data) {\n    if (data==null)\n      throw new NullPointerException();\n    if (currentState != null)\n      throw new IllegalStateException();\n    currentState = new StartState();\n    currentState.updateUI();\n    this.data = data;\n  }\n\n  private void updateUI() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.updateUI();\n  }\n\n  public void update() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.update();\n  }\n\n  public void input() {\n    if (currentState == null)\n      throw new IllegalStateException();\n    currentState.input();\n  }\n\n  private void setSolution(String solution) {\n    if (currentState == null)\n      throw new IllegalStateException();\n    if (solution==null)\n      throw new NullPointerException();\n    if (solution==\"\")\n      throw new IllegalArgumentException();\n    currentState.setSolution(solution);\n  }\n\n  private void drawNext() {\n    data.drawNext();\n  }\n\n  private VocabCard getCurrentVocabCard() {\n    return data.getCurrentVocabCard();\n  }\n\n  abstract class State {\n\n    public void updateUI() {\n      throw new IllegalStateException();\n    }\n\n    public void update() {\n      throw new IllegalStateException();\n    }\n\n    public void input() {\n      throw new IllegalStateException();\n    }\n\n    public void setSolution(String solution) {\n      throw new IllegalStateException();\n    }\n\n    public String toString() {\n      return \"Abstract State\";\n    }\n\n  }\n\n  public class StartState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Beep boob boob bap. Hi\");\n      QuizProcess.this.out.println(\"Beep boob boob bap. Hi\");\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"StartState\";\n    }\n\n  }\n\n  public class AskingState extends State {\n\n    public void updateUI() {\n      System.out.println(\"Please translate:\"+getCurrentVocabCard().getVocable());\n      QuizProcess.this.out.println(getCurrentVocabCard().getVocable());\n    }\n\n    public void input() {\n      currentState = new SolutionState();\n      QuizProcess.this.setSolution(getCurrentVocabCard().getTranslation());\n      QuizProcess.this.updateUI();\n    }\n\n    public String toString() {\n      return \"AskingState\";\n    }\n\n  }\n\n  public class SolutionState extends State {\n\n    private String solution;\n\n    public void updateUI() {\n      String input = QuizProcess.this.inStream.nextLine();\n      if (input.equals(solution)) {\n        QuizProcess.this.out.println(\"Correct!\");\n        System.out.println(\"Correct!\");\n      }\n      else {\n        QuizProcess.this.out.println(\"Wrong!\");\n        System.out.println(\"Wrong! Solution would have been: \"+solution+\"\\nYou entered: \"+input);\n      }\n    }\n\n    public void update() {\n      currentState = new AskingState();\n      QuizProcess.this.getData().drawNext();\n      QuizProcess.this.updateUI();\n    }\n\n    public void setSolution(String solution) {\n      if (solution == \"\")\n        throw new IllegalArgumentException();\n      if (solution == null)\n        throw new NullPointerException();\n      this.solution = solution;\n    }\n\n    public String toString() {\n      return \"SolutionState\";\n    }\n\n\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass VocabCard extends Object {\n\n  private String vocable;\n  private String translation;\n\n  public VocabCard(String vocable, String translation) {\n    if (vocable==\"\"||translation==\"\")\n      throw new IllegalArgumentException();\n    if (vocable==null||translation==null)\n      throw new NullPointerException();\n    this.vocable = vocable;\n    this.translation = translation;\n  }\n\n  public String getVocable() {\n    return vocable;\n  }\n\n  public String getTranslation() {\n    return translation;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof VocabCard) {\n      VocabCard check = (VocabCard) o;\n      return (check.getVocable().equals(vocable))&&(check.getTranslation().equals(translation));\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(vocable, translation);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass VocabCard extends Object {\n\n  private String vocable;\n  private String translation;\n\n  public VocabCard(String vocable, String translation) {\n    if (vocable==\"\"||translation==\"\")\n      throw new IllegalArgumentException();\n    if (vocable==null||translation==null)\n      throw new NullPointerException();\n    this.vocable = vocable;\n    this.translation = translation;\n  }\n\n  public String getVocable() {\n    return vocable;\n  }\n\n  public String getTranslation() {\n    return translation;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof VocabCard) {\n      VocabCard check = (VocabCard) o;\n      return (check.getVocable().equals(vocable))&&(check.getTranslation().equals(translation));\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(vocable, translation);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass VocabCard extends Object {\n\n  private String vocable;\n  private String translation;\n\n  public VocabCard(String vocable, String translation) {\n    if (vocable==\"\"||translation==\"\")\n      throw new IllegalArgumentException();\n    if (vocable==null||translation==null)\n      throw new NullPointerException();\n    this.vocable = vocable;\n    this.translation = translation;\n  }\n\n  public String getVocable() {\n    return vocable;\n  }\n\n  public String getTranslation() {\n    return translation;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof VocabCard) {\n      VocabCard check = (VocabCard) o;\n      return (check.getVocable().equals(vocable))&&(check.getTranslation().equals(translation));\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(vocable, translation);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass VocabCard extends Object {\n\n  private String vocable;\n  private String translation;\n\n  public VocabCard(String vocable, String translation) {\n    if (vocable==\"\"||translation==\"\")\n      throw new IllegalArgumentException();\n    if (vocable==null||translation==null)\n      throw new NullPointerException();\n    this.vocable = vocable;\n    this.translation = translation;\n  }\n\n  public String getVocable() {\n    return vocable;\n  }\n\n  public String getTranslation() {\n    return translation;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof VocabCard) {\n      VocabCard check = (VocabCard) o;\n      return (check.getVocable().equals(vocable))&&(check.getTranslation().equals(translation));\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(vocable, translation);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass VocabCard extends Object {\n\n  private String vocable;\n  private String translation;\n\n  public VocabCard(String vocable, String translation) {\n    if (vocable==\"\"||translation==\"\")\n      throw new IllegalArgumentException();\n    if (vocable==null||translation==null)\n      throw new NullPointerException();\n    this.vocable = vocable;\n    this.translation = translation;\n  }\n\n  public String getVocable() {\n    return vocable;\n  }\n\n  public String getTranslation() {\n    return translation;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof VocabCard) {\n      VocabCard check = (VocabCard) o;\n      return (check.getVocable().equals(vocable))&&(check.getTranslation().equals(translation));\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(vocable, translation);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass VocabReader {\n\n  private Scanner vocabFileStream;\n\n  public VocabReader(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public void setVocabFileStream(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public Map<Integer, VocabCard> read() {\n    Map<Integer,VocabCard> vocabMap = new HashMap<Integer,VocabCard>();\n    Integer currentInt = 1;\n    String currentLine;\n    while (vocabFileStream.hasNextLine()) {\n      currentLine = vocabFileStream.nextLine();\n      System.out.println(\"Current Line: \"+currentLine);\n      if (!(currentLine.contains(\"#\"))) {\n        vocabMap.put(currentInt, createVocabCard(currentLine));\n        currentInt += 1;\n      }\n    }\n    return vocabMap;\n  }\n\n  private VocabCard createVocabCard(String line) {\n    if (line==null)\n      throw new NullPointerException();\n    if (line == \"\")\n      throw new IllegalArgumentException();\n    VocabCard output = new VocabCard(line.split(\"\\\\:\")[0], line.split(\"\\\\:\")[1]);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass VocabReader {\n\n  private Scanner vocabFileStream;\n\n  public VocabReader(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public void setVocabFileStream(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public Map<Integer, VocabCard> read() {\n    Map<Integer,VocabCard> vocabMap = new HashMap<Integer,VocabCard>();\n    Integer currentInt = 1;\n    String currentLine;\n    while (vocabFileStream.hasNextLine()) {\n      currentLine = vocabFileStream.nextLine();\n      System.out.println(\"Current Line: \"+currentLine);\n      if (!(currentLine.contains(\"#\"))) {\n        vocabMap.put(currentInt, createVocabCard(currentLine));\n        currentInt += 1;\n      }\n    }\n    return vocabMap;\n  }\n\n  private VocabCard createVocabCard(String line) {\n    if (line==null)\n      throw new NullPointerException();\n    if (line == \"\")\n      throw new IllegalArgumentException();\n    VocabCard output = new VocabCard(line.split(\"\\\\:\")[0], line.split(\"\\\\:\")[1]);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass VocabReader {\n\n  private Scanner vocabFileStream;\n\n  public VocabReader(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public void setVocabFileStream(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public Map<Integer, VocabCard> read() {\n    Map<Integer,VocabCard> vocabMap = new HashMap<Integer,VocabCard>();\n    Integer currentInt = 1;\n    String currentLine;\n    while (vocabFileStream.hasNextLine()) {\n      currentLine = vocabFileStream.nextLine();\n      System.out.println(\"Current Line: \"+currentLine);\n      if (!(currentLine.contains(\"#\"))) {\n        vocabMap.put(currentInt, createVocabCard(currentLine));\n        currentInt += 1;\n      }\n    }\n    return vocabMap;\n  }\n\n  private VocabCard createVocabCard(String line) {\n    if (line==null)\n      throw new NullPointerException();\n    if (line == \"\")\n      throw new IllegalArgumentException();\n    VocabCard output = new VocabCard(line.split(\"\\\\:\")[0], line.split(\"\\\\:\")[1]);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "37",
    "end_line": "37",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass VocabReader {\n\n  private Scanner vocabFileStream;\n\n  public VocabReader(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public void setVocabFileStream(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public Map<Integer, VocabCard> read() {\n    Map<Integer,VocabCard> vocabMap = new HashMap<Integer,VocabCard>();\n    Integer currentInt = 1;\n    String currentLine;\n    while (vocabFileStream.hasNextLine()) {\n      currentLine = vocabFileStream.nextLine();\n      System.out.println(\"Current Line: \"+currentLine);\n      if (!(currentLine.contains(\"#\"))) {\n        vocabMap.put(currentInt, createVocabCard(currentLine));\n        currentInt += 1;\n      }\n    }\n    return vocabMap;\n  }\n\n  private VocabCard createVocabCard(String line) {\n    if (line==null)\n      throw new NullPointerException();\n    if (line == \"\")\n      throw new IllegalArgumentException();\n    VocabCard output = new VocabCard(line.split(\"\\\\:\")[0], line.split(\"\\\\:\")[1]);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "39",
    "end_line": "39",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass VocabReader {\n\n  private Scanner vocabFileStream;\n\n  public VocabReader(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public void setVocabFileStream(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public Map<Integer, VocabCard> read() {\n    Map<Integer,VocabCard> vocabMap = new HashMap<Integer,VocabCard>();\n    Integer currentInt = 1;\n    String currentLine;\n    while (vocabFileStream.hasNextLine()) {\n      currentLine = vocabFileStream.nextLine();\n      System.out.println(\"Current Line: \"+currentLine);\n      if (!(currentLine.contains(\"#\"))) {\n        vocabMap.put(currentInt, createVocabCard(currentLine));\n        currentInt += 1;\n      }\n    }\n    return vocabMap;\n  }\n\n  private VocabCard createVocabCard(String line) {\n    if (line==null)\n      throw new NullPointerException();\n    if (line == \"\")\n      throw new IllegalArgumentException();\n    VocabCard output = new VocabCard(line.split(\"\\\\:\")[0], line.split(\"\\\\:\")[1]);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Vocabulary Trainer",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "39",
    "end_line": "39",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass VocabReader {\n\n  private Scanner vocabFileStream;\n\n  public VocabReader(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public void setVocabFileStream(InputStream vocabFileStream) {\n    if (vocabFileStream==null)\n      throw new NullPointerException();\n    this.vocabFileStream = new Scanner(vocabFileStream);\n  }\n\n  public Map<Integer, VocabCard> read() {\n    Map<Integer,VocabCard> vocabMap = new HashMap<Integer,VocabCard>();\n    Integer currentInt = 1;\n    String currentLine;\n    while (vocabFileStream.hasNextLine()) {\n      currentLine = vocabFileStream.nextLine();\n      System.out.println(\"Current Line: \"+currentLine);\n      if (!(currentLine.contains(\"#\"))) {\n        vocabMap.put(currentInt, createVocabCard(currentLine));\n        currentInt += 1;\n      }\n    }\n    return vocabMap;\n  }\n\n  private VocabCard createVocabCard(String line) {\n    if (line==null)\n      throw new NullPointerException();\n    if (line == \"\")\n      throw new IllegalArgumentException();\n    VocabCard output = new VocabCard(line.split(\"\\\\:\")[0], line.split(\"\\\\:\")[1]);\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Java and Functions",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "class Functions {\n\n  public static int factorial(int n) {\n      if (n == 0)\n        return 1;\n      if (n == 1)\n        return 1;\n      return n * factorial(n-1);\n  }\n}\n\n// class Application {\n//\n//   public static void main(String[] args) {\n//     Application application = new Application();\n//     application.run();\n//   }\n//\n//   public void run() {\n//     Functions parser = new Functions();\n//     System.out.printf(\"The Factorial of 5 is %d\\n\", parser.factorial(5));\n//   }\n// }\n"
  },
  {
    "user": "3",
    "task": "Java and Functions",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Functions {\n\n  public static int factorial(int n) {\n      if (n == 0)\n        return 1;\n      if (n == 1)\n        return 1;\n      return n * factorial(n-1);\n  }\n}\n\n// class Application {\n//\n//   public static void main(String[] args) {\n//     Application application = new Application();\n//     application.run();\n//   }\n//\n//   public void run() {\n//     Functions parser = new Functions();\n//     System.out.printf(\"The Factorial of 5 is %d\\n\", parser.factorial(5));\n//   }\n// }\n"
  },
  {
    "user": "3",
    "task": "Java and Functions",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Functions {\n\n  public static int factorial(int n) {\n      if (n == 0)\n        return 1;\n      if (n == 1)\n        return 1;\n      return n * factorial(n-1);\n  }\n}\n\n// class Application {\n//\n//   public static void main(String[] args) {\n//     Application application = new Application();\n//     application.run();\n//   }\n//\n//   public void run() {\n//     Functions parser = new Functions();\n//     System.out.printf(\"The Factorial of 5 is %d\\n\", parser.factorial(5));\n//   }\n// }\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DefaultCollector implements KeywordCollector {\n\n  public Set<String> getKeywords(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    Set<String> output = new HashSet<String>();\n    output.add(res.getName());\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": "19",
    "end_column": "19",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": "19",
    "end_column": "19",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": "19",
    "end_column": "19",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "38",
    "end_line": "38",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "44",
    "end_line": "44",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "44",
    "end_line": "44",
    "start_column": "17",
    "end_column": "17",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "46",
    "end_line": "46",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass DesktopSearch {\n\n  private Map<String,ResourceType> types = new HashMap<String,ResourceType>();\n  private Index index;\n\n  public DesktopSearch() {}\n\n  public void registerType(String extension, ResourceType type) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null || type == null)\n      throw new NullPointerException();\n    if (!(this.types.containsKey(extension)))\n      this.types.put(extension, type);\n  }\n\n  public ResourceType getType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    return this.types.get(extension);\n  }\n\n  public void unregisterType(String extension) {\n    if (extension == \"\")\n      throw new IllegalArgumentException();\n    if (extension == null)\n      throw new NullPointerException();\n    if (this.types.containsKey(extension))\n      this.types.remove(extension);\n  }\n\n  public void registerResource(Resource res) {\n    if (res == null)\n      throw new NullPointerException();\n    this.index.add(res);\n  }\n\n  public List<Resource> processRequest(String request) {\n    if (request == \"\")\n      throw new IllegalArgumentException();\n    if (request == null)\n      throw new NullPointerException();\n    return this.index.getResources(request);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\n\n\nclass Index {\n\n  private Map<String,ArrayList<Resource>> index = new HashMap<String,ArrayList<Resource>>();\n\n  public Index() {}\n\n  public void add(Resource res) {\n    // Check if resource is empty\n    if (res == null) {\n      throw new IllegalArgumentException(\"Empty resource!\");\n    }\n    else {\n      // Get keywords of resource through forward propagation\n      // For each keyword, receive resources already in the index\n      // Add resource to existing resources or create the list and reappend\n      Set<String> keywords = res.getType().getCollector().getKeywords(res);\n      for (String keyword : keywords) {\n        ArrayList<Resource> resources = this.index.get(keyword);\n        if (resources == null) {\n          resources = new ArrayList<Resource>();\n          resources.add(res);\n          this.index.put(keyword, resources);\n        }\n        else {\n          if (!resources.contains(res)) {\n            resources.add(res);\n            this.index.put(keyword, resources);\n          }\n        }\n      }\n    }\n  }\n\n  public List<Resource> getResources(String keyword) {\n    return this.index.get(keyword);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface KeywordCollector {\n\n  public Set<String> getKeywords(Resource res);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Resource {\n\n  private String name;\n  private String path;\n  private ResourceType rt;\n\n  public Resource (String name, String path, ResourceType rt) {\n\n    if (name == null) throw new IllegalArgumentException(\"Name is empty\");\n    else this.name = name;\n    if (path == null) throw new IllegalArgumentException(\"Path is empty\");\n    else this.path = path;\n    if (rt == null) throw new IllegalArgumentException(\"ResourceType is empty\");\n    else this.rt = rt;\n\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getPath() {\n    return this.path;\n  }\n\n  public ResourceType getType() {\n    return this.rt;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Resource {\n\n  private String name;\n  private String path;\n  private ResourceType rt;\n\n  public Resource (String name, String path, ResourceType rt) {\n\n    if (name == null) throw new IllegalArgumentException(\"Name is empty\");\n    else this.name = name;\n    if (path == null) throw new IllegalArgumentException(\"Path is empty\");\n    else this.path = path;\n    if (rt == null) throw new IllegalArgumentException(\"ResourceType is empty\");\n    else this.rt = rt;\n\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getPath() {\n    return this.path;\n  }\n\n  public ResourceType getType() {\n    return this.rt;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Resource {\n\n  private String name;\n  private String path;\n  private ResourceType rt;\n\n  public Resource (String name, String path, ResourceType rt) {\n\n    if (name == null) throw new IllegalArgumentException(\"Name is empty\");\n    else this.name = name;\n    if (path == null) throw new IllegalArgumentException(\"Path is empty\");\n    else this.path = path;\n    if (rt == null) throw new IllegalArgumentException(\"ResourceType is empty\");\n    else this.rt = rt;\n\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getPath() {\n    return this.path;\n  }\n\n  public ResourceType getType() {\n    return this.rt;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Resource {\n\n  private String name;\n  private String path;\n  private ResourceType rt;\n\n  public Resource (String name, String path, ResourceType rt) {\n\n    if (name == null) throw new IllegalArgumentException(\"Name is empty\");\n    else this.name = name;\n    if (path == null) throw new IllegalArgumentException(\"Path is empty\");\n    else this.path = path;\n    if (rt == null) throw new IllegalArgumentException(\"ResourceType is empty\");\n    else this.rt = rt;\n\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getPath() {\n    return this.path;\n  }\n\n  public ResourceType getType() {\n    return this.rt;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Resource {\n\n  private String name;\n  private String path;\n  private ResourceType rt;\n\n  public Resource (String name, String path, ResourceType rt) {\n\n    if (name == null) throw new IllegalArgumentException(\"Name is empty\");\n    else this.name = name;\n    if (path == null) throw new IllegalArgumentException(\"Path is empty\");\n    else this.path = path;\n    if (rt == null) throw new IllegalArgumentException(\"ResourceType is empty\");\n    else this.rt = rt;\n\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getPath() {\n    return this.path;\n  }\n\n  public ResourceType getType() {\n    return this.rt;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Resource {\n\n  private String name;\n  private String path;\n  private ResourceType rt;\n\n  public Resource (String name, String path, ResourceType rt) {\n\n    if (name == null) throw new IllegalArgumentException(\"Name is empty\");\n    else this.name = name;\n    if (path == null) throw new IllegalArgumentException(\"Path is empty\");\n    else this.path = path;\n    if (rt == null) throw new IllegalArgumentException(\"ResourceType is empty\");\n    else this.rt = rt;\n\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getPath() {\n    return this.path;\n  }\n\n  public ResourceType getType() {\n    return this.rt;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Resource {\n\n  private String name;\n  private String path;\n  private ResourceType rt;\n\n  public Resource (String name, String path, ResourceType rt) {\n\n    if (name == null) throw new IllegalArgumentException(\"Name is empty\");\n    else this.name = name;\n    if (path == null) throw new IllegalArgumentException(\"Path is empty\");\n    else this.path = path;\n    if (rt == null) throw new IllegalArgumentException(\"ResourceType is empty\");\n    else this.rt = rt;\n\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getPath() {\n    return this.path;\n  }\n\n  public ResourceType getType() {\n    return this.rt;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass ResourceType {\n\n  private String description;\n  private KeywordCollector collector;\n\n  public ResourceType(String desc, KeywordCollector collector) {\n    if (desc == null) {throw new IllegalArgumentException(\"Description is empty\");}\n    else {this.description = desc;}\n    if (collector == null) {throw new IllegalArgumentException(\"Collector is empty\");}\n    else {this.collector = collector;}\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public KeywordCollector getCollector() {\n    return this.collector;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'{' at column 23 should have line break after.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "23",
    "end_column": "23",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass ResourceType {\n\n  private String description;\n  private KeywordCollector collector;\n\n  public ResourceType(String desc, KeywordCollector collector) {\n    if (desc == null) {throw new IllegalArgumentException(\"Description is empty\");}\n    else {this.description = desc;}\n    if (collector == null) {throw new IllegalArgumentException(\"Collector is empty\");}\n    else {this.collector = collector;}\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public KeywordCollector getCollector() {\n    return this.collector;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'{' at column 10 should have line break after.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "10",
    "end_column": "10",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass ResourceType {\n\n  private String description;\n  private KeywordCollector collector;\n\n  public ResourceType(String desc, KeywordCollector collector) {\n    if (desc == null) {throw new IllegalArgumentException(\"Description is empty\");}\n    else {this.description = desc;}\n    if (collector == null) {throw new IllegalArgumentException(\"Collector is empty\");}\n    else {this.collector = collector;}\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public KeywordCollector getCollector() {\n    return this.collector;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'{' at column 28 should have line break after.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "28",
    "end_column": "28",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass ResourceType {\n\n  private String description;\n  private KeywordCollector collector;\n\n  public ResourceType(String desc, KeywordCollector collector) {\n    if (desc == null) {throw new IllegalArgumentException(\"Description is empty\");}\n    else {this.description = desc;}\n    if (collector == null) {throw new IllegalArgumentException(\"Collector is empty\");}\n    else {this.collector = collector;}\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public KeywordCollector getCollector() {\n    return this.collector;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "'{' at column 10 should have line break after.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": "10",
    "end_column": "10",
    "rule": {
      "identifier": "LeftCurly",
      "explanation": "Code blocks should always include left curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass ResourceType {\n\n  private String description;\n  private KeywordCollector collector;\n\n  public ResourceType(String desc, KeywordCollector collector) {\n    if (desc == null) {throw new IllegalArgumentException(\"Description is empty\");}\n    else {this.description = desc;}\n    if (collector == null) {throw new IllegalArgumentException(\"Collector is empty\");}\n    else {this.collector = collector;}\n  }\n\n  public String getDescription() {\n    return this.description;\n  }\n\n  public KeywordCollector getCollector() {\n    return this.collector;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Variable 'resource' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "12",
    "end_column": "12",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.UnsupportedOperationException;\n\nclass TextFileIterator implements Iterator<String> {\n\n  Resource resource;\n\n  public TextFileIterator(Resource res) {\n    this.resource = res;\n  }\n\n  @Override\n  public boolean hasNext() {\n    return false;\n  }\n\n  @Override\n  public String next() {\n    return \"\";\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"Method remove() is not supported.\");\n  }\n\n  public String getAsString(Resource res) {\n    return \"We wish you good luck in this exam!\\nWe hope you are well pre-\\npared.\";\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Desktop Search Engine",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.UnsupportedOperationException;\n\nclass TextFileIterator implements Iterator<String> {\n\n  Resource resource;\n\n  public TextFileIterator(Resource res) {\n    this.resource = res;\n  }\n\n  @Override\n  public boolean hasNext() {\n    return false;\n  }\n\n  @Override\n  public String next() {\n    return \"\";\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"Method remove() is not supported.\");\n  }\n\n  public String getAsString(Resource res) {\n    return \"We wish you good luck in this exam!\\nWe hope you are well pre-\\npared.\";\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Library",
    "message": "Variable 'title' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "10",
    "end_column": "10",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "class Book {\n\n  String title;\n\n  public Book(String title) {\n    this.title = title;\n    System.out.println(\"Book \"+title+\" created.\");\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Library",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Book {\n\n  String title;\n\n  public Book(String title) {\n    this.title = title;\n    System.out.println(\"Book \"+title+\" created.\");\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Library",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "class HelloLibrary {\n  public static void main(String[] args) {\n    Library lib = new Library();\n    Book book1 = new Book(\"UML\");\n    Book book2 = new Book(\"Java2\");\n    lib.add(book1);\n    lib.add(book2);\n    lib.search(\"UML\");\n    lib.search(\"Test\");\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Library",
    "message": "Variable 'maxbooks' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "7",
    "end_column": "7",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Library {\n\n  int maxbooks = 10;\n  int currentbooks;\n  List<Book> books = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library, which can store up to 10 books!\");\n    this.currentbooks = 0;\n  }\n\n  public void add(Book book) {\n    Book add_this_book = book;\n    if (this.currentbooks == maxbooks)\n      System.out.println(\"The library is full!\");\n    else {\n      System.out.println(\"I added the book \"+book.title+\"!\");\n      this.books.add(add_this_book);\n      this.currentbooks = this.currentbooks + 1;\n    }\n  }\n\n  public Book search(String title) {\n    for (int i = 0; i < currentbooks; i++) {\n      if (books.get(i).title == title) {\n        System.out.println(\"The book with the title \"+title+\" exists in the library!\");\n        return books.get(i);\n      }\n    }\n    System.out.println(\"The book with the title \"+title+\" does not exist in the library!\");\n    return null;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Library",
    "message": "'10' is a magic number.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "18",
    "end_column": "18",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Library {\n\n  int maxbooks = 10;\n  int currentbooks;\n  List<Book> books = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library, which can store up to 10 books!\");\n    this.currentbooks = 0;\n  }\n\n  public void add(Book book) {\n    Book add_this_book = book;\n    if (this.currentbooks == maxbooks)\n      System.out.println(\"The library is full!\");\n    else {\n      System.out.println(\"I added the book \"+book.title+\"!\");\n      this.books.add(add_this_book);\n      this.currentbooks = this.currentbooks + 1;\n    }\n  }\n\n  public Book search(String title) {\n    for (int i = 0; i < currentbooks; i++) {\n      if (books.get(i).title == title) {\n        System.out.println(\"The book with the title \"+title+\" exists in the library!\");\n        return books.get(i);\n      }\n    }\n    System.out.println(\"The book with the title \"+title+\" does not exist in the library!\");\n    return null;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Library",
    "message": "Variable 'currentbooks' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "7",
    "end_column": "7",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Library {\n\n  int maxbooks = 10;\n  int currentbooks;\n  List<Book> books = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library, which can store up to 10 books!\");\n    this.currentbooks = 0;\n  }\n\n  public void add(Book book) {\n    Book add_this_book = book;\n    if (this.currentbooks == maxbooks)\n      System.out.println(\"The library is full!\");\n    else {\n      System.out.println(\"I added the book \"+book.title+\"!\");\n      this.books.add(add_this_book);\n      this.currentbooks = this.currentbooks + 1;\n    }\n  }\n\n  public Book search(String title) {\n    for (int i = 0; i < currentbooks; i++) {\n      if (books.get(i).title == title) {\n        System.out.println(\"The book with the title \"+title+\" exists in the library!\");\n        return books.get(i);\n      }\n    }\n    System.out.println(\"The book with the title \"+title+\" does not exist in the library!\");\n    return null;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Library",
    "message": "Variable 'books' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Library {\n\n  int maxbooks = 10;\n  int currentbooks;\n  List<Book> books = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library, which can store up to 10 books!\");\n    this.currentbooks = 0;\n  }\n\n  public void add(Book book) {\n    Book add_this_book = book;\n    if (this.currentbooks == maxbooks)\n      System.out.println(\"The library is full!\");\n    else {\n      System.out.println(\"I added the book \"+book.title+\"!\");\n      this.books.add(add_this_book);\n      this.currentbooks = this.currentbooks + 1;\n    }\n  }\n\n  public Book search(String title) {\n    for (int i = 0; i < currentbooks; i++) {\n      if (books.get(i).title == title) {\n        System.out.println(\"The book with the title \"+title+\" exists in the library!\");\n        return books.get(i);\n      }\n    }\n    System.out.println(\"The book with the title \"+title+\" does not exist in the library!\");\n    return null;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Library",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Library {\n\n  int maxbooks = 10;\n  int currentbooks;\n  List<Book> books = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library, which can store up to 10 books!\");\n    this.currentbooks = 0;\n  }\n\n  public void add(Book book) {\n    Book add_this_book = book;\n    if (this.currentbooks == maxbooks)\n      System.out.println(\"The library is full!\");\n    else {\n      System.out.println(\"I added the book \"+book.title+\"!\");\n      this.books.add(add_this_book);\n      this.currentbooks = this.currentbooks + 1;\n    }\n  }\n\n  public Book search(String title) {\n    for (int i = 0; i < currentbooks; i++) {\n      if (books.get(i).title == title) {\n        System.out.println(\"The book with the title \"+title+\" exists in the library!\");\n        return books.get(i);\n      }\n    }\n    System.out.println(\"The book with the title \"+title+\" does not exist in the library!\");\n    return null;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Library",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Library {\n\n  int maxbooks = 10;\n  int currentbooks;\n  List<Book> books = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library, which can store up to 10 books!\");\n    this.currentbooks = 0;\n  }\n\n  public void add(Book book) {\n    Book add_this_book = book;\n    if (this.currentbooks == maxbooks)\n      System.out.println(\"The library is full!\");\n    else {\n      System.out.println(\"I added the book \"+book.title+\"!\");\n      this.books.add(add_this_book);\n      this.currentbooks = this.currentbooks + 1;\n    }\n  }\n\n  public Book search(String title) {\n    for (int i = 0; i < currentbooks; i++) {\n      if (books.get(i).title == title) {\n        System.out.println(\"The book with the title \"+title+\" exists in the library!\");\n        return books.get(i);\n      }\n    }\n    System.out.println(\"The book with the title \"+title+\" does not exist in the library!\");\n    return null;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Leet",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.Arrays;\n\nclass Leet {\n\n  private static String[] regex = new String[] {\"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\"};\n  private static String[] replacement = new String[] {\"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\"};\n\n\n  public static String toLeet(String normal) {\n    if (normal == null)\n      return null;\n    for (int i = 0; i < 11; i++) {\n      normal = normal.replaceAll(regex[i], replacement[i]);\n    }\n    return normal;\n  }\n\n  public static String[] allToLeet(String[] normals) {\n    String[] output = new String[normals.length];\n    for (int i = 0; i < output.length; i++)\n      output[i] = toLeet(normals[i]);\n    return output;\n  }\n\n}\n\n// class Application {\n//\n//   public static void main(String[] args) {\n//     Application application = new Application();\n//     application.run();\n//   }\n//\n//   public void run() {\n//     String[] org = new String[] { \"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\", };\n//     String[] res = new String[] { \"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\", };\n//     String[] orgText = new String[] { \"We are elite hackers!\", \"Informatiker machen tolle Sachen!\" };\n//     String[] resText = new String[] { \"W3 @r3 1337 h@xx0rz!!!11\",\n//             \"Inf0rm@7ik0rz m@chn 70ll3 S@chn!!!11\" };\n//     String[] actual = Leet.allToLeet(org);\n//     String[] actualText = Leet.allToLeet(orgText);\n//\n//\n//     for (int i = 0; i < org.length; i++) {\n//                 System.out.println(Leet.toLeet(org[i]));\n//     }\n//     for (int i = 0; i < orgText.length; i++) {\n//                 System.out.println(Leet.toLeet(orgText[i]));\n//     }\n//     System.out.println(Arrays.toString(actual));\n//     System.out.println(Arrays.toString(actualText));\n//\n//   }\n// }\n"
  },
  {
    "user": "3",
    "task": "Leet",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Arrays;\n\nclass Leet {\n\n  private static String[] regex = new String[] {\"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\"};\n  private static String[] replacement = new String[] {\"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\"};\n\n\n  public static String toLeet(String normal) {\n    if (normal == null)\n      return null;\n    for (int i = 0; i < 11; i++) {\n      normal = normal.replaceAll(regex[i], replacement[i]);\n    }\n    return normal;\n  }\n\n  public static String[] allToLeet(String[] normals) {\n    String[] output = new String[normals.length];\n    for (int i = 0; i < output.length; i++)\n      output[i] = toLeet(normals[i]);\n    return output;\n  }\n\n}\n\n// class Application {\n//\n//   public static void main(String[] args) {\n//     Application application = new Application();\n//     application.run();\n//   }\n//\n//   public void run() {\n//     String[] org = new String[] { \"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\", };\n//     String[] res = new String[] { \"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\", };\n//     String[] orgText = new String[] { \"We are elite hackers!\", \"Informatiker machen tolle Sachen!\" };\n//     String[] resText = new String[] { \"W3 @r3 1337 h@xx0rz!!!11\",\n//             \"Inf0rm@7ik0rz m@chn 70ll3 S@chn!!!11\" };\n//     String[] actual = Leet.allToLeet(org);\n//     String[] actualText = Leet.allToLeet(orgText);\n//\n//\n//     for (int i = 0; i < org.length; i++) {\n//                 System.out.println(Leet.toLeet(org[i]));\n//     }\n//     for (int i = 0; i < orgText.length; i++) {\n//                 System.out.println(Leet.toLeet(orgText[i]));\n//     }\n//     System.out.println(Arrays.toString(actual));\n//     System.out.println(Arrays.toString(actualText));\n//\n//   }\n// }\n"
  },
  {
    "user": "3",
    "task": "Leet",
    "message": "'11' is a magic number.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": "25",
    "end_column": "25",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Arrays;\n\nclass Leet {\n\n  private static String[] regex = new String[] {\"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\"};\n  private static String[] replacement = new String[] {\"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\"};\n\n\n  public static String toLeet(String normal) {\n    if (normal == null)\n      return null;\n    for (int i = 0; i < 11; i++) {\n      normal = normal.replaceAll(regex[i], replacement[i]);\n    }\n    return normal;\n  }\n\n  public static String[] allToLeet(String[] normals) {\n    String[] output = new String[normals.length];\n    for (int i = 0; i < output.length; i++)\n      output[i] = toLeet(normals[i]);\n    return output;\n  }\n\n}\n\n// class Application {\n//\n//   public static void main(String[] args) {\n//     Application application = new Application();\n//     application.run();\n//   }\n//\n//   public void run() {\n//     String[] org = new String[] { \"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\", };\n//     String[] res = new String[] { \"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\", };\n//     String[] orgText = new String[] { \"We are elite hackers!\", \"Informatiker machen tolle Sachen!\" };\n//     String[] resText = new String[] { \"W3 @r3 1337 h@xx0rz!!!11\",\n//             \"Inf0rm@7ik0rz m@chn 70ll3 S@chn!!!11\" };\n//     String[] actual = Leet.allToLeet(org);\n//     String[] actualText = Leet.allToLeet(orgText);\n//\n//\n//     for (int i = 0; i < org.length; i++) {\n//                 System.out.println(Leet.toLeet(org[i]));\n//     }\n//     for (int i = 0; i < orgText.length; i++) {\n//                 System.out.println(Leet.toLeet(orgText[i]));\n//     }\n//     System.out.println(Arrays.toString(actual));\n//     System.out.println(Arrays.toString(actualText));\n//\n//   }\n// }\n"
  },
  {
    "user": "3",
    "task": "Leet",
    "message": "Assignment of parameter 'normal' is not allowed.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "ParameterAssignment",
      "explanation": "Assignments to parameters of a function is often considered poor programming practice, because the parameters may be mutated without knowledge of the outside caller and reused in a potentially erroneous context. Parameters can be declared final.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.Arrays;\n\nclass Leet {\n\n  private static String[] regex = new String[] {\"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\"};\n  private static String[] replacement = new String[] {\"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\"};\n\n\n  public static String toLeet(String normal) {\n    if (normal == null)\n      return null;\n    for (int i = 0; i < 11; i++) {\n      normal = normal.replaceAll(regex[i], replacement[i]);\n    }\n    return normal;\n  }\n\n  public static String[] allToLeet(String[] normals) {\n    String[] output = new String[normals.length];\n    for (int i = 0; i < output.length; i++)\n      output[i] = toLeet(normals[i]);\n    return output;\n  }\n\n}\n\n// class Application {\n//\n//   public static void main(String[] args) {\n//     Application application = new Application();\n//     application.run();\n//   }\n//\n//   public void run() {\n//     String[] org = new String[] { \"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\", };\n//     String[] res = new String[] { \"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\", };\n//     String[] orgText = new String[] { \"We are elite hackers!\", \"Informatiker machen tolle Sachen!\" };\n//     String[] resText = new String[] { \"W3 @r3 1337 h@xx0rz!!!11\",\n//             \"Inf0rm@7ik0rz m@chn 70ll3 S@chn!!!11\" };\n//     String[] actual = Leet.allToLeet(org);\n//     String[] actualText = Leet.allToLeet(orgText);\n//\n//\n//     for (int i = 0; i < org.length; i++) {\n//                 System.out.println(Leet.toLeet(org[i]));\n//     }\n//     for (int i = 0; i < orgText.length; i++) {\n//                 System.out.println(Leet.toLeet(orgText[i]));\n//     }\n//     System.out.println(Arrays.toString(actual));\n//     System.out.println(Arrays.toString(actualText));\n//\n//   }\n// }\n"
  },
  {
    "user": "3",
    "task": "Leet",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Arrays;\n\nclass Leet {\n\n  private static String[] regex = new String[] {\"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\"};\n  private static String[] replacement = new String[] {\"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\"};\n\n\n  public static String toLeet(String normal) {\n    if (normal == null)\n      return null;\n    for (int i = 0; i < 11; i++) {\n      normal = normal.replaceAll(regex[i], replacement[i]);\n    }\n    return normal;\n  }\n\n  public static String[] allToLeet(String[] normals) {\n    String[] output = new String[normals.length];\n    for (int i = 0; i < output.length; i++)\n      output[i] = toLeet(normals[i]);\n    return output;\n  }\n\n}\n\n// class Application {\n//\n//   public static void main(String[] args) {\n//     Application application = new Application();\n//     application.run();\n//   }\n//\n//   public void run() {\n//     String[] org = new String[] { \"elite\", \"cool\", \"!\", \"ck\", \"ers\", \"er\", \"en\", \"e\", \"t\", \"o\", \"a\", };\n//     String[] res = new String[] { \"1337\", \"k3wl\", \"!!!11\", \"xx\", \"0rz\", \"0rz\", \"n\", \"3\", \"7\", \"0\", \"@\", };\n//     String[] orgText = new String[] { \"We are elite hackers!\", \"Informatiker machen tolle Sachen!\" };\n//     String[] resText = new String[] { \"W3 @r3 1337 h@xx0rz!!!11\",\n//             \"Inf0rm@7ik0rz m@chn 70ll3 S@chn!!!11\" };\n//     String[] actual = Leet.allToLeet(org);\n//     String[] actualText = Leet.allToLeet(orgText);\n//\n//\n//     for (int i = 0; i < org.length; i++) {\n//                 System.out.println(Leet.toLeet(org[i]));\n//     }\n//     for (int i = 0; i < orgText.length; i++) {\n//                 System.out.println(Leet.toLeet(orgText[i]));\n//     }\n//     System.out.println(Arrays.toString(actual));\n//     System.out.println(Arrays.toString(actualText));\n//\n//   }\n// }\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nabstract class AbstractEnterpriseUnit implements EnterpriseNode {\n\n  private String name;\n\n  public AbstractEnterpriseUnit(String name) {\n    if (name == null) throw new NullPointerException(\"Empty string\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    this.name = name;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nabstract class AbstractEnterpriseUnit implements EnterpriseNode {\n\n  private String name;\n\n  public AbstractEnterpriseUnit(String name) {\n    if (name == null) throw new NullPointerException(\"Empty string\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    this.name = name;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nabstract class AbstractEnterpriseUnit implements EnterpriseNode {\n\n  private String name;\n\n  public AbstractEnterpriseUnit(String name) {\n    if (name == null) throw new NullPointerException(\"Empty string\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    this.name = name;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\n\nabstract class AbstractEnterpriseUnit implements EnterpriseNode {\n\n  private String name;\n\n  public AbstractEnterpriseUnit(String name) {\n    if (name == null) throw new NullPointerException(\"Empty string\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    this.name = name;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\n\nabstract class AbstractUnit extends AbstractEnterpriseUnit{\n\n  private List<AbstractEnterpriseUnit> childNodes = new ArrayList<AbstractEnterpriseUnit>();\n\n  public AbstractUnit(String name) {\n    super(name);\n  }\n\n  public boolean add(AbstractEnterpriseUnit childNode) {\n    if (childNode == null) throw new NullPointerException(\"Empty argument\");\n    if (!(this.childNodes.contains(childNode))) return this.childNodes.add(childNode);\n    return false;\n  }\n\n  public boolean remove(AbstractEnterpriseUnit childNode) {\n    if (childNode == null) throw new NullPointerException(\"Empty argument\");\n    return this.childNodes.remove(childNode);\n  }\n\n  public List<AbstractEnterpriseUnit> getChildNodes() {\n    return this.childNodes;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\n\nabstract class AbstractUnit extends AbstractEnterpriseUnit{\n\n  private List<AbstractEnterpriseUnit> childNodes = new ArrayList<AbstractEnterpriseUnit>();\n\n  public AbstractUnit(String name) {\n    super(name);\n  }\n\n  public boolean add(AbstractEnterpriseUnit childNode) {\n    if (childNode == null) throw new NullPointerException(\"Empty argument\");\n    if (!(this.childNodes.contains(childNode))) return this.childNodes.add(childNode);\n    return false;\n  }\n\n  public boolean remove(AbstractEnterpriseUnit childNode) {\n    if (childNode == null) throw new NullPointerException(\"Empty argument\");\n    return this.childNodes.remove(childNode);\n  }\n\n  public List<AbstractEnterpriseUnit> getChildNodes() {\n    return this.childNodes;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\n\nabstract class AbstractUnit extends AbstractEnterpriseUnit{\n\n  private List<AbstractEnterpriseUnit> childNodes = new ArrayList<AbstractEnterpriseUnit>();\n\n  public AbstractUnit(String name) {\n    super(name);\n  }\n\n  public boolean add(AbstractEnterpriseUnit childNode) {\n    if (childNode == null) throw new NullPointerException(\"Empty argument\");\n    if (!(this.childNodes.contains(childNode))) return this.childNodes.add(childNode);\n    return false;\n  }\n\n  public boolean remove(AbstractEnterpriseUnit childNode) {\n    if (childNode == null) throw new NullPointerException(\"Empty argument\");\n    return this.childNodes.remove(childNode);\n  }\n\n  public List<AbstractEnterpriseUnit> getChildNodes() {\n    return this.childNodes;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.NullPointerException;\nimport java.lang.IllegalArgumentException;\nimport java.util.*;\n\nabstract class AbstractUnit extends AbstractEnterpriseUnit{\n\n  private List<AbstractEnterpriseUnit> childNodes = new ArrayList<AbstractEnterpriseUnit>();\n\n  public AbstractUnit(String name) {\n    super(name);\n  }\n\n  public boolean add(AbstractEnterpriseUnit childNode) {\n    if (childNode == null) throw new NullPointerException(\"Empty argument\");\n    if (!(this.childNodes.contains(childNode))) return this.childNodes.add(childNode);\n    return false;\n  }\n\n  public boolean remove(AbstractEnterpriseUnit childNode) {\n    if (childNode == null) throw new NullPointerException(\"Empty argument\");\n    return this.childNodes.remove(childNode);\n  }\n\n  public List<AbstractEnterpriseUnit> getChildNodes() {\n    return this.childNodes;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Company extends AbstractUnit {\n\n  public Company(String name) {\n    super(name);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Division extends AbstractUnit {\n\n  public Division(String name) {\n    super(name);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "interface EnterpriseNode {\n\n  public String getName();\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\n\nclass Holding extends AbstractUnit {\n\n  public Holding(String name) {\n    super(name);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\nclass StaffMember implements EnterpriseNode,Comparable<StaffMember> {\n\n  private String name;\n  private String job;\n  private Set<StaffMember> directSubordinates = new HashSet<StaffMember>();\n\n  public StaffMember(String name, String job) {\n    if (name == null) throw new NullPointerException(\"Empty argument\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    if (job == null) throw new NullPointerException(\"Empty argument\");\n    if (job == \"\") throw new IllegalArgumentException(\"Empty job\");\n    this.name = name;\n    this.job = job;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getJob() {\n    return this.job;\n  }\n\n  public boolean addDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.add(subordinate);\n  }\n\n  public boolean removeDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.remove(subordinate);\n  }\n\n  public Set<StaffMember> getDirectSubordinates() {\n    return this.directSubordinates;\n  }\n\n  @Override\n  public String toString() {\n    return this.name;\n  }\n\n  @Override\n  public int compareTo(StaffMember otherMember) {\n    return this.name.compareTo(otherMember.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\nclass StaffMember implements EnterpriseNode,Comparable<StaffMember> {\n\n  private String name;\n  private String job;\n  private Set<StaffMember> directSubordinates = new HashSet<StaffMember>();\n\n  public StaffMember(String name, String job) {\n    if (name == null) throw new NullPointerException(\"Empty argument\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    if (job == null) throw new NullPointerException(\"Empty argument\");\n    if (job == \"\") throw new IllegalArgumentException(\"Empty job\");\n    this.name = name;\n    this.job = job;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getJob() {\n    return this.job;\n  }\n\n  public boolean addDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.add(subordinate);\n  }\n\n  public boolean removeDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.remove(subordinate);\n  }\n\n  public Set<StaffMember> getDirectSubordinates() {\n    return this.directSubordinates;\n  }\n\n  @Override\n  public String toString() {\n    return this.name;\n  }\n\n  @Override\n  public int compareTo(StaffMember otherMember) {\n    return this.name.compareTo(otherMember.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\nclass StaffMember implements EnterpriseNode,Comparable<StaffMember> {\n\n  private String name;\n  private String job;\n  private Set<StaffMember> directSubordinates = new HashSet<StaffMember>();\n\n  public StaffMember(String name, String job) {\n    if (name == null) throw new NullPointerException(\"Empty argument\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    if (job == null) throw new NullPointerException(\"Empty argument\");\n    if (job == \"\") throw new IllegalArgumentException(\"Empty job\");\n    this.name = name;\n    this.job = job;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getJob() {\n    return this.job;\n  }\n\n  public boolean addDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.add(subordinate);\n  }\n\n  public boolean removeDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.remove(subordinate);\n  }\n\n  public Set<StaffMember> getDirectSubordinates() {\n    return this.directSubordinates;\n  }\n\n  @Override\n  public String toString() {\n    return this.name;\n  }\n\n  @Override\n  public int compareTo(StaffMember otherMember) {\n    return this.name.compareTo(otherMember.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\nclass StaffMember implements EnterpriseNode,Comparable<StaffMember> {\n\n  private String name;\n  private String job;\n  private Set<StaffMember> directSubordinates = new HashSet<StaffMember>();\n\n  public StaffMember(String name, String job) {\n    if (name == null) throw new NullPointerException(\"Empty argument\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    if (job == null) throw new NullPointerException(\"Empty argument\");\n    if (job == \"\") throw new IllegalArgumentException(\"Empty job\");\n    this.name = name;\n    this.job = job;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getJob() {\n    return this.job;\n  }\n\n  public boolean addDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.add(subordinate);\n  }\n\n  public boolean removeDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.remove(subordinate);\n  }\n\n  public Set<StaffMember> getDirectSubordinates() {\n    return this.directSubordinates;\n  }\n\n  @Override\n  public String toString() {\n    return this.name;\n  }\n\n  @Override\n  public int compareTo(StaffMember otherMember) {\n    return this.name.compareTo(otherMember.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\nclass StaffMember implements EnterpriseNode,Comparable<StaffMember> {\n\n  private String name;\n  private String job;\n  private Set<StaffMember> directSubordinates = new HashSet<StaffMember>();\n\n  public StaffMember(String name, String job) {\n    if (name == null) throw new NullPointerException(\"Empty argument\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    if (job == null) throw new NullPointerException(\"Empty argument\");\n    if (job == \"\") throw new IllegalArgumentException(\"Empty job\");\n    this.name = name;\n    this.job = job;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getJob() {\n    return this.job;\n  }\n\n  public boolean addDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.add(subordinate);\n  }\n\n  public boolean removeDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.remove(subordinate);\n  }\n\n  public Set<StaffMember> getDirectSubordinates() {\n    return this.directSubordinates;\n  }\n\n  @Override\n  public String toString() {\n    return this.name;\n  }\n\n  @Override\n  public int compareTo(StaffMember otherMember) {\n    return this.name.compareTo(otherMember.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\nclass StaffMember implements EnterpriseNode,Comparable<StaffMember> {\n\n  private String name;\n  private String job;\n  private Set<StaffMember> directSubordinates = new HashSet<StaffMember>();\n\n  public StaffMember(String name, String job) {\n    if (name == null) throw new NullPointerException(\"Empty argument\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    if (job == null) throw new NullPointerException(\"Empty argument\");\n    if (job == \"\") throw new IllegalArgumentException(\"Empty job\");\n    this.name = name;\n    this.job = job;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getJob() {\n    return this.job;\n  }\n\n  public boolean addDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.add(subordinate);\n  }\n\n  public boolean removeDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.remove(subordinate);\n  }\n\n  public Set<StaffMember> getDirectSubordinates() {\n    return this.directSubordinates;\n  }\n\n  @Override\n  public String toString() {\n    return this.name;\n  }\n\n  @Override\n  public int compareTo(StaffMember otherMember) {\n    return this.name.compareTo(otherMember.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": "13",
    "end_column": "13",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\nclass StaffMember implements EnterpriseNode,Comparable<StaffMember> {\n\n  private String name;\n  private String job;\n  private Set<StaffMember> directSubordinates = new HashSet<StaffMember>();\n\n  public StaffMember(String name, String job) {\n    if (name == null) throw new NullPointerException(\"Empty argument\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    if (job == null) throw new NullPointerException(\"Empty argument\");\n    if (job == \"\") throw new IllegalArgumentException(\"Empty job\");\n    this.name = name;\n    this.job = job;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getJob() {\n    return this.job;\n  }\n\n  public boolean addDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.add(subordinate);\n  }\n\n  public boolean removeDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.remove(subordinate);\n  }\n\n  public Set<StaffMember> getDirectSubordinates() {\n    return this.directSubordinates;\n  }\n\n  @Override\n  public String toString() {\n    return this.name;\n  }\n\n  @Override\n  public int compareTo(StaffMember otherMember) {\n    return this.name.compareTo(otherMember.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\nclass StaffMember implements EnterpriseNode,Comparable<StaffMember> {\n\n  private String name;\n  private String job;\n  private Set<StaffMember> directSubordinates = new HashSet<StaffMember>();\n\n  public StaffMember(String name, String job) {\n    if (name == null) throw new NullPointerException(\"Empty argument\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    if (job == null) throw new NullPointerException(\"Empty argument\");\n    if (job == \"\") throw new IllegalArgumentException(\"Empty job\");\n    this.name = name;\n    this.job = job;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getJob() {\n    return this.job;\n  }\n\n  public boolean addDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.add(subordinate);\n  }\n\n  public boolean removeDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.remove(subordinate);\n  }\n\n  public Set<StaffMember> getDirectSubordinates() {\n    return this.directSubordinates;\n  }\n\n  @Override\n  public String toString() {\n    return this.name;\n  }\n\n  @Override\n  public int compareTo(StaffMember otherMember) {\n    return this.name.compareTo(otherMember.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "34",
    "end_line": "34",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\n\nclass StaffMember implements EnterpriseNode,Comparable<StaffMember> {\n\n  private String name;\n  private String job;\n  private Set<StaffMember> directSubordinates = new HashSet<StaffMember>();\n\n  public StaffMember(String name, String job) {\n    if (name == null) throw new NullPointerException(\"Empty argument\");\n    if (name == \"\") throw new IllegalArgumentException(\"Empty name\");\n    if (job == null) throw new NullPointerException(\"Empty argument\");\n    if (job == \"\") throw new IllegalArgumentException(\"Empty job\");\n    this.name = name;\n    this.job = job;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getJob() {\n    return this.job;\n  }\n\n  public boolean addDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.add(subordinate);\n  }\n\n  public boolean removeDirectSubordinate(StaffMember subordinate) {\n    if (subordinate == null) throw new NullPointerException(\"Empty argument\");\n    return this.directSubordinates.remove(subordinate);\n  }\n\n  public Set<StaffMember> getDirectSubordinates() {\n    return this.directSubordinates;\n  }\n\n  @Override\n  public String toString() {\n    return this.name;\n  }\n\n  @Override\n  public int compareTo(StaffMember otherMember) {\n    return this.name.compareTo(otherMember.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Variable 'allMembers' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "28",
    "end_column": "28",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.NoSuchElementException;\n\nclass StaffMemberIterator implements EnterpriseNodeIterator<StaffMember> {\n\n  private int currentSize;\n  private int currentIndex;\n  public List<StaffMember> allMembers = new ArrayList<StaffMember>();\n\n  public StaffMemberIterator(Set<StaffMember> directSubordinates) {\n    Set<StaffMember> members = directSubordinates;\n    for (StaffMember member : directSubordinates) {\n      members.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n    this.currentIndex = 0;\n    this.allMembers.addAll(members);\n    this.currentSize = allMembers.size();\n    Collections.sort(this.allMembers);\n    if (!(this.allMembers.isEmpty())) {\n      System.out.println(\"Created team with members:\");\n      for (int i = 0; i < this.currentSize; i++) {\n        System.out.println(\"ID: \"+i+\" \"+this.allMembers.get(i));\n      }\n    }\n    else {\n      System.out.println(\"Created empty Team.\");\n    }\n  }\n\n  private void findSubordinatesRecursively(StaffMember m) {\n    Set<StaffMember> plebs = m.getDirectSubordinates();\n    if (plebs.isEmpty()) return;\n    for (StaffMember member : plebs) {\n      this.allMembers.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (this.currentSize == 0) return false;\n    if (this.currentIndex < this.currentSize) {\n      return true;\n    }\n    else\n      return false;\n  }\n\n  @Override\n  public StaffMember next() {\n    if (allMembers.isEmpty()) throw new NoSuchElementException(\"No such element\");\n    if (this.currentIndex >= this.currentSize) throw new NoSuchElementException(\"No such element\");\n    return this.allMembers.get(currentIndex++);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.NoSuchElementException;\n\nclass StaffMemberIterator implements EnterpriseNodeIterator<StaffMember> {\n\n  private int currentSize;\n  private int currentIndex;\n  public List<StaffMember> allMembers = new ArrayList<StaffMember>();\n\n  public StaffMemberIterator(Set<StaffMember> directSubordinates) {\n    Set<StaffMember> members = directSubordinates;\n    for (StaffMember member : directSubordinates) {\n      members.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n    this.currentIndex = 0;\n    this.allMembers.addAll(members);\n    this.currentSize = allMembers.size();\n    Collections.sort(this.allMembers);\n    if (!(this.allMembers.isEmpty())) {\n      System.out.println(\"Created team with members:\");\n      for (int i = 0; i < this.currentSize; i++) {\n        System.out.println(\"ID: \"+i+\" \"+this.allMembers.get(i));\n      }\n    }\n    else {\n      System.out.println(\"Created empty Team.\");\n    }\n  }\n\n  private void findSubordinatesRecursively(StaffMember m) {\n    Set<StaffMember> plebs = m.getDirectSubordinates();\n    if (plebs.isEmpty()) return;\n    for (StaffMember member : plebs) {\n      this.allMembers.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (this.currentSize == 0) return false;\n    if (this.currentIndex < this.currentSize) {\n      return true;\n    }\n    else\n      return false;\n  }\n\n  @Override\n  public StaffMember next() {\n    if (allMembers.isEmpty()) throw new NoSuchElementException(\"No such element\");\n    if (this.currentIndex >= this.currentSize) throw new NoSuchElementException(\"No such element\");\n    return this.allMembers.get(currentIndex++);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.NoSuchElementException;\n\nclass StaffMemberIterator implements EnterpriseNodeIterator<StaffMember> {\n\n  private int currentSize;\n  private int currentIndex;\n  public List<StaffMember> allMembers = new ArrayList<StaffMember>();\n\n  public StaffMemberIterator(Set<StaffMember> directSubordinates) {\n    Set<StaffMember> members = directSubordinates;\n    for (StaffMember member : directSubordinates) {\n      members.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n    this.currentIndex = 0;\n    this.allMembers.addAll(members);\n    this.currentSize = allMembers.size();\n    Collections.sort(this.allMembers);\n    if (!(this.allMembers.isEmpty())) {\n      System.out.println(\"Created team with members:\");\n      for (int i = 0; i < this.currentSize; i++) {\n        System.out.println(\"ID: \"+i+\" \"+this.allMembers.get(i));\n      }\n    }\n    else {\n      System.out.println(\"Created empty Team.\");\n    }\n  }\n\n  private void findSubordinatesRecursively(StaffMember m) {\n    Set<StaffMember> plebs = m.getDirectSubordinates();\n    if (plebs.isEmpty()) return;\n    for (StaffMember member : plebs) {\n      this.allMembers.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (this.currentSize == 0) return false;\n    if (this.currentIndex < this.currentSize) {\n      return true;\n    }\n    else\n      return false;\n  }\n\n  @Override\n  public StaffMember next() {\n    if (allMembers.isEmpty()) throw new NoSuchElementException(\"No such element\");\n    if (this.currentIndex >= this.currentSize) throw new NoSuchElementException(\"No such element\");\n    return this.allMembers.get(currentIndex++);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "42",
    "end_line": "42",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.NoSuchElementException;\n\nclass StaffMemberIterator implements EnterpriseNodeIterator<StaffMember> {\n\n  private int currentSize;\n  private int currentIndex;\n  public List<StaffMember> allMembers = new ArrayList<StaffMember>();\n\n  public StaffMemberIterator(Set<StaffMember> directSubordinates) {\n    Set<StaffMember> members = directSubordinates;\n    for (StaffMember member : directSubordinates) {\n      members.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n    this.currentIndex = 0;\n    this.allMembers.addAll(members);\n    this.currentSize = allMembers.size();\n    Collections.sort(this.allMembers);\n    if (!(this.allMembers.isEmpty())) {\n      System.out.println(\"Created team with members:\");\n      for (int i = 0; i < this.currentSize; i++) {\n        System.out.println(\"ID: \"+i+\" \"+this.allMembers.get(i));\n      }\n    }\n    else {\n      System.out.println(\"Created empty Team.\");\n    }\n  }\n\n  private void findSubordinatesRecursively(StaffMember m) {\n    Set<StaffMember> plebs = m.getDirectSubordinates();\n    if (plebs.isEmpty()) return;\n    for (StaffMember member : plebs) {\n      this.allMembers.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (this.currentSize == 0) return false;\n    if (this.currentIndex < this.currentSize) {\n      return true;\n    }\n    else\n      return false;\n  }\n\n  @Override\n  public StaffMember next() {\n    if (allMembers.isEmpty()) throw new NoSuchElementException(\"No such element\");\n    if (this.currentIndex >= this.currentSize) throw new NoSuchElementException(\"No such element\");\n    return this.allMembers.get(currentIndex++);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Conditional logic can be removed.",
    "priority": "error",
    "start_line": "43",
    "end_line": "43",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "SimplifyBooleanReturn",
      "explanation": "Over complicated boolean return statements are hard to understand and should be simplified.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.NoSuchElementException;\n\nclass StaffMemberIterator implements EnterpriseNodeIterator<StaffMember> {\n\n  private int currentSize;\n  private int currentIndex;\n  public List<StaffMember> allMembers = new ArrayList<StaffMember>();\n\n  public StaffMemberIterator(Set<StaffMember> directSubordinates) {\n    Set<StaffMember> members = directSubordinates;\n    for (StaffMember member : directSubordinates) {\n      members.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n    this.currentIndex = 0;\n    this.allMembers.addAll(members);\n    this.currentSize = allMembers.size();\n    Collections.sort(this.allMembers);\n    if (!(this.allMembers.isEmpty())) {\n      System.out.println(\"Created team with members:\");\n      for (int i = 0; i < this.currentSize; i++) {\n        System.out.println(\"ID: \"+i+\" \"+this.allMembers.get(i));\n      }\n    }\n    else {\n      System.out.println(\"Created empty Team.\");\n    }\n  }\n\n  private void findSubordinatesRecursively(StaffMember m) {\n    Set<StaffMember> plebs = m.getDirectSubordinates();\n    if (plebs.isEmpty()) return;\n    for (StaffMember member : plebs) {\n      this.allMembers.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (this.currentSize == 0) return false;\n    if (this.currentIndex < this.currentSize) {\n      return true;\n    }\n    else\n      return false;\n  }\n\n  @Override\n  public StaffMember next() {\n    if (allMembers.isEmpty()) throw new NoSuchElementException(\"No such element\");\n    if (this.currentIndex >= this.currentSize) throw new NoSuchElementException(\"No such element\");\n    return this.allMembers.get(currentIndex++);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "46",
    "end_line": "46",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.NoSuchElementException;\n\nclass StaffMemberIterator implements EnterpriseNodeIterator<StaffMember> {\n\n  private int currentSize;\n  private int currentIndex;\n  public List<StaffMember> allMembers = new ArrayList<StaffMember>();\n\n  public StaffMemberIterator(Set<StaffMember> directSubordinates) {\n    Set<StaffMember> members = directSubordinates;\n    for (StaffMember member : directSubordinates) {\n      members.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n    this.currentIndex = 0;\n    this.allMembers.addAll(members);\n    this.currentSize = allMembers.size();\n    Collections.sort(this.allMembers);\n    if (!(this.allMembers.isEmpty())) {\n      System.out.println(\"Created team with members:\");\n      for (int i = 0; i < this.currentSize; i++) {\n        System.out.println(\"ID: \"+i+\" \"+this.allMembers.get(i));\n      }\n    }\n    else {\n      System.out.println(\"Created empty Team.\");\n    }\n  }\n\n  private void findSubordinatesRecursively(StaffMember m) {\n    Set<StaffMember> plebs = m.getDirectSubordinates();\n    if (plebs.isEmpty()) return;\n    for (StaffMember member : plebs) {\n      this.allMembers.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (this.currentSize == 0) return false;\n    if (this.currentIndex < this.currentSize) {\n      return true;\n    }\n    else\n      return false;\n  }\n\n  @Override\n  public StaffMember next() {\n    if (allMembers.isEmpty()) throw new NoSuchElementException(\"No such element\");\n    if (this.currentIndex >= this.currentSize) throw new NoSuchElementException(\"No such element\");\n    return this.allMembers.get(currentIndex++);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "52",
    "end_line": "52",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.NoSuchElementException;\n\nclass StaffMemberIterator implements EnterpriseNodeIterator<StaffMember> {\n\n  private int currentSize;\n  private int currentIndex;\n  public List<StaffMember> allMembers = new ArrayList<StaffMember>();\n\n  public StaffMemberIterator(Set<StaffMember> directSubordinates) {\n    Set<StaffMember> members = directSubordinates;\n    for (StaffMember member : directSubordinates) {\n      members.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n    this.currentIndex = 0;\n    this.allMembers.addAll(members);\n    this.currentSize = allMembers.size();\n    Collections.sort(this.allMembers);\n    if (!(this.allMembers.isEmpty())) {\n      System.out.println(\"Created team with members:\");\n      for (int i = 0; i < this.currentSize; i++) {\n        System.out.println(\"ID: \"+i+\" \"+this.allMembers.get(i));\n      }\n    }\n    else {\n      System.out.println(\"Created empty Team.\");\n    }\n  }\n\n  private void findSubordinatesRecursively(StaffMember m) {\n    Set<StaffMember> plebs = m.getDirectSubordinates();\n    if (plebs.isEmpty()) return;\n    for (StaffMember member : plebs) {\n      this.allMembers.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (this.currentSize == 0) return false;\n    if (this.currentIndex < this.currentSize) {\n      return true;\n    }\n    else\n      return false;\n  }\n\n  @Override\n  public StaffMember next() {\n    if (allMembers.isEmpty()) throw new NoSuchElementException(\"No such element\");\n    if (this.currentIndex >= this.currentSize) throw new NoSuchElementException(\"No such element\");\n    return this.allMembers.get(currentIndex++);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "53",
    "end_line": "53",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.util.NoSuchElementException;\n\nclass StaffMemberIterator implements EnterpriseNodeIterator<StaffMember> {\n\n  private int currentSize;\n  private int currentIndex;\n  public List<StaffMember> allMembers = new ArrayList<StaffMember>();\n\n  public StaffMemberIterator(Set<StaffMember> directSubordinates) {\n    Set<StaffMember> members = directSubordinates;\n    for (StaffMember member : directSubordinates) {\n      members.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n    this.currentIndex = 0;\n    this.allMembers.addAll(members);\n    this.currentSize = allMembers.size();\n    Collections.sort(this.allMembers);\n    if (!(this.allMembers.isEmpty())) {\n      System.out.println(\"Created team with members:\");\n      for (int i = 0; i < this.currentSize; i++) {\n        System.out.println(\"ID: \"+i+\" \"+this.allMembers.get(i));\n      }\n    }\n    else {\n      System.out.println(\"Created empty Team.\");\n    }\n  }\n\n  private void findSubordinatesRecursively(StaffMember m) {\n    Set<StaffMember> plebs = m.getDirectSubordinates();\n    if (plebs.isEmpty()) return;\n    for (StaffMember member : plebs) {\n      this.allMembers.add(member);\n      this.findSubordinatesRecursively(member);\n    }\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (this.currentSize == 0) return false;\n    if (this.currentIndex < this.currentSize) {\n      return true;\n    }\n    else\n      return false;\n  }\n\n  @Override\n  public StaffMember next() {\n    if (allMembers.isEmpty()) throw new NoSuchElementException(\"No such element\");\n    if (this.currentIndex >= this.currentSize) throw new NoSuchElementException(\"No such element\");\n    return this.allMembers.get(currentIndex++);\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Variable 'teamLeader' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.*;\n\nclass Team extends AbstractEnterpriseUnit {\n\n  StaffMember teamLeader;\n\n  public Team(String name, StaffMember teamLeader) {\n    super(name);\n    if (teamLeader == null) throw new NullPointerException(\"Empty argument\");\n    this.teamLeader = teamLeader;\n  }\n\n  public StaffMember getTeamLeader() {\n    return this.teamLeader;\n  }\n\n  public List<StaffMember> getTeamMembers() {\n    StaffMemberIterator iterator = new StaffMemberIterator(this.teamLeader.getDirectSubordinates());\n    List<StaffMember> all = iterator.allMembers;\n    all.add(this.teamLeader);\n    Collections.sort(all);\n    return all;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.*;\n\nclass Team extends AbstractEnterpriseUnit {\n\n  StaffMember teamLeader;\n\n  public Team(String name, StaffMember teamLeader) {\n    super(name);\n    if (teamLeader == null) throw new NullPointerException(\"Empty argument\");\n    this.teamLeader = teamLeader;\n  }\n\n  public StaffMember getTeamLeader() {\n    return this.teamLeader;\n  }\n\n  public List<StaffMember> getTeamMembers() {\n    StaffMemberIterator iterator = new StaffMemberIterator(this.teamLeader.getDirectSubordinates());\n    List<StaffMember> all = iterator.allMembers;\n    all.add(this.teamLeader);\n    Collections.sort(all);\n    return all;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Enterprise Node",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.*;\n\nclass Team extends AbstractEnterpriseUnit {\n\n  StaffMember teamLeader;\n\n  public Team(String name, StaffMember teamLeader) {\n    super(name);\n    if (teamLeader == null) throw new NullPointerException(\"Empty argument\");\n    this.teamLeader = teamLeader;\n  }\n\n  public StaffMember getTeamLeader() {\n    return this.teamLeader;\n  }\n\n  public List<StaffMember> getTeamMembers() {\n    StaffMemberIterator iterator = new StaffMemberIterator(this.teamLeader.getDirectSubordinates());\n    List<StaffMember> all = iterator.allMembers;\n    all.add(this.teamLeader);\n    Collections.sort(all);\n    return all;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "Variable 'forename' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "2",
    "end_line": "2",
    "start_column": "10",
    "end_column": "10",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "class Human {\n  String forename;\n  String name;\n\n  public Human(String forename, String name) {\n    this.forename = forename;\n    this.name = name;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getForename() {\n    return this.forename;\n  }\n\n  @Override public String toString() {\n    return String.format(\"%s %s\", this.getForename(), this.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "Variable 'name' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "10",
    "end_column": "10",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "class Human {\n  String forename;\n  String name;\n\n  public Human(String forename, String name) {\n    this.forename = forename;\n    this.name = name;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getForename() {\n    return this.forename;\n  }\n\n  @Override public String toString() {\n    return String.format(\"%s %s\", this.getForename(), this.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Human {\n  String forename;\n  String name;\n\n  public Human(String forename, String name) {\n    this.forename = forename;\n    this.name = name;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getForename() {\n    return this.forename;\n  }\n\n  @Override public String toString() {\n    return String.format(\"%s %s\", this.getForename(), this.getName());\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "Variable 'driver' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "9",
    "end_column": "9",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Taxi {\n  Human driver;\n  List<Human> passengers = new ArrayList<Human>();\n  int maxpassengers = 4;\n\n  public Taxi(Human driver) {\n    this.driver = driver;\n  }\n\n  public String getDriverName() {\n    return this.driver.toString();\n  }\n\n  public void add(Human x) {\n    if (this.passengers.size() < this.maxpassengers) {\n      this.passengers.add(x);\n      System.out.println(x.toString()+\" gets in.\");\n    }\n    else {\n      System.out.println(\"We are sorry, \"+x.toString()+\". The taxi is full.\");\n    }\n  }\n\n  @Override public String toString() {\n    if (this.passengers.size() == 0) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes nobody along.\");\n    }\n    if (this.passengers.size() == 1) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 2) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" and \"+this.passengers.get(1).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 3) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\" and \"+this.passengers.get(2).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 4) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\", \"+this.passengers.get(2).toString()+\" and \"+this.passengers.get(3).toString()+\" along.\");\n    }\n    return String.format(\"Here be dragons\");\n  }\n\n  public Human[] allGetOut() {\n    Human[] output = new Human[this.passengers.size()];\n    output = this.passengers.toArray(output);\n    this.passengers.clear();\n    return output;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "Variable 'passengers' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Taxi {\n  Human driver;\n  List<Human> passengers = new ArrayList<Human>();\n  int maxpassengers = 4;\n\n  public Taxi(Human driver) {\n    this.driver = driver;\n  }\n\n  public String getDriverName() {\n    return this.driver.toString();\n  }\n\n  public void add(Human x) {\n    if (this.passengers.size() < this.maxpassengers) {\n      this.passengers.add(x);\n      System.out.println(x.toString()+\" gets in.\");\n    }\n    else {\n      System.out.println(\"We are sorry, \"+x.toString()+\". The taxi is full.\");\n    }\n  }\n\n  @Override public String toString() {\n    if (this.passengers.size() == 0) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes nobody along.\");\n    }\n    if (this.passengers.size() == 1) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 2) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" and \"+this.passengers.get(1).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 3) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\" and \"+this.passengers.get(2).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 4) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\", \"+this.passengers.get(2).toString()+\" and \"+this.passengers.get(3).toString()+\" along.\");\n    }\n    return String.format(\"Here be dragons\");\n  }\n\n  public Human[] allGetOut() {\n    Human[] output = new Human[this.passengers.size()];\n    output = this.passengers.toArray(output);\n    this.passengers.clear();\n    return output;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "Variable 'maxpassengers' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "7",
    "end_column": "7",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Taxi {\n  Human driver;\n  List<Human> passengers = new ArrayList<Human>();\n  int maxpassengers = 4;\n\n  public Taxi(Human driver) {\n    this.driver = driver;\n  }\n\n  public String getDriverName() {\n    return this.driver.toString();\n  }\n\n  public void add(Human x) {\n    if (this.passengers.size() < this.maxpassengers) {\n      this.passengers.add(x);\n      System.out.println(x.toString()+\" gets in.\");\n    }\n    else {\n      System.out.println(\"We are sorry, \"+x.toString()+\". The taxi is full.\");\n    }\n  }\n\n  @Override public String toString() {\n    if (this.passengers.size() == 0) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes nobody along.\");\n    }\n    if (this.passengers.size() == 1) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 2) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" and \"+this.passengers.get(1).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 3) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\" and \"+this.passengers.get(2).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 4) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\", \"+this.passengers.get(2).toString()+\" and \"+this.passengers.get(3).toString()+\" along.\");\n    }\n    return String.format(\"Here be dragons\");\n  }\n\n  public Human[] allGetOut() {\n    Human[] output = new Human[this.passengers.size()];\n    output = this.passengers.toArray(output);\n    this.passengers.clear();\n    return output;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "'4' is a magic number.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "23",
    "end_column": "23",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Taxi {\n  Human driver;\n  List<Human> passengers = new ArrayList<Human>();\n  int maxpassengers = 4;\n\n  public Taxi(Human driver) {\n    this.driver = driver;\n  }\n\n  public String getDriverName() {\n    return this.driver.toString();\n  }\n\n  public void add(Human x) {\n    if (this.passengers.size() < this.maxpassengers) {\n      this.passengers.add(x);\n      System.out.println(x.toString()+\" gets in.\");\n    }\n    else {\n      System.out.println(\"We are sorry, \"+x.toString()+\". The taxi is full.\");\n    }\n  }\n\n  @Override public String toString() {\n    if (this.passengers.size() == 0) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes nobody along.\");\n    }\n    if (this.passengers.size() == 1) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 2) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" and \"+this.passengers.get(1).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 3) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\" and \"+this.passengers.get(2).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 4) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\", \"+this.passengers.get(2).toString()+\" and \"+this.passengers.get(3).toString()+\" along.\");\n    }\n    return String.format(\"Here be dragons\");\n  }\n\n  public Human[] allGetOut() {\n    Human[] output = new Human[this.passengers.size()];\n    output = this.passengers.toArray(output);\n    this.passengers.clear();\n    return output;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Taxi {\n  Human driver;\n  List<Human> passengers = new ArrayList<Human>();\n  int maxpassengers = 4;\n\n  public Taxi(Human driver) {\n    this.driver = driver;\n  }\n\n  public String getDriverName() {\n    return this.driver.toString();\n  }\n\n  public void add(Human x) {\n    if (this.passengers.size() < this.maxpassengers) {\n      this.passengers.add(x);\n      System.out.println(x.toString()+\" gets in.\");\n    }\n    else {\n      System.out.println(\"We are sorry, \"+x.toString()+\". The taxi is full.\");\n    }\n  }\n\n  @Override public String toString() {\n    if (this.passengers.size() == 0) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes nobody along.\");\n    }\n    if (this.passengers.size() == 1) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 2) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" and \"+this.passengers.get(1).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 3) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\" and \"+this.passengers.get(2).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 4) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\", \"+this.passengers.get(2).toString()+\" and \"+this.passengers.get(3).toString()+\" along.\");\n    }\n    return String.format(\"Here be dragons\");\n  }\n\n  public Human[] allGetOut() {\n    Human[] output = new Human[this.passengers.size()];\n    output = this.passengers.toArray(output);\n    this.passengers.clear();\n    return output;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "'3' is a magic number.",
    "priority": "error",
    "start_line": "37",
    "end_line": "37",
    "start_column": "35",
    "end_column": "35",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Taxi {\n  Human driver;\n  List<Human> passengers = new ArrayList<Human>();\n  int maxpassengers = 4;\n\n  public Taxi(Human driver) {\n    this.driver = driver;\n  }\n\n  public String getDriverName() {\n    return this.driver.toString();\n  }\n\n  public void add(Human x) {\n    if (this.passengers.size() < this.maxpassengers) {\n      this.passengers.add(x);\n      System.out.println(x.toString()+\" gets in.\");\n    }\n    else {\n      System.out.println(\"We are sorry, \"+x.toString()+\". The taxi is full.\");\n    }\n  }\n\n  @Override public String toString() {\n    if (this.passengers.size() == 0) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes nobody along.\");\n    }\n    if (this.passengers.size() == 1) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 2) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" and \"+this.passengers.get(1).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 3) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\" and \"+this.passengers.get(2).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 4) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\", \"+this.passengers.get(2).toString()+\" and \"+this.passengers.get(3).toString()+\" along.\");\n    }\n    return String.format(\"Here be dragons\");\n  }\n\n  public Human[] allGetOut() {\n    Human[] output = new Human[this.passengers.size()];\n    output = this.passengers.toArray(output);\n    this.passengers.clear();\n    return output;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "'4' is a magic number.",
    "priority": "error",
    "start_line": "40",
    "end_line": "40",
    "start_column": "35",
    "end_column": "35",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Taxi {\n  Human driver;\n  List<Human> passengers = new ArrayList<Human>();\n  int maxpassengers = 4;\n\n  public Taxi(Human driver) {\n    this.driver = driver;\n  }\n\n  public String getDriverName() {\n    return this.driver.toString();\n  }\n\n  public void add(Human x) {\n    if (this.passengers.size() < this.maxpassengers) {\n      this.passengers.add(x);\n      System.out.println(x.toString()+\" gets in.\");\n    }\n    else {\n      System.out.println(\"We are sorry, \"+x.toString()+\". The taxi is full.\");\n    }\n  }\n\n  @Override public String toString() {\n    if (this.passengers.size() == 0) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes nobody along.\");\n    }\n    if (this.passengers.size() == 1) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 2) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" and \"+this.passengers.get(1).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 3) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\" and \"+this.passengers.get(2).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 4) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\", \"+this.passengers.get(2).toString()+\" and \"+this.passengers.get(3).toString()+\" along.\");\n    }\n    return String.format(\"Here be dragons\");\n  }\n\n  public Human[] allGetOut() {\n    Human[] output = new Human[this.passengers.size()];\n    output = this.passengers.toArray(output);\n    this.passengers.clear();\n    return output;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Classes and Objects (Taxi)",
    "message": "'3' is a magic number.",
    "priority": "error",
    "start_line": "41",
    "end_line": "41",
    "start_column": "228",
    "end_column": "228",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Taxi {\n  Human driver;\n  List<Human> passengers = new ArrayList<Human>();\n  int maxpassengers = 4;\n\n  public Taxi(Human driver) {\n    this.driver = driver;\n  }\n\n  public String getDriverName() {\n    return this.driver.toString();\n  }\n\n  public void add(Human x) {\n    if (this.passengers.size() < this.maxpassengers) {\n      this.passengers.add(x);\n      System.out.println(x.toString()+\" gets in.\");\n    }\n    else {\n      System.out.println(\"We are sorry, \"+x.toString()+\". The taxi is full.\");\n    }\n  }\n\n  @Override public String toString() {\n    if (this.passengers.size() == 0) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes nobody along.\");\n    }\n    if (this.passengers.size() == 1) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 2) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\" and \"+this.passengers.get(1).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 3) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\" and \"+this.passengers.get(2).toString()+\" along.\");\n    }\n    if (this.passengers.size() == 4) {\n      return String.format(\"This is the taxi of \"+this.driver.toString()+\". He takes \"+this.passengers.get(0).toString()+\", \"+this.passengers.get(1).toString()+\", \"+this.passengers.get(2).toString()+\" and \"+this.passengers.get(3).toString()+\" along.\");\n    }\n    return String.format(\"Here be dragons\");\n  }\n\n  public Human[] allGetOut() {\n    Human[] output = new Human[this.passengers.size()];\n    output = this.passengers.toArray(output);\n    this.passengers.clear();\n    return output;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Collections I",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Book implements Comparable<Book> {\n\n  private String title = \"\";\n  private String author = \"\";\n  private String isbn;\n\n  public Book(String isbn, String author, String title) {\n    this.title = title;\n    this.author = author;\n    this.isbn = isbn;\n    System.out.println(\"Book \"+title+\" by \"+author+\" created.\");\n  }\n\n  public Book(String isbn) {\n    this.isbn = isbn;\n    System.out.println(\"Book with ISBN \"+isbn+\" created.\");\n  }\n\n  public String getIsbn() {\n    return this.isbn;\n  }\n\n  public String getAuthor() {\n    return this.author;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n  @Override public int compareTo(Book book) {\n    int bookIsbn = Integer.parseInt(book.getIsbn());\n    int thisIsbn = Integer.parseInt(this.getIsbn());\n    if (bookIsbn == thisIsbn)\n      return 0;\n    else\n      return thisIsbn - bookIsbn;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections I",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Book implements Comparable<Book> {\n\n  private String title = \"\";\n  private String author = \"\";\n  private String isbn;\n\n  public Book(String isbn, String author, String title) {\n    this.title = title;\n    this.author = author;\n    this.isbn = isbn;\n    System.out.println(\"Book \"+title+\" by \"+author+\" created.\");\n  }\n\n  public Book(String isbn) {\n    this.isbn = isbn;\n    System.out.println(\"Book with ISBN \"+isbn+\" created.\");\n  }\n\n  public String getIsbn() {\n    return this.isbn;\n  }\n\n  public String getAuthor() {\n    return this.author;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n  @Override public int compareTo(Book book) {\n    int bookIsbn = Integer.parseInt(book.getIsbn());\n    int thisIsbn = Integer.parseInt(this.getIsbn());\n    if (bookIsbn == thisIsbn)\n      return 0;\n    else\n      return thisIsbn - bookIsbn;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections I",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "40",
    "end_line": "40",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Book implements Comparable<Book> {\n\n  private String title = \"\";\n  private String author = \"\";\n  private String isbn;\n\n  public Book(String isbn, String author, String title) {\n    this.title = title;\n    this.author = author;\n    this.isbn = isbn;\n    System.out.println(\"Book \"+title+\" by \"+author+\" created.\");\n  }\n\n  public Book(String isbn) {\n    this.isbn = isbn;\n    System.out.println(\"Book with ISBN \"+isbn+\" created.\");\n  }\n\n  public String getIsbn() {\n    return this.isbn;\n  }\n\n  public String getAuthor() {\n    return this.author;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n  @Override public int compareTo(Book book) {\n    int bookIsbn = Integer.parseInt(book.getIsbn());\n    int thisIsbn = Integer.parseInt(this.getIsbn());\n    if (bookIsbn == thisIsbn)\n      return 0;\n    else\n      return thisIsbn - bookIsbn;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections I",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "42",
    "end_line": "42",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Book implements Comparable<Book> {\n\n  private String title = \"\";\n  private String author = \"\";\n  private String isbn;\n\n  public Book(String isbn, String author, String title) {\n    this.title = title;\n    this.author = author;\n    this.isbn = isbn;\n    System.out.println(\"Book \"+title+\" by \"+author+\" created.\");\n  }\n\n  public Book(String isbn) {\n    this.isbn = isbn;\n    System.out.println(\"Book with ISBN \"+isbn+\" created.\");\n  }\n\n  public String getIsbn() {\n    return this.isbn;\n  }\n\n  public String getAuthor() {\n    return this.author;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n  @Override public int compareTo(Book book) {\n    int bookIsbn = Integer.parseInt(book.getIsbn());\n    int thisIsbn = Integer.parseInt(this.getIsbn());\n    if (bookIsbn == thisIsbn)\n      return 0;\n    else\n      return thisIsbn - bookIsbn;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections I",
    "message": "Variable 'stock' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Library {\n\n  List<Book> stock = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library!\");\n  }\n\n  public void sortedInsertion (Book newBook) {\n    Book add_this_book = newBook;\n    System.out.println(\"I added the book \"+newBook.getTitle()+\"!\");\n    this.stock.add(add_this_book);\n    Collections.sort(this.stock);\n  }\n\n  public Book searchForIsbn(String isbn) {\n    Book b = new Book(isbn);\n    int search = Collections.binarySearch(this.stock, b, new BookComparator());\n    if (search >= 0)\n      return this.stock.get(search);\n    return null;\n  }\n\n  public List<Book> searchForAuthor(String author) {\n    List<Book> output = new ArrayList<Book>();\n    for (Book b : this.stock) {\n      if (b.getAuthor() == author)\n        output.add(b);\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections I",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Library {\n\n  List<Book> stock = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library!\");\n  }\n\n  public void sortedInsertion (Book newBook) {\n    Book add_this_book = newBook;\n    System.out.println(\"I added the book \"+newBook.getTitle()+\"!\");\n    this.stock.add(add_this_book);\n    Collections.sort(this.stock);\n  }\n\n  public Book searchForIsbn(String isbn) {\n    Book b = new Book(isbn);\n    int search = Collections.binarySearch(this.stock, b, new BookComparator());\n    if (search >= 0)\n      return this.stock.get(search);\n    return null;\n  }\n\n  public List<Book> searchForAuthor(String author) {\n    List<Book> output = new ArrayList<Book>();\n    for (Book b : this.stock) {\n      if (b.getAuthor() == author)\n        output.add(b);\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections I",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Library {\n\n  List<Book> stock = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library!\");\n  }\n\n  public void sortedInsertion (Book newBook) {\n    Book add_this_book = newBook;\n    System.out.println(\"I added the book \"+newBook.getTitle()+\"!\");\n    this.stock.add(add_this_book);\n    Collections.sort(this.stock);\n  }\n\n  public Book searchForIsbn(String isbn) {\n    Book b = new Book(isbn);\n    int search = Collections.binarySearch(this.stock, b, new BookComparator());\n    if (search >= 0)\n      return this.stock.get(search);\n    return null;\n  }\n\n  public List<Book> searchForAuthor(String author) {\n    List<Book> output = new ArrayList<Book>();\n    for (Book b : this.stock) {\n      if (b.getAuthor() == author)\n        output.add(b);\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections I",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Library {\n\n  List<Book> stock = new ArrayList<Book>();\n\n  public Library() {\n    System.out.println(\"Hello, I am a library!\");\n  }\n\n  public void sortedInsertion (Book newBook) {\n    Book add_this_book = newBook;\n    System.out.println(\"I added the book \"+newBook.getTitle()+\"!\");\n    this.stock.add(add_this_book);\n    Collections.sort(this.stock);\n  }\n\n  public Book searchForIsbn(String isbn) {\n    Book b = new Book(isbn);\n    int search = Collections.binarySearch(this.stock, b, new BookComparator());\n    if (search >= 0)\n      return this.stock.get(search);\n    return null;\n  }\n\n  public List<Book> searchForAuthor(String author) {\n    List<Book> output = new ArrayList<Book>();\n    for (Book b : this.stock) {\n      if (b.getAuthor() == author)\n        output.add(b);\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'12' is a magic number.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "26",
    "end_column": "26",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Application {\n\n  public static void main(String[] args) {\n    Application application = new Application();\n    application.run();\n  }\n\n  public void run() {\n    Inhabitant george = new Serf();\n    for (int i = 0; i <= 12; i++) {\n    george.setIncome(i);\n    System.out.printf(\"Tax: %d\\n\",george.taxableIncome());\n    }\n    george.setIncome(13);\n    System.out.printf(\"Tax: %d\\n\",george.taxableIncome());\n    george.setIncome(20);\n    System.out.printf(\"Tax: %d\\n\",george.taxableIncome());\n\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'13' is a magic number.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": "22",
    "end_column": "22",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Application {\n\n  public static void main(String[] args) {\n    Application application = new Application();\n    application.run();\n  }\n\n  public void run() {\n    Inhabitant george = new Serf();\n    for (int i = 0; i <= 12; i++) {\n    george.setIncome(i);\n    System.out.printf(\"Tax: %d\\n\",george.taxableIncome());\n    }\n    george.setIncome(13);\n    System.out.printf(\"Tax: %d\\n\",george.taxableIncome());\n    george.setIncome(20);\n    System.out.printf(\"Tax: %d\\n\",george.taxableIncome());\n\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'20' is a magic number.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": "22",
    "end_column": "22",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Application {\n\n  public static void main(String[] args) {\n    Application application = new Application();\n    application.run();\n  }\n\n  public void run() {\n    Inhabitant george = new Serf();\n    for (int i = 0; i <= 12; i++) {\n    george.setIncome(i);\n    System.out.printf(\"Tax: %d\\n\",george.taxableIncome());\n    }\n    george.setIncome(13);\n    System.out.printf(\"Tax: %d\\n\",george.taxableIncome());\n    george.setIncome(20);\n    System.out.printf(\"Tax: %d\\n\",george.taxableIncome());\n\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "Variable 'income' explicitly initialized to '0' (default value for its type).",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "21",
    "end_column": "21",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "class Inhabitant {\n\n  public static int income = 0;\n\n  public int taxableIncome() {\n    return income;\n  }\n\n  public int tax() {\n    int tax = taxableIncome()/10;\n    if (tax <= 1)\n      return 1;\n    else\n      return tax;\n  }\n\n  public void setIncome(int setincome) {\n    income = setincome;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "Variable 'income' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "21",
    "end_column": "21",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "class Inhabitant {\n\n  public static int income = 0;\n\n  public int taxableIncome() {\n    return income;\n  }\n\n  public int tax() {\n    int tax = taxableIncome()/10;\n    if (tax <= 1)\n      return 1;\n    else\n      return tax;\n  }\n\n  public void setIncome(int setincome) {\n    income = setincome;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'10' is a magic number.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Inhabitant {\n\n  public static int income = 0;\n\n  public int taxableIncome() {\n    return income;\n  }\n\n  public int tax() {\n    int tax = taxableIncome()/10;\n    if (tax <= 1)\n      return 1;\n    else\n      return tax;\n  }\n\n  public void setIncome(int setincome) {\n    income = setincome;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Inhabitant {\n\n  public static int income = 0;\n\n  public int taxableIncome() {\n    return income;\n  }\n\n  public int tax() {\n    int tax = taxableIncome()/10;\n    if (tax <= 1)\n      return 1;\n    else\n      return tax;\n  }\n\n  public void setIncome(int setincome) {\n    income = setincome;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Inhabitant {\n\n  public static int income = 0;\n\n  public int taxableIncome() {\n    return income;\n  }\n\n  public int tax() {\n    int tax = taxableIncome()/10;\n    if (tax <= 1)\n      return 1;\n    else\n      return tax;\n  }\n\n  public void setIncome(int setincome) {\n    income = setincome;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'10' is a magic number.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "36",
    "end_column": "36",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Noble extends Inhabitant {\n  @Override\n  public int tax() {\n    int tax = this.taxableIncome()/10;\n    if (tax <= 20)\n      return 20;\n    else\n      return tax;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Noble extends Inhabitant {\n  @Override\n  public int tax() {\n    int tax = this.taxableIncome()/10;\n    if (tax <= 20)\n      return 20;\n    else\n      return tax;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'20' is a magic number.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "16",
    "end_column": "16",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Noble extends Inhabitant {\n  @Override\n  public int tax() {\n    int tax = this.taxableIncome()/10;\n    if (tax <= 20)\n      return 20;\n    else\n      return tax;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'20' is a magic number.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Noble extends Inhabitant {\n  @Override\n  public int tax() {\n    int tax = this.taxableIncome()/10;\n    if (tax <= 20)\n      return 20;\n    else\n      return tax;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Noble extends Inhabitant {\n  @Override\n  public int tax() {\n    int tax = this.taxableIncome()/10;\n    if (tax <= 20)\n      return 20;\n    else\n      return tax;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Serf extends Peasant {\n  @Override\n  public int taxableIncome() {\n    if (income <= 12)\n      return 0;\n    else\n      return income - 12;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'12' is a magic number.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "19",
    "end_column": "19",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Serf extends Peasant {\n  @Override\n  public int taxableIncome() {\n    if (income <= 12)\n      return 0;\n    else\n      return income - 12;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Serf extends Peasant {\n  @Override\n  public int taxableIncome() {\n    if (income <= 12)\n      return 0;\n    else\n      return income - 12;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Inheritance",
    "message": "'12' is a magic number.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "23",
    "end_column": "23",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Serf extends Peasant {\n  @Override\n  public int taxableIncome() {\n    if (income <= 12)\n      return 0;\n    else\n      return income - 12;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\ninterface Predicate<T> {\n\n  public boolean predicate(T element, T argument);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateEndsWith<T extends String> implements Predicate<T> {\n\n  public boolean predicate(T element, T argument) {\n    if (element == null || argument == null)\n      return false;\n    return element.endsWith(argument);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "Variable 'position' explicitly initialized to '0' (default value for its type).",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateIterator<T> {\n\n  private Iterator<T> iter;\n  private Predicate<T> pred;\n  private T argument;\n  private List<T> items = new ArrayList<T>();\n  private int position = 0;\n\n  public PredicateIterator(Iterator<T> iter, Predicate<T> pred, T argument) {\n    if (iter == null || pred == null || argument == null)\n      throw new NullPointerException();\n    this.iter = iter;\n    this.pred = pred;\n    this.argument = argument;\n    while (iter.hasNext()) {\n      T next = iter.next();\n      this.items.add(next);\n    }\n  }\n\n  public boolean hasNext() {\n    int i = position + 1;\n    while(i <= items.size()) {\n      if (pred.predicate(items.get(i - 1),argument))\n        return true;\n      i++;\n    }\n    return false;\n  }\n\n  public T next() {\n    int i = position + 1;\n    System.out.println(\"Current: \"+position);\n    while (i <= items.size()) {\n      System.out.println(\"Checking: \"+(i-1));\n      if (pred.predicate(items.get(i - 1),argument)) {\n        this.position = i;\n        System.out.println(\"Next: \"+position);\n        return items.get(i - 1);\n      }\n      i++;\n    }\n    throw new NoSuchElementException();\n  }\n\n  public void remove() {\n    // \u00c4tsch b\u00e4tsch ich muss das gar nicht implementieren\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateIterator<T> {\n\n  private Iterator<T> iter;\n  private Predicate<T> pred;\n  private T argument;\n  private List<T> items = new ArrayList<T>();\n  private int position = 0;\n\n  public PredicateIterator(Iterator<T> iter, Predicate<T> pred, T argument) {\n    if (iter == null || pred == null || argument == null)\n      throw new NullPointerException();\n    this.iter = iter;\n    this.pred = pred;\n    this.argument = argument;\n    while (iter.hasNext()) {\n      T next = iter.next();\n      this.items.add(next);\n    }\n  }\n\n  public boolean hasNext() {\n    int i = position + 1;\n    while(i <= items.size()) {\n      if (pred.predicate(items.get(i - 1),argument))\n        return true;\n      i++;\n    }\n    return false;\n  }\n\n  public T next() {\n    int i = position + 1;\n    System.out.println(\"Current: \"+position);\n    while (i <= items.size()) {\n      System.out.println(\"Checking: \"+(i-1));\n      if (pred.predicate(items.get(i - 1),argument)) {\n        this.position = i;\n        System.out.println(\"Next: \"+position);\n        return items.get(i - 1);\n      }\n      i++;\n    }\n    throw new NoSuchElementException();\n  }\n\n  public void remove() {\n    // \u00c4tsch b\u00e4tsch ich muss das gar nicht implementieren\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateIterator<T> {\n\n  private Iterator<T> iter;\n  private Predicate<T> pred;\n  private T argument;\n  private List<T> items = new ArrayList<T>();\n  private int position = 0;\n\n  public PredicateIterator(Iterator<T> iter, Predicate<T> pred, T argument) {\n    if (iter == null || pred == null || argument == null)\n      throw new NullPointerException();\n    this.iter = iter;\n    this.pred = pred;\n    this.argument = argument;\n    while (iter.hasNext()) {\n      T next = iter.next();\n      this.items.add(next);\n    }\n  }\n\n  public boolean hasNext() {\n    int i = position + 1;\n    while(i <= items.size()) {\n      if (pred.predicate(items.get(i - 1),argument))\n        return true;\n      i++;\n    }\n    return false;\n  }\n\n  public T next() {\n    int i = position + 1;\n    System.out.println(\"Current: \"+position);\n    while (i <= items.size()) {\n      System.out.println(\"Checking: \"+(i-1));\n      if (pred.predicate(items.get(i - 1),argument)) {\n        this.position = i;\n        System.out.println(\"Next: \"+position);\n        return items.get(i - 1);\n      }\n      i++;\n    }\n    throw new NoSuchElementException();\n  }\n\n  public void remove() {\n    // \u00c4tsch b\u00e4tsch ich muss das gar nicht implementieren\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateIterator<T> {\n\n  private Iterator<T> iter;\n  private Predicate<T> pred;\n  private T argument;\n  private List<T> items = new ArrayList<T>();\n  private int position = 0;\n\n  public PredicateIterator(Iterator<T> iter, Predicate<T> pred, T argument) {\n    if (iter == null || pred == null || argument == null)\n      throw new NullPointerException();\n    this.iter = iter;\n    this.pred = pred;\n    this.argument = argument;\n    while (iter.hasNext()) {\n      T next = iter.next();\n      this.items.add(next);\n    }\n  }\n\n  public boolean hasNext() {\n    int i = position + 1;\n    while(i <= items.size()) {\n      if (pred.predicate(items.get(i - 1),argument))\n        return true;\n      i++;\n    }\n    return false;\n  }\n\n  public T next() {\n    int i = position + 1;\n    System.out.println(\"Current: \"+position);\n    while (i <= items.size()) {\n      System.out.println(\"Checking: \"+(i-1));\n      if (pred.predicate(items.get(i - 1),argument)) {\n        this.position = i;\n        System.out.println(\"Next: \"+position);\n        return items.get(i - 1);\n      }\n      i++;\n    }\n    throw new NoSuchElementException();\n  }\n\n  public void remove() {\n    // \u00c4tsch b\u00e4tsch ich muss das gar nicht implementieren\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateLength<T extends String> implements Predicate<T> {\n\n  public boolean predicate(T element, T argument) {\n    if (element == null || argument == null)\n      return false;\n    return element.length() == Integer.parseInt(argument);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateStartsWith<T extends String> implements Predicate<T> {\n\n  public boolean predicate(T element, T argument) {\n    if (element == \"\" || argument == \"\")\n      return false;\n    if (element == null || argument == null)\n      return false;\n    return element.startsWith(argument);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "17",
    "end_column": "17",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateStartsWith<T extends String> implements Predicate<T> {\n\n  public boolean predicate(T element, T argument) {\n    if (element == \"\" || argument == \"\")\n      return false;\n    if (element == null || argument == null)\n      return false;\n    return element.startsWith(argument);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "35",
    "end_column": "35",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateStartsWith<T extends String> implements Predicate<T> {\n\n  public boolean predicate(T element, T argument) {\n    if (element == \"\" || argument == \"\")\n      return false;\n    if (element == null || argument == null)\n      return false;\n    return element.startsWith(argument);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Predicate Iterator",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PredicateStartsWith<T extends String> implements Predicate<T> {\n\n  public boolean predicate(T element, T argument) {\n    if (element == \"\" || argument == \"\")\n      return false;\n    if (element == null || argument == null)\n      return false;\n    return element.startsWith(argument);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'0.02' is a magic number.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Flooring extends Material {\n\n  private static double limit = 0.02;\n  private double widthOfFlooring;\n\n  public Flooring(String name, double price, double width) {\n    super(name, price);\n    if (width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    widthOfFlooring = width;\n  }\n\n  public double getWidth() {\n    return widthOfFlooring;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = surfaceArea / widthOfFlooring;\n    double inaccurateCalculation = requirement % 1;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement);\n    else\n      return (int) Math.ceil(requirement);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Flooring extends Material {\n\n  private static double limit = 0.02;\n  private double widthOfFlooring;\n\n  public Flooring(String name, double price, double width) {\n    super(name, price);\n    if (width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    widthOfFlooring = width;\n  }\n\n  public double getWidth() {\n    return widthOfFlooring;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = surfaceArea / widthOfFlooring;\n    double inaccurateCalculation = requirement % 1;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement);\n    else\n      return (int) Math.ceil(requirement);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Flooring extends Material {\n\n  private static double limit = 0.02;\n  private double widthOfFlooring;\n\n  public Flooring(String name, double price, double width) {\n    super(name, price);\n    if (width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    widthOfFlooring = width;\n  }\n\n  public double getWidth() {\n    return widthOfFlooring;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = surfaceArea / widthOfFlooring;\n    double inaccurateCalculation = requirement % 1;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement);\n    else\n      return (int) Math.ceil(requirement);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": "56",
    "end_column": "56",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Flooring extends Material {\n\n  private static double limit = 0.02;\n  private double widthOfFlooring;\n\n  public Flooring(String name, double price, double width) {\n    super(name, price);\n    if (width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    widthOfFlooring = width;\n  }\n\n  public double getWidth() {\n    return widthOfFlooring;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = surfaceArea / widthOfFlooring;\n    double inaccurateCalculation = requirement % 1;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement);\n    else\n      return (int) Math.ceil(requirement);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": "23",
    "end_column": "23",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Flooring extends Material {\n\n  private static double limit = 0.02;\n  private double widthOfFlooring;\n\n  public Flooring(String name, double price, double width) {\n    super(name, price);\n    if (width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    widthOfFlooring = width;\n  }\n\n  public double getWidth() {\n    return widthOfFlooring;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = surfaceArea / widthOfFlooring;\n    double inaccurateCalculation = requirement % 1;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement);\n    else\n      return (int) Math.ceil(requirement);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Flooring extends Material {\n\n  private static double limit = 0.02;\n  private double widthOfFlooring;\n\n  public Flooring(String name, double price, double width) {\n    super(name, price);\n    if (width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    widthOfFlooring = width;\n  }\n\n  public double getWidth() {\n    return widthOfFlooring;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = surfaceArea / widthOfFlooring;\n    double inaccurateCalculation = requirement % 1;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement);\n    else\n      return (int) Math.ceil(requirement);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Flooring extends Material {\n\n  private static double limit = 0.02;\n  private double widthOfFlooring;\n\n  public Flooring(String name, double price, double width) {\n    super(name, price);\n    if (width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    widthOfFlooring = width;\n  }\n\n  public double getWidth() {\n    return widthOfFlooring;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = surfaceArea / widthOfFlooring;\n    double inaccurateCalculation = requirement % 1;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement);\n    else\n      return (int) Math.ceil(requirement);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Name 'Material' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nabstract class Material {\n\n  private String name;\n  private double price;\n\n  public Material(String name, double price) {\n    if (name == \"\"||price < 0) throw new IllegalArgumentException();\n    if (name == null) throw new NullPointerException();\n    this.name = name;\n    this.price = price;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public double getPricePerUnit() {\n    return price;\n  }\n\n  public abstract int getMaterialReq(Surface s);\n\n  public double getPriceOfASurface(Surface s) {\n    if (s == null) throw new NullPointerException();\n    return (double) getMaterialReq(s) * price;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nabstract class Material {\n\n  private String name;\n  private double price;\n\n  public Material(String name, double price) {\n    if (name == \"\"||price < 0) throw new IllegalArgumentException();\n    if (name == null) throw new NullPointerException();\n    this.name = name;\n    this.price = price;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public double getPricePerUnit() {\n    return price;\n  }\n\n  public abstract int getMaterialReq(Surface s);\n\n  public double getPriceOfASurface(Surface s) {\n    if (s == null) throw new NullPointerException();\n    return (double) getMaterialReq(s) * price;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nabstract class Material {\n\n  private String name;\n  private double price;\n\n  public Material(String name, double price) {\n    if (name == \"\"||price < 0) throw new IllegalArgumentException();\n    if (name == null) throw new NullPointerException();\n    this.name = name;\n    this.price = price;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public double getPricePerUnit() {\n    return price;\n  }\n\n  public abstract int getMaterialReq(Surface s);\n\n  public double getPriceOfASurface(Surface s) {\n    if (s == null) throw new NullPointerException();\n    return (double) getMaterialReq(s) * price;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nabstract class Material {\n\n  private String name;\n  private double price;\n\n  public Material(String name, double price) {\n    if (name == \"\"||price < 0) throw new IllegalArgumentException();\n    if (name == null) throw new NullPointerException();\n    this.name = name;\n    this.price = price;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public double getPricePerUnit() {\n    return price;\n  }\n\n  public abstract int getMaterialReq(Surface s);\n\n  public double getPriceOfASurface(Surface s) {\n    if (s == null) throw new NullPointerException();\n    return (double) getMaterialReq(s) * price;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nabstract class Material {\n\n  private String name;\n  private double price;\n\n  public Material(String name, double price) {\n    if (name == \"\"||price < 0) throw new IllegalArgumentException();\n    if (name == null) throw new NullPointerException();\n    this.name = name;\n    this.price = price;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public double getPricePerUnit() {\n    return price;\n  }\n\n  public abstract int getMaterialReq(Surface s);\n\n  public double getPriceOfASurface(Surface s) {\n    if (s == null) throw new NullPointerException();\n    return (double) getMaterialReq(s) * price;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'getPriceOfASurface' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nabstract class Material {\n\n  private String name;\n  private double price;\n\n  public Material(String name, double price) {\n    if (name == \"\"||price < 0) throw new IllegalArgumentException();\n    if (name == null) throw new NullPointerException();\n    this.name = name;\n    this.price = price;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public double getPricePerUnit() {\n    return price;\n  }\n\n  public abstract int getMaterialReq(Surface s);\n\n  public double getPriceOfASurface(Surface s) {\n    if (s == null) throw new NullPointerException();\n    return (double) getMaterialReq(s) * price;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nabstract class Material {\n\n  private String name;\n  private double price;\n\n  public Material(String name, double price) {\n    if (name == \"\"||price < 0) throw new IllegalArgumentException();\n    if (name == null) throw new NullPointerException();\n    this.name = name;\n    this.price = price;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public double getPricePerUnit() {\n    return price;\n  }\n\n  public abstract int getMaterialReq(Surface s);\n\n  public double getPriceOfASurface(Surface s) {\n    if (s == null) throw new NullPointerException();\n    return (double) getMaterialReq(s) * price;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'0.02' is a magic number.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'noOfSqMPerLiter' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'noOfSqMPerLiter' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Abbreviation in name 'getNoOfSqMPerLiter' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'0.5' is a magic number.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": "50",
    "end_column": "50",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": "56",
    "end_column": "56",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "30",
    "end_line": "30",
    "start_column": "23",
    "end_column": "23",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Paint extends Material {\n\n  private static double limit = 0.02;\n  private int noOfCoats;\n  private double noOfSqMPerLiter;\n\n  public Paint(String name, double price, int noOfCoats, double noOfSqMPerLiter) {\n    super(name, price);\n    if (noOfCoats < Double.MIN_VALUE||noOfSqMPerLiter < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.noOfCoats = noOfCoats;\n    this.noOfSqMPerLiter = noOfSqMPerLiter;\n  }\n\n  public int getNoOfCoats() {\n    return noOfCoats;\n  }\n\n  public double getNoOfSqMPerLiter() {\n    return noOfSqMPerLiter;\n  }\n\n  public int getMaterialReq(Surface s) {\n    double surfaceArea = s.getWidth() * s.getLength();\n    double requirement = (surfaceArea * (double)noOfCoats) / noOfSqMPerLiter;\n    double inaccurateCalculation = requirement % 0.5;\n    double modulo = Math.round(inaccurateCalculation * 100);\n    modulo = modulo / 100;\n    if (modulo < limit)\n      return (int) Math.floor(requirement * 2);\n    else\n      return (int) Math.ceil(requirement * 2);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Name 'RenovationObject' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nabstract class RenovationObject {\n\n  public abstract double getPrice();\n  public abstract Map<String, Integer> addMaterialReq(Map<String, Integer> materials);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass StructuredObject extends RenovationObject {\n\n  private Set<RenovationObject> parts = new HashSet<RenovationObject>();\n\n  public StructuredObject() {\n    System.out.println(\"New StructuredObject created.\");\n  }\n\n  public void add(RenovationObject r) {\n    if (r == null) throw new NullPointerException();\n    parts.add(r);\n  }\n\n  public double getPrice() {\n    double price = 0;\n    for (RenovationObject r : parts)\n      price += r.getPrice();\n    return price;\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    for (String mat : materials.keySet()) {\n      if (mat == null&&materials.get(mat) != null)\n        throw new NullPointerException();\n      if (mat != null&&materials.get(mat) == null)\n        throw new NullPointerException();\n    }\n    if (materials == null) throw new NullPointerException();\n\n    Map<String, Integer> output = materials;\n\n    for (RenovationObject p : parts) {\n      // System.out.println(\"Parts: \"+parts.size());\n      // System.out.println(\"Output before adding: \"+output.toString());\n      if (p.addMaterialReq(output) != null) {\n        p.addMaterialReq(output).forEach(output::putIfAbsent);\n      }\n      // System.out.println(\"Output after adding: \"+output.toString());\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass StructuredObject extends RenovationObject {\n\n  private Set<RenovationObject> parts = new HashSet<RenovationObject>();\n\n  public StructuredObject() {\n    System.out.println(\"New StructuredObject created.\");\n  }\n\n  public void add(RenovationObject r) {\n    if (r == null) throw new NullPointerException();\n    parts.add(r);\n  }\n\n  public double getPrice() {\n    double price = 0;\n    for (RenovationObject r : parts)\n      price += r.getPrice();\n    return price;\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    for (String mat : materials.keySet()) {\n      if (mat == null&&materials.get(mat) != null)\n        throw new NullPointerException();\n      if (mat != null&&materials.get(mat) == null)\n        throw new NullPointerException();\n    }\n    if (materials == null) throw new NullPointerException();\n\n    Map<String, Integer> output = materials;\n\n    for (RenovationObject p : parts) {\n      // System.out.println(\"Parts: \"+parts.size());\n      // System.out.println(\"Output before adding: \"+output.toString());\n      if (p.addMaterialReq(output) != null) {\n        p.addMaterialReq(output).forEach(output::putIfAbsent);\n      }\n      // System.out.println(\"Output after adding: \"+output.toString());\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass StructuredObject extends RenovationObject {\n\n  private Set<RenovationObject> parts = new HashSet<RenovationObject>();\n\n  public StructuredObject() {\n    System.out.println(\"New StructuredObject created.\");\n  }\n\n  public void add(RenovationObject r) {\n    if (r == null) throw new NullPointerException();\n    parts.add(r);\n  }\n\n  public double getPrice() {\n    double price = 0;\n    for (RenovationObject r : parts)\n      price += r.getPrice();\n    return price;\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    for (String mat : materials.keySet()) {\n      if (mat == null&&materials.get(mat) != null)\n        throw new NullPointerException();\n      if (mat != null&&materials.get(mat) == null)\n        throw new NullPointerException();\n    }\n    if (materials == null) throw new NullPointerException();\n\n    Map<String, Integer> output = materials;\n\n    for (RenovationObject p : parts) {\n      // System.out.println(\"Parts: \"+parts.size());\n      // System.out.println(\"Output before adding: \"+output.toString());\n      if (p.addMaterialReq(output) != null) {\n        p.addMaterialReq(output).forEach(output::putIfAbsent);\n      }\n      // System.out.println(\"Output after adding: \"+output.toString());\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass StructuredObject extends RenovationObject {\n\n  private Set<RenovationObject> parts = new HashSet<RenovationObject>();\n\n  public StructuredObject() {\n    System.out.println(\"New StructuredObject created.\");\n  }\n\n  public void add(RenovationObject r) {\n    if (r == null) throw new NullPointerException();\n    parts.add(r);\n  }\n\n  public double getPrice() {\n    double price = 0;\n    for (RenovationObject r : parts)\n      price += r.getPrice();\n    return price;\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    for (String mat : materials.keySet()) {\n      if (mat == null&&materials.get(mat) != null)\n        throw new NullPointerException();\n      if (mat != null&&materials.get(mat) == null)\n        throw new NullPointerException();\n    }\n    if (materials == null) throw new NullPointerException();\n\n    Map<String, Integer> output = materials;\n\n    for (RenovationObject p : parts) {\n      // System.out.println(\"Parts: \"+parts.size());\n      // System.out.println(\"Output before adding: \"+output.toString());\n      if (p.addMaterialReq(output) != null) {\n        p.addMaterialReq(output).forEach(output::putIfAbsent);\n      }\n      // System.out.println(\"Output after adding: \"+output.toString());\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass StructuredObject extends RenovationObject {\n\n  private Set<RenovationObject> parts = new HashSet<RenovationObject>();\n\n  public StructuredObject() {\n    System.out.println(\"New StructuredObject created.\");\n  }\n\n  public void add(RenovationObject r) {\n    if (r == null) throw new NullPointerException();\n    parts.add(r);\n  }\n\n  public double getPrice() {\n    double price = 0;\n    for (RenovationObject r : parts)\n      price += r.getPrice();\n    return price;\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    for (String mat : materials.keySet()) {\n      if (mat == null&&materials.get(mat) != null)\n        throw new NullPointerException();\n      if (mat != null&&materials.get(mat) == null)\n        throw new NullPointerException();\n    }\n    if (materials == null) throw new NullPointerException();\n\n    Map<String, Integer> output = materials;\n\n    for (RenovationObject p : parts) {\n      // System.out.println(\"Parts: \"+parts.size());\n      // System.out.println(\"Output before adding: \"+output.toString());\n      if (p.addMaterialReq(output) != null) {\n        p.addMaterialReq(output).forEach(output::putIfAbsent);\n      }\n      // System.out.println(\"Output after adding: \"+output.toString());\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass StructuredObject extends RenovationObject {\n\n  private Set<RenovationObject> parts = new HashSet<RenovationObject>();\n\n  public StructuredObject() {\n    System.out.println(\"New StructuredObject created.\");\n  }\n\n  public void add(RenovationObject r) {\n    if (r == null) throw new NullPointerException();\n    parts.add(r);\n  }\n\n  public double getPrice() {\n    double price = 0;\n    for (RenovationObject r : parts)\n      price += r.getPrice();\n    return price;\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    for (String mat : materials.keySet()) {\n      if (mat == null&&materials.get(mat) != null)\n        throw new NullPointerException();\n      if (mat != null&&materials.get(mat) == null)\n        throw new NullPointerException();\n    }\n    if (materials == null) throw new NullPointerException();\n\n    Map<String, Integer> output = materials;\n\n    for (RenovationObject p : parts) {\n      // System.out.println(\"Parts: \"+parts.size());\n      // System.out.println(\"Output before adding: \"+output.toString());\n      if (p.addMaterialReq(output) != null) {\n        p.addMaterialReq(output).forEach(output::putIfAbsent);\n      }\n      // System.out.println(\"Output after adding: \"+output.toString());\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "34",
    "end_line": "34",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "41",
    "end_line": "41",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "43",
    "end_line": "43",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "46",
    "end_line": "46",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "47",
    "end_line": "47",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "53",
    "end_line": "53",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "55",
    "end_line": "55",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Renovation Project",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "58",
    "end_line": "58",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Surface extends RenovationObject {\n\n  private Material selectedMaterial;\n  private double length;\n  private double width;\n\n  public Surface(double length, double width) {\n    if (length < Double.MIN_VALUE||width < Double.MIN_VALUE) throw new IllegalArgumentException();\n    this.length = length;\n    this.width = width;\n  }\n\n  public void setMaterial(Material m) {\n    if (m == null) throw new NullPointerException();\n    selectedMaterial = m;\n  }\n\n  public double getArea() {\n    return length * width;\n  }\n\n  public double getLength() {\n    return length;\n  }\n\n  public double getWidth() {\n    return width;\n  }\n\n  public double getPrice() {\n    if (selectedMaterial == null)\n      return 0;\n    else\n      return selectedMaterial.getPriceOfASurface(this);\n  }\n\n  public Map<String, Integer> addMaterialReq(Map<String, Integer> materials) {\n    if (selectedMaterial == null)\n      throw new NullPointerException();\n    if (materials == null)\n      throw new NullPointerException();\n    for (String fuckThisUnitTest : materials.keySet()) {\n      if (fuckThisUnitTest == null&&materials.get(fuckThisUnitTest) != null) throw new NullPointerException();\n      if (fuckThisUnitTest != null&&materials.get(fuckThisUnitTest) == null) throw new NullPointerException();\n    }\n    String matName = selectedMaterial.getName();\n    Integer amount = materials.get(matName);\n    System.out.println(\"Amount already in list: \"+amount);\n    if (amount != null) {\n      if (amount % selectedMaterial.getMaterialReq(this) != 0)\n        amount += selectedMaterial.getMaterialReq(this);\n      else\n        amount = selectedMaterial.getMaterialReq(this);\n    }\n    else\n      amount = selectedMaterial.getMaterialReq(this);\n    System.out.println(\"Amount after adding: \"+amount);\n    materials.put(matName, amount);\n    return materials;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\ninterface Queue<T> {\n  public boolean add(T t);\n  public T remove();\n  public T first();\n  public boolean isEmpty();\n  public int size();\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\ninterface Queue<T> {\n  public boolean add(T t);\n  public T remove();\n  public T first();\n  public boolean isEmpty();\n  public int size();\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\ninterface Queue<T> {\n  public boolean add(T t);\n  public T remove();\n  public T first();\n  public boolean isEmpty();\n  public int size();\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\ninterface Queue<T> {\n  public boolean add(T t);\n  public T remove();\n  public T first();\n  public boolean isEmpty();\n  public int size();\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\ninterface Queue<T> {\n  public boolean add(T t);\n  public T remove();\n  public T first();\n  public boolean isEmpty();\n  public int size();\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "35",
    "end_line": "35",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "40",
    "end_line": "40",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "42",
    "end_line": "42",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "47",
    "end_line": "47",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Queue",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "49",
    "end_line": "49",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass QueueImpl<T> implements Queue {\n\n  private OrderedSet<T> elementsWithoutDuplicates;\n  private List<T> elementsWithDuplicates;\n  private boolean withDuplicates;\n\n  public QueueImpl(boolean withDuplicates) {\n    this.withDuplicates = withDuplicates;\n    if (withDuplicates)\n      elementsWithDuplicates = new ArrayList<T>();\n    else\n      elementsWithoutDuplicates = new OrderedSetImpl<T>();\n  }\n\n  public boolean add(T t) {\n    if (withDuplicates)\n      elementsWithDuplicates.add(t);\n    else\n      elementsWithoutDuplicates.add(t);\n  }\n\n  public T remove() {\n    if (withDuplicates)\n      return elementsWithDuplicates.remove(0);\n    else\n      return elementsWithoutDuplicates.remove(0);\n  }\n\n  public T first() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0);\n    else\n      return elementsWithoutDuplicates.get(0);\n  }\n\n  public boolean isEmpty() {\n    if (withDuplicates)\n      return elementsWithDuplicates.get(0) == null;\n    else\n      return elementsWithoutDuplicates.get(0) == null;\n  }\n\n  public int size() {\n    if (withDuplicates)\n      return elementsWithDuplicates.size();\n    else\n      return elementsWithoutDuplicates.size();\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections II",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Book implements Comparable<Book> {\n\n  private String title = \"\";\n  private String author = \"\";\n  private String isbn;\n\n  public Book(String isbn, String author, String title) {\n    this.title = title;\n    this.author = author;\n    this.isbn = isbn;\n    System.out.println(\"Book \"+title+\" by \"+author+\" created.\");\n  }\n\n  public Book(String isbn) {\n    this.isbn = isbn;\n    System.out.println(\"Book with ISBN \"+isbn+\" created.\");\n  }\n\n  public String getIsbn() {\n    return this.isbn;\n  }\n\n  public String getAuthor() {\n    return this.author;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n  @Override public int compareTo(Book book) {\n    int bookIsbn = Integer.parseInt(book.getIsbn());\n    int thisIsbn = Integer.parseInt(this.getIsbn());\n    if (bookIsbn == thisIsbn)\n      return 0;\n    else\n      return thisIsbn - bookIsbn;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections II",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Book implements Comparable<Book> {\n\n  private String title = \"\";\n  private String author = \"\";\n  private String isbn;\n\n  public Book(String isbn, String author, String title) {\n    this.title = title;\n    this.author = author;\n    this.isbn = isbn;\n    System.out.println(\"Book \"+title+\" by \"+author+\" created.\");\n  }\n\n  public Book(String isbn) {\n    this.isbn = isbn;\n    System.out.println(\"Book with ISBN \"+isbn+\" created.\");\n  }\n\n  public String getIsbn() {\n    return this.isbn;\n  }\n\n  public String getAuthor() {\n    return this.author;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n  @Override public int compareTo(Book book) {\n    int bookIsbn = Integer.parseInt(book.getIsbn());\n    int thisIsbn = Integer.parseInt(this.getIsbn());\n    if (bookIsbn == thisIsbn)\n      return 0;\n    else\n      return thisIsbn - bookIsbn;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections II",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "40",
    "end_line": "40",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Book implements Comparable<Book> {\n\n  private String title = \"\";\n  private String author = \"\";\n  private String isbn;\n\n  public Book(String isbn, String author, String title) {\n    this.title = title;\n    this.author = author;\n    this.isbn = isbn;\n    System.out.println(\"Book \"+title+\" by \"+author+\" created.\");\n  }\n\n  public Book(String isbn) {\n    this.isbn = isbn;\n    System.out.println(\"Book with ISBN \"+isbn+\" created.\");\n  }\n\n  public String getIsbn() {\n    return this.isbn;\n  }\n\n  public String getAuthor() {\n    return this.author;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n  @Override public int compareTo(Book book) {\n    int bookIsbn = Integer.parseInt(book.getIsbn());\n    int thisIsbn = Integer.parseInt(this.getIsbn());\n    if (bookIsbn == thisIsbn)\n      return 0;\n    else\n      return thisIsbn - bookIsbn;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections II",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "42",
    "end_line": "42",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Book implements Comparable<Book> {\n\n  private String title = \"\";\n  private String author = \"\";\n  private String isbn;\n\n  public Book(String isbn, String author, String title) {\n    this.title = title;\n    this.author = author;\n    this.isbn = isbn;\n    System.out.println(\"Book \"+title+\" by \"+author+\" created.\");\n  }\n\n  public Book(String isbn) {\n    this.isbn = isbn;\n    System.out.println(\"Book with ISBN \"+isbn+\" created.\");\n  }\n\n  public String getIsbn() {\n    return this.isbn;\n  }\n\n  public String getAuthor() {\n    return this.author;\n  }\n\n  public String getTitle() {\n    return this.title;\n  }\n\n  @Override public String toString() {\n    return String.format(this.title);\n  }\n\n  @Override public int compareTo(Book book) {\n    int bookIsbn = Integer.parseInt(book.getIsbn());\n    int thisIsbn = Integer.parseInt(this.getIsbn());\n    if (bookIsbn == thisIsbn)\n      return 0;\n    else\n      return thisIsbn - bookIsbn;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections II",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Library {\n\n  private Set<Book> stock = new TreeSet<Book>(new BookComparator());\n\n  public Library() {\n    System.out.println(\"Hello, I am a library!\");\n  }\n\n  public boolean insertBook (Book newBook) {\n    Book add_this_book = newBook;\n    System.out.println(\"I added the book \"+newBook.getTitle()+\"!\");\n    return this.stock.add(add_this_book);\n  }\n\n  public Book searchForIsbn(String isbn) {\n    for (Book book : this.stock) {\n      if (book.getIsbn() == isbn)\n        return book;\n    }\n    return null;\n  }\n\n  public Collection<Book> searchForAuthor(String author) {\n    Collection<Book> output = new ArrayList<Book>();\n    for (Book book : this.stock) {\n      if (book.getAuthor() == author)\n        output.add(book);\n    }\n    return output;\n  }\n\n  public Map<String, Set<Book>> listStockByAuthor() {\n    Map<String, Set<Book>> output = new HashMap<String, Set<Book>>();\n    for (Book book : this.stock) {\n      Set<Book> books = new HashSet<Book>(this.searchForAuthor(book.getAuthor()));\n      output.put(book.getAuthor(), books);\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections II",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Library {\n\n  private Set<Book> stock = new TreeSet<Book>(new BookComparator());\n\n  public Library() {\n    System.out.println(\"Hello, I am a library!\");\n  }\n\n  public boolean insertBook (Book newBook) {\n    Book add_this_book = newBook;\n    System.out.println(\"I added the book \"+newBook.getTitle()+\"!\");\n    return this.stock.add(add_this_book);\n  }\n\n  public Book searchForIsbn(String isbn) {\n    for (Book book : this.stock) {\n      if (book.getIsbn() == isbn)\n        return book;\n    }\n    return null;\n  }\n\n  public Collection<Book> searchForAuthor(String author) {\n    Collection<Book> output = new ArrayList<Book>();\n    for (Book book : this.stock) {\n      if (book.getAuthor() == author)\n        output.add(book);\n    }\n    return output;\n  }\n\n  public Map<String, Set<Book>> listStockByAuthor() {\n    Map<String, Set<Book>> output = new HashMap<String, Set<Book>>();\n    for (Book book : this.stock) {\n      Set<Book> books = new HashSet<Book>(this.searchForAuthor(book.getAuthor()));\n      output.put(book.getAuthor(), books);\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Collections II",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\nclass Library {\n\n  private Set<Book> stock = new TreeSet<Book>(new BookComparator());\n\n  public Library() {\n    System.out.println(\"Hello, I am a library!\");\n  }\n\n  public boolean insertBook (Book newBook) {\n    Book add_this_book = newBook;\n    System.out.println(\"I added the book \"+newBook.getTitle()+\"!\");\n    return this.stock.add(add_this_book);\n  }\n\n  public Book searchForIsbn(String isbn) {\n    for (Book book : this.stock) {\n      if (book.getIsbn() == isbn)\n        return book;\n    }\n    return null;\n  }\n\n  public Collection<Book> searchForAuthor(String author) {\n    Collection<Book> output = new ArrayList<Book>();\n    for (Book book : this.stock) {\n      if (book.getAuthor() == author)\n        output.add(book);\n    }\n    return output;\n  }\n\n  public Map<String, Set<Book>> listStockByAuthor() {\n    Map<String, Set<Book>> output = new HashMap<String, Set<Book>>();\n    for (Book book : this.stock) {\n      Set<Book> books = new HashSet<Book>(this.searchForAuthor(book.getAuthor()));\n      output.put(book.getAuthor(), books);\n    }\n    return output;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface Matrix<T> {\n    public int getRowCount();\n    public int getColumnCount();\n    public int getObjectCount();\n    public int getDistinctObjectCount();\n    public Iterator<T> iterator();\n    public T get(int row, int column);\n    public T put (int row, int column, T value);\n    public boolean contains(T value);\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface Matrix<T> {\n    public int getRowCount();\n    public int getColumnCount();\n    public int getObjectCount();\n    public int getDistinctObjectCount();\n    public Iterator<T> iterator();\n    public T get(int row, int column);\n    public T put (int row, int column, T value);\n    public boolean contains(T value);\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface Matrix<T> {\n    public int getRowCount();\n    public int getColumnCount();\n    public int getObjectCount();\n    public int getDistinctObjectCount();\n    public Iterator<T> iterator();\n    public T get(int row, int column);\n    public T put (int row, int column, T value);\n    public boolean contains(T value);\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface Matrix<T> {\n    public int getRowCount();\n    public int getColumnCount();\n    public int getObjectCount();\n    public int getDistinctObjectCount();\n    public Iterator<T> iterator();\n    public T get(int row, int column);\n    public T put (int row, int column, T value);\n    public boolean contains(T value);\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface Matrix<T> {\n    public int getRowCount();\n    public int getColumnCount();\n    public int getObjectCount();\n    public int getDistinctObjectCount();\n    public Iterator<T> iterator();\n    public T get(int row, int column);\n    public T put (int row, int column, T value);\n    public boolean contains(T value);\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface Matrix<T> {\n    public int getRowCount();\n    public int getColumnCount();\n    public int getObjectCount();\n    public int getDistinctObjectCount();\n    public Iterator<T> iterator();\n    public T get(int row, int column);\n    public T put (int row, int column, T value);\n    public boolean contains(T value);\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface Matrix<T> {\n    public int getRowCount();\n    public int getColumnCount();\n    public int getObjectCount();\n    public int getDistinctObjectCount();\n    public Iterator<T> iterator();\n    public T get(int row, int column);\n    public T put (int row, int column, T value);\n    public boolean contains(T value);\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface Matrix<T> {\n    public int getRowCount();\n    public int getColumnCount();\n    public int getObjectCount();\n    public int getDistinctObjectCount();\n    public Iterator<T> iterator();\n    public T get(int row, int column);\n    public T put (int row, int column, T value);\n    public boolean contains(T value);\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "18",
    "end_line": "18",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.NoSuchElementException;\nimport java.lang.UnsupportedOperationException;\nimport java.awt.Point;\n\nclass MyMatrix<T> implements Matrix<T> {\n\n  private Map<Point,T> matrixEntries = new HashMap<Point,T>();\n\n  class DepthFirstIterator implements Iterator {\n\n    private Point current = new Point();\n    private int rows;\n    private int columns;\n\n    public DepthFirstIterator() {\n      this.rows = getRowCount();\n      this.columns = getColumnCount();\n    }\n\n    @Override\n    public T next() {\n      if (this.current.y == this.columns - 1) {\n        this.current.y = 0;\n        this.current.x++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      else {\n        this.current.y++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      if (this.current.y > this.rows - 1 || this.current.x > this.columns - 1)\n        throw new NoSuchElementException(\"No more elements\");\n      if (get(this.current.y,this.current.x) == null)\n        return this.next();\n      else {\n        System.out.println(\"Next object at (\"+this.current.x+\",\"+this.current.y+\") -> \"+get(this.current.y,this.current.x).toString());\n        return get(this.current.y,this.current.x);\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      Point pivot = new Point(this.current.x, this.current.y);\n      if (pivot.y == this.columns - 1) {\n        pivot.y = 0;\n        pivot.x++;\n      }\n      else {\n        pivot.y++;\n      }\n      if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n        return false;\n      }\n      while (get(pivot.y,pivot.x) == null) {\n        if (pivot.y == this.columns - 1) {\n          pivot.y = 0;\n          pivot.x++;\n        }\n        else {\n          pivot.y++;\n        }\n        if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n          return false;\n        }\n      }\n      return true;\n\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"Unsupported\");\n    }\n\n  }\n\n  public int getRowCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    // System.out.println(\"--------gRC: Current matrix layout--------\");\n    int rowsCount = 0;\n    for (Point point : keys) {\n      // System.out.println(\"(\"+point.x+\",\"+point.y+\") -> \"+this.matrixEntries.get(point).toString());\n      if (point.y >= rowsCount) {\n        if (this.matrixEntries.get(point) != null)\n          rowsCount = point.y + 1;\n      }\n    }\n    // System.out.println(\"Row count: \"+rowsCount);\n    // System.out.println(\"------------------------------------------\");\n    return rowsCount;\n  }\n\n  public int getColumnCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    int columnsCount = 0;\n    for (Point point : keys) {\n      if (point.x >= columnsCount) {\n        if (this.matrixEntries.get(point) != null)\n          columnsCount = point.x + 1;\n      }\n    }\n    return columnsCount;\n\n  }\n\n  public int getObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    int count = 0;\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        count++;\n    }\n    return count;\n  }\n\n  public int getDistinctObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    Set<T> objects = new HashSet<T>();\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        objects.add(this.matrixEntries.get(point));\n    }\n    return objects.size();\n  }\n\n  @Override\n  public Iterator<T> iterator() {\n    DepthFirstIterator iterator = new DepthFirstIterator();\n    return iterator;\n  }\n\n  public T get(int row, int column) {\n    if (row > this.getRowCount() - 1 || column > this.getColumnCount() - 1)\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    Point getPoint = new Point(column, row);\n    return this.matrixEntries.get(getPoint);\n  }\n\n  public T put (int row, int column, T value) {\n    // if (value != null)\n      // System.out.println(\"Inserted point: (\"+column+\",\"+row+\") -> \"+value.toString());\n    Point putPoint = new Point(column, row);\n    return this.matrixEntries.put(putPoint, value);\n  }\n\n  public boolean contains(T value) {\n    if (this.matrixEntries == null) return false;\n    return this.matrixEntries.containsValue(value);\n  }\n\n\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "34",
    "end_line": "34",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.NoSuchElementException;\nimport java.lang.UnsupportedOperationException;\nimport java.awt.Point;\n\nclass MyMatrix<T> implements Matrix<T> {\n\n  private Map<Point,T> matrixEntries = new HashMap<Point,T>();\n\n  class DepthFirstIterator implements Iterator {\n\n    private Point current = new Point();\n    private int rows;\n    private int columns;\n\n    public DepthFirstIterator() {\n      this.rows = getRowCount();\n      this.columns = getColumnCount();\n    }\n\n    @Override\n    public T next() {\n      if (this.current.y == this.columns - 1) {\n        this.current.y = 0;\n        this.current.x++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      else {\n        this.current.y++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      if (this.current.y > this.rows - 1 || this.current.x > this.columns - 1)\n        throw new NoSuchElementException(\"No more elements\");\n      if (get(this.current.y,this.current.x) == null)\n        return this.next();\n      else {\n        System.out.println(\"Next object at (\"+this.current.x+\",\"+this.current.y+\") -> \"+get(this.current.y,this.current.x).toString());\n        return get(this.current.y,this.current.x);\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      Point pivot = new Point(this.current.x, this.current.y);\n      if (pivot.y == this.columns - 1) {\n        pivot.y = 0;\n        pivot.x++;\n      }\n      else {\n        pivot.y++;\n      }\n      if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n        return false;\n      }\n      while (get(pivot.y,pivot.x) == null) {\n        if (pivot.y == this.columns - 1) {\n          pivot.y = 0;\n          pivot.x++;\n        }\n        else {\n          pivot.y++;\n        }\n        if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n          return false;\n        }\n      }\n      return true;\n\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"Unsupported\");\n    }\n\n  }\n\n  public int getRowCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    // System.out.println(\"--------gRC: Current matrix layout--------\");\n    int rowsCount = 0;\n    for (Point point : keys) {\n      // System.out.println(\"(\"+point.x+\",\"+point.y+\") -> \"+this.matrixEntries.get(point).toString());\n      if (point.y >= rowsCount) {\n        if (this.matrixEntries.get(point) != null)\n          rowsCount = point.y + 1;\n      }\n    }\n    // System.out.println(\"Row count: \"+rowsCount);\n    // System.out.println(\"------------------------------------------\");\n    return rowsCount;\n  }\n\n  public int getColumnCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    int columnsCount = 0;\n    for (Point point : keys) {\n      if (point.x >= columnsCount) {\n        if (this.matrixEntries.get(point) != null)\n          columnsCount = point.x + 1;\n      }\n    }\n    return columnsCount;\n\n  }\n\n  public int getObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    int count = 0;\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        count++;\n    }\n    return count;\n  }\n\n  public int getDistinctObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    Set<T> objects = new HashSet<T>();\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        objects.add(this.matrixEntries.get(point));\n    }\n    return objects.size();\n  }\n\n  @Override\n  public Iterator<T> iterator() {\n    DepthFirstIterator iterator = new DepthFirstIterator();\n    return iterator;\n  }\n\n  public T get(int row, int column) {\n    if (row > this.getRowCount() - 1 || column > this.getColumnCount() - 1)\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    Point getPoint = new Point(column, row);\n    return this.matrixEntries.get(getPoint);\n  }\n\n  public T put (int row, int column, T value) {\n    // if (value != null)\n      // System.out.println(\"Inserted point: (\"+column+\",\"+row+\") -> \"+value.toString());\n    Point putPoint = new Point(column, row);\n    return this.matrixEntries.put(putPoint, value);\n  }\n\n  public boolean contains(T value) {\n    if (this.matrixEntries == null) return false;\n    return this.matrixEntries.containsValue(value);\n  }\n\n\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.NoSuchElementException;\nimport java.lang.UnsupportedOperationException;\nimport java.awt.Point;\n\nclass MyMatrix<T> implements Matrix<T> {\n\n  private Map<Point,T> matrixEntries = new HashMap<Point,T>();\n\n  class DepthFirstIterator implements Iterator {\n\n    private Point current = new Point();\n    private int rows;\n    private int columns;\n\n    public DepthFirstIterator() {\n      this.rows = getRowCount();\n      this.columns = getColumnCount();\n    }\n\n    @Override\n    public T next() {\n      if (this.current.y == this.columns - 1) {\n        this.current.y = 0;\n        this.current.x++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      else {\n        this.current.y++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      if (this.current.y > this.rows - 1 || this.current.x > this.columns - 1)\n        throw new NoSuchElementException(\"No more elements\");\n      if (get(this.current.y,this.current.x) == null)\n        return this.next();\n      else {\n        System.out.println(\"Next object at (\"+this.current.x+\",\"+this.current.y+\") -> \"+get(this.current.y,this.current.x).toString());\n        return get(this.current.y,this.current.x);\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      Point pivot = new Point(this.current.x, this.current.y);\n      if (pivot.y == this.columns - 1) {\n        pivot.y = 0;\n        pivot.x++;\n      }\n      else {\n        pivot.y++;\n      }\n      if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n        return false;\n      }\n      while (get(pivot.y,pivot.x) == null) {\n        if (pivot.y == this.columns - 1) {\n          pivot.y = 0;\n          pivot.x++;\n        }\n        else {\n          pivot.y++;\n        }\n        if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n          return false;\n        }\n      }\n      return true;\n\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"Unsupported\");\n    }\n\n  }\n\n  public int getRowCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    // System.out.println(\"--------gRC: Current matrix layout--------\");\n    int rowsCount = 0;\n    for (Point point : keys) {\n      // System.out.println(\"(\"+point.x+\",\"+point.y+\") -> \"+this.matrixEntries.get(point).toString());\n      if (point.y >= rowsCount) {\n        if (this.matrixEntries.get(point) != null)\n          rowsCount = point.y + 1;\n      }\n    }\n    // System.out.println(\"Row count: \"+rowsCount);\n    // System.out.println(\"------------------------------------------\");\n    return rowsCount;\n  }\n\n  public int getColumnCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    int columnsCount = 0;\n    for (Point point : keys) {\n      if (point.x >= columnsCount) {\n        if (this.matrixEntries.get(point) != null)\n          columnsCount = point.x + 1;\n      }\n    }\n    return columnsCount;\n\n  }\n\n  public int getObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    int count = 0;\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        count++;\n    }\n    return count;\n  }\n\n  public int getDistinctObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    Set<T> objects = new HashSet<T>();\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        objects.add(this.matrixEntries.get(point));\n    }\n    return objects.size();\n  }\n\n  @Override\n  public Iterator<T> iterator() {\n    DepthFirstIterator iterator = new DepthFirstIterator();\n    return iterator;\n  }\n\n  public T get(int row, int column) {\n    if (row > this.getRowCount() - 1 || column > this.getColumnCount() - 1)\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    Point getPoint = new Point(column, row);\n    return this.matrixEntries.get(getPoint);\n  }\n\n  public T put (int row, int column, T value) {\n    // if (value != null)\n      // System.out.println(\"Inserted point: (\"+column+\",\"+row+\") -> \"+value.toString());\n    Point putPoint = new Point(column, row);\n    return this.matrixEntries.put(putPoint, value);\n  }\n\n  public boolean contains(T value) {\n    if (this.matrixEntries == null) return false;\n    return this.matrixEntries.containsValue(value);\n  }\n\n\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "87",
    "end_line": "87",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.NoSuchElementException;\nimport java.lang.UnsupportedOperationException;\nimport java.awt.Point;\n\nclass MyMatrix<T> implements Matrix<T> {\n\n  private Map<Point,T> matrixEntries = new HashMap<Point,T>();\n\n  class DepthFirstIterator implements Iterator {\n\n    private Point current = new Point();\n    private int rows;\n    private int columns;\n\n    public DepthFirstIterator() {\n      this.rows = getRowCount();\n      this.columns = getColumnCount();\n    }\n\n    @Override\n    public T next() {\n      if (this.current.y == this.columns - 1) {\n        this.current.y = 0;\n        this.current.x++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      else {\n        this.current.y++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      if (this.current.y > this.rows - 1 || this.current.x > this.columns - 1)\n        throw new NoSuchElementException(\"No more elements\");\n      if (get(this.current.y,this.current.x) == null)\n        return this.next();\n      else {\n        System.out.println(\"Next object at (\"+this.current.x+\",\"+this.current.y+\") -> \"+get(this.current.y,this.current.x).toString());\n        return get(this.current.y,this.current.x);\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      Point pivot = new Point(this.current.x, this.current.y);\n      if (pivot.y == this.columns - 1) {\n        pivot.y = 0;\n        pivot.x++;\n      }\n      else {\n        pivot.y++;\n      }\n      if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n        return false;\n      }\n      while (get(pivot.y,pivot.x) == null) {\n        if (pivot.y == this.columns - 1) {\n          pivot.y = 0;\n          pivot.x++;\n        }\n        else {\n          pivot.y++;\n        }\n        if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n          return false;\n        }\n      }\n      return true;\n\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"Unsupported\");\n    }\n\n  }\n\n  public int getRowCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    // System.out.println(\"--------gRC: Current matrix layout--------\");\n    int rowsCount = 0;\n    for (Point point : keys) {\n      // System.out.println(\"(\"+point.x+\",\"+point.y+\") -> \"+this.matrixEntries.get(point).toString());\n      if (point.y >= rowsCount) {\n        if (this.matrixEntries.get(point) != null)\n          rowsCount = point.y + 1;\n      }\n    }\n    // System.out.println(\"Row count: \"+rowsCount);\n    // System.out.println(\"------------------------------------------\");\n    return rowsCount;\n  }\n\n  public int getColumnCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    int columnsCount = 0;\n    for (Point point : keys) {\n      if (point.x >= columnsCount) {\n        if (this.matrixEntries.get(point) != null)\n          columnsCount = point.x + 1;\n      }\n    }\n    return columnsCount;\n\n  }\n\n  public int getObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    int count = 0;\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        count++;\n    }\n    return count;\n  }\n\n  public int getDistinctObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    Set<T> objects = new HashSet<T>();\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        objects.add(this.matrixEntries.get(point));\n    }\n    return objects.size();\n  }\n\n  @Override\n  public Iterator<T> iterator() {\n    DepthFirstIterator iterator = new DepthFirstIterator();\n    return iterator;\n  }\n\n  public T get(int row, int column) {\n    if (row > this.getRowCount() - 1 || column > this.getColumnCount() - 1)\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    Point getPoint = new Point(column, row);\n    return this.matrixEntries.get(getPoint);\n  }\n\n  public T put (int row, int column, T value) {\n    // if (value != null)\n      // System.out.println(\"Inserted point: (\"+column+\",\"+row+\") -> \"+value.toString());\n    Point putPoint = new Point(column, row);\n    return this.matrixEntries.put(putPoint, value);\n  }\n\n  public boolean contains(T value) {\n    if (this.matrixEntries == null) return false;\n    return this.matrixEntries.containsValue(value);\n  }\n\n\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "101",
    "end_line": "101",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.NoSuchElementException;\nimport java.lang.UnsupportedOperationException;\nimport java.awt.Point;\n\nclass MyMatrix<T> implements Matrix<T> {\n\n  private Map<Point,T> matrixEntries = new HashMap<Point,T>();\n\n  class DepthFirstIterator implements Iterator {\n\n    private Point current = new Point();\n    private int rows;\n    private int columns;\n\n    public DepthFirstIterator() {\n      this.rows = getRowCount();\n      this.columns = getColumnCount();\n    }\n\n    @Override\n    public T next() {\n      if (this.current.y == this.columns - 1) {\n        this.current.y = 0;\n        this.current.x++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      else {\n        this.current.y++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      if (this.current.y > this.rows - 1 || this.current.x > this.columns - 1)\n        throw new NoSuchElementException(\"No more elements\");\n      if (get(this.current.y,this.current.x) == null)\n        return this.next();\n      else {\n        System.out.println(\"Next object at (\"+this.current.x+\",\"+this.current.y+\") -> \"+get(this.current.y,this.current.x).toString());\n        return get(this.current.y,this.current.x);\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      Point pivot = new Point(this.current.x, this.current.y);\n      if (pivot.y == this.columns - 1) {\n        pivot.y = 0;\n        pivot.x++;\n      }\n      else {\n        pivot.y++;\n      }\n      if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n        return false;\n      }\n      while (get(pivot.y,pivot.x) == null) {\n        if (pivot.y == this.columns - 1) {\n          pivot.y = 0;\n          pivot.x++;\n        }\n        else {\n          pivot.y++;\n        }\n        if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n          return false;\n        }\n      }\n      return true;\n\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"Unsupported\");\n    }\n\n  }\n\n  public int getRowCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    // System.out.println(\"--------gRC: Current matrix layout--------\");\n    int rowsCount = 0;\n    for (Point point : keys) {\n      // System.out.println(\"(\"+point.x+\",\"+point.y+\") -> \"+this.matrixEntries.get(point).toString());\n      if (point.y >= rowsCount) {\n        if (this.matrixEntries.get(point) != null)\n          rowsCount = point.y + 1;\n      }\n    }\n    // System.out.println(\"Row count: \"+rowsCount);\n    // System.out.println(\"------------------------------------------\");\n    return rowsCount;\n  }\n\n  public int getColumnCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    int columnsCount = 0;\n    for (Point point : keys) {\n      if (point.x >= columnsCount) {\n        if (this.matrixEntries.get(point) != null)\n          columnsCount = point.x + 1;\n      }\n    }\n    return columnsCount;\n\n  }\n\n  public int getObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    int count = 0;\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        count++;\n    }\n    return count;\n  }\n\n  public int getDistinctObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    Set<T> objects = new HashSet<T>();\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        objects.add(this.matrixEntries.get(point));\n    }\n    return objects.size();\n  }\n\n  @Override\n  public Iterator<T> iterator() {\n    DepthFirstIterator iterator = new DepthFirstIterator();\n    return iterator;\n  }\n\n  public T get(int row, int column) {\n    if (row > this.getRowCount() - 1 || column > this.getColumnCount() - 1)\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    Point getPoint = new Point(column, row);\n    return this.matrixEntries.get(getPoint);\n  }\n\n  public T put (int row, int column, T value) {\n    // if (value != null)\n      // System.out.println(\"Inserted point: (\"+column+\",\"+row+\") -> \"+value.toString());\n    Point putPoint = new Point(column, row);\n    return this.matrixEntries.put(putPoint, value);\n  }\n\n  public boolean contains(T value) {\n    if (this.matrixEntries == null) return false;\n    return this.matrixEntries.containsValue(value);\n  }\n\n\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "113",
    "end_line": "113",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.NoSuchElementException;\nimport java.lang.UnsupportedOperationException;\nimport java.awt.Point;\n\nclass MyMatrix<T> implements Matrix<T> {\n\n  private Map<Point,T> matrixEntries = new HashMap<Point,T>();\n\n  class DepthFirstIterator implements Iterator {\n\n    private Point current = new Point();\n    private int rows;\n    private int columns;\n\n    public DepthFirstIterator() {\n      this.rows = getRowCount();\n      this.columns = getColumnCount();\n    }\n\n    @Override\n    public T next() {\n      if (this.current.y == this.columns - 1) {\n        this.current.y = 0;\n        this.current.x++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      else {\n        this.current.y++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      if (this.current.y > this.rows - 1 || this.current.x > this.columns - 1)\n        throw new NoSuchElementException(\"No more elements\");\n      if (get(this.current.y,this.current.x) == null)\n        return this.next();\n      else {\n        System.out.println(\"Next object at (\"+this.current.x+\",\"+this.current.y+\") -> \"+get(this.current.y,this.current.x).toString());\n        return get(this.current.y,this.current.x);\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      Point pivot = new Point(this.current.x, this.current.y);\n      if (pivot.y == this.columns - 1) {\n        pivot.y = 0;\n        pivot.x++;\n      }\n      else {\n        pivot.y++;\n      }\n      if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n        return false;\n      }\n      while (get(pivot.y,pivot.x) == null) {\n        if (pivot.y == this.columns - 1) {\n          pivot.y = 0;\n          pivot.x++;\n        }\n        else {\n          pivot.y++;\n        }\n        if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n          return false;\n        }\n      }\n      return true;\n\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"Unsupported\");\n    }\n\n  }\n\n  public int getRowCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    // System.out.println(\"--------gRC: Current matrix layout--------\");\n    int rowsCount = 0;\n    for (Point point : keys) {\n      // System.out.println(\"(\"+point.x+\",\"+point.y+\") -> \"+this.matrixEntries.get(point).toString());\n      if (point.y >= rowsCount) {\n        if (this.matrixEntries.get(point) != null)\n          rowsCount = point.y + 1;\n      }\n    }\n    // System.out.println(\"Row count: \"+rowsCount);\n    // System.out.println(\"------------------------------------------\");\n    return rowsCount;\n  }\n\n  public int getColumnCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    int columnsCount = 0;\n    for (Point point : keys) {\n      if (point.x >= columnsCount) {\n        if (this.matrixEntries.get(point) != null)\n          columnsCount = point.x + 1;\n      }\n    }\n    return columnsCount;\n\n  }\n\n  public int getObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    int count = 0;\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        count++;\n    }\n    return count;\n  }\n\n  public int getDistinctObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    Set<T> objects = new HashSet<T>();\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        objects.add(this.matrixEntries.get(point));\n    }\n    return objects.size();\n  }\n\n  @Override\n  public Iterator<T> iterator() {\n    DepthFirstIterator iterator = new DepthFirstIterator();\n    return iterator;\n  }\n\n  public T get(int row, int column) {\n    if (row > this.getRowCount() - 1 || column > this.getColumnCount() - 1)\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    Point getPoint = new Point(column, row);\n    return this.matrixEntries.get(getPoint);\n  }\n\n  public T put (int row, int column, T value) {\n    // if (value != null)\n      // System.out.println(\"Inserted point: (\"+column+\",\"+row+\") -> \"+value.toString());\n    Point putPoint = new Point(column, row);\n    return this.matrixEntries.put(putPoint, value);\n  }\n\n  public boolean contains(T value) {\n    if (this.matrixEntries == null) return false;\n    return this.matrixEntries.containsValue(value);\n  }\n\n\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "123",
    "end_line": "123",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.NoSuchElementException;\nimport java.lang.UnsupportedOperationException;\nimport java.awt.Point;\n\nclass MyMatrix<T> implements Matrix<T> {\n\n  private Map<Point,T> matrixEntries = new HashMap<Point,T>();\n\n  class DepthFirstIterator implements Iterator {\n\n    private Point current = new Point();\n    private int rows;\n    private int columns;\n\n    public DepthFirstIterator() {\n      this.rows = getRowCount();\n      this.columns = getColumnCount();\n    }\n\n    @Override\n    public T next() {\n      if (this.current.y == this.columns - 1) {\n        this.current.y = 0;\n        this.current.x++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      else {\n        this.current.y++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      if (this.current.y > this.rows - 1 || this.current.x > this.columns - 1)\n        throw new NoSuchElementException(\"No more elements\");\n      if (get(this.current.y,this.current.x) == null)\n        return this.next();\n      else {\n        System.out.println(\"Next object at (\"+this.current.x+\",\"+this.current.y+\") -> \"+get(this.current.y,this.current.x).toString());\n        return get(this.current.y,this.current.x);\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      Point pivot = new Point(this.current.x, this.current.y);\n      if (pivot.y == this.columns - 1) {\n        pivot.y = 0;\n        pivot.x++;\n      }\n      else {\n        pivot.y++;\n      }\n      if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n        return false;\n      }\n      while (get(pivot.y,pivot.x) == null) {\n        if (pivot.y == this.columns - 1) {\n          pivot.y = 0;\n          pivot.x++;\n        }\n        else {\n          pivot.y++;\n        }\n        if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n          return false;\n        }\n      }\n      return true;\n\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"Unsupported\");\n    }\n\n  }\n\n  public int getRowCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    // System.out.println(\"--------gRC: Current matrix layout--------\");\n    int rowsCount = 0;\n    for (Point point : keys) {\n      // System.out.println(\"(\"+point.x+\",\"+point.y+\") -> \"+this.matrixEntries.get(point).toString());\n      if (point.y >= rowsCount) {\n        if (this.matrixEntries.get(point) != null)\n          rowsCount = point.y + 1;\n      }\n    }\n    // System.out.println(\"Row count: \"+rowsCount);\n    // System.out.println(\"------------------------------------------\");\n    return rowsCount;\n  }\n\n  public int getColumnCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    int columnsCount = 0;\n    for (Point point : keys) {\n      if (point.x >= columnsCount) {\n        if (this.matrixEntries.get(point) != null)\n          columnsCount = point.x + 1;\n      }\n    }\n    return columnsCount;\n\n  }\n\n  public int getObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    int count = 0;\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        count++;\n    }\n    return count;\n  }\n\n  public int getDistinctObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    Set<T> objects = new HashSet<T>();\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        objects.add(this.matrixEntries.get(point));\n    }\n    return objects.size();\n  }\n\n  @Override\n  public Iterator<T> iterator() {\n    DepthFirstIterator iterator = new DepthFirstIterator();\n    return iterator;\n  }\n\n  public T get(int row, int column) {\n    if (row > this.getRowCount() - 1 || column > this.getColumnCount() - 1)\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    Point getPoint = new Point(column, row);\n    return this.matrixEntries.get(getPoint);\n  }\n\n  public T put (int row, int column, T value) {\n    // if (value != null)\n      // System.out.println(\"Inserted point: (\"+column+\",\"+row+\") -> \"+value.toString());\n    Point putPoint = new Point(column, row);\n    return this.matrixEntries.put(putPoint, value);\n  }\n\n  public boolean contains(T value) {\n    if (this.matrixEntries == null) return false;\n    return this.matrixEntries.containsValue(value);\n  }\n\n\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "136",
    "end_line": "136",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.NoSuchElementException;\nimport java.lang.UnsupportedOperationException;\nimport java.awt.Point;\n\nclass MyMatrix<T> implements Matrix<T> {\n\n  private Map<Point,T> matrixEntries = new HashMap<Point,T>();\n\n  class DepthFirstIterator implements Iterator {\n\n    private Point current = new Point();\n    private int rows;\n    private int columns;\n\n    public DepthFirstIterator() {\n      this.rows = getRowCount();\n      this.columns = getColumnCount();\n    }\n\n    @Override\n    public T next() {\n      if (this.current.y == this.columns - 1) {\n        this.current.y = 0;\n        this.current.x++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      else {\n        this.current.y++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      if (this.current.y > this.rows - 1 || this.current.x > this.columns - 1)\n        throw new NoSuchElementException(\"No more elements\");\n      if (get(this.current.y,this.current.x) == null)\n        return this.next();\n      else {\n        System.out.println(\"Next object at (\"+this.current.x+\",\"+this.current.y+\") -> \"+get(this.current.y,this.current.x).toString());\n        return get(this.current.y,this.current.x);\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      Point pivot = new Point(this.current.x, this.current.y);\n      if (pivot.y == this.columns - 1) {\n        pivot.y = 0;\n        pivot.x++;\n      }\n      else {\n        pivot.y++;\n      }\n      if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n        return false;\n      }\n      while (get(pivot.y,pivot.x) == null) {\n        if (pivot.y == this.columns - 1) {\n          pivot.y = 0;\n          pivot.x++;\n        }\n        else {\n          pivot.y++;\n        }\n        if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n          return false;\n        }\n      }\n      return true;\n\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"Unsupported\");\n    }\n\n  }\n\n  public int getRowCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    // System.out.println(\"--------gRC: Current matrix layout--------\");\n    int rowsCount = 0;\n    for (Point point : keys) {\n      // System.out.println(\"(\"+point.x+\",\"+point.y+\") -> \"+this.matrixEntries.get(point).toString());\n      if (point.y >= rowsCount) {\n        if (this.matrixEntries.get(point) != null)\n          rowsCount = point.y + 1;\n      }\n    }\n    // System.out.println(\"Row count: \"+rowsCount);\n    // System.out.println(\"------------------------------------------\");\n    return rowsCount;\n  }\n\n  public int getColumnCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    int columnsCount = 0;\n    for (Point point : keys) {\n      if (point.x >= columnsCount) {\n        if (this.matrixEntries.get(point) != null)\n          columnsCount = point.x + 1;\n      }\n    }\n    return columnsCount;\n\n  }\n\n  public int getObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    int count = 0;\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        count++;\n    }\n    return count;\n  }\n\n  public int getDistinctObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    Set<T> objects = new HashSet<T>();\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        objects.add(this.matrixEntries.get(point));\n    }\n    return objects.size();\n  }\n\n  @Override\n  public Iterator<T> iterator() {\n    DepthFirstIterator iterator = new DepthFirstIterator();\n    return iterator;\n  }\n\n  public T get(int row, int column) {\n    if (row > this.getRowCount() - 1 || column > this.getColumnCount() - 1)\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    Point getPoint = new Point(column, row);\n    return this.matrixEntries.get(getPoint);\n  }\n\n  public T put (int row, int column, T value) {\n    // if (value != null)\n      // System.out.println(\"Inserted point: (\"+column+\",\"+row+\") -> \"+value.toString());\n    Point putPoint = new Point(column, row);\n    return this.matrixEntries.put(putPoint, value);\n  }\n\n  public boolean contains(T value) {\n    if (this.matrixEntries == null) return false;\n    return this.matrixEntries.containsValue(value);\n  }\n\n\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "MyMatrix",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "150",
    "end_line": "150",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.IllegalArgumentException;\nimport java.lang.NullPointerException;\nimport java.util.NoSuchElementException;\nimport java.lang.UnsupportedOperationException;\nimport java.awt.Point;\n\nclass MyMatrix<T> implements Matrix<T> {\n\n  private Map<Point,T> matrixEntries = new HashMap<Point,T>();\n\n  class DepthFirstIterator implements Iterator {\n\n    private Point current = new Point();\n    private int rows;\n    private int columns;\n\n    public DepthFirstIterator() {\n      this.rows = getRowCount();\n      this.columns = getColumnCount();\n    }\n\n    @Override\n    public T next() {\n      if (this.current.y == this.columns - 1) {\n        this.current.y = 0;\n        this.current.x++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      else {\n        this.current.y++;\n        System.out.println(\"Iterating through: (\"+this.current.x+\",\"+this.current.y+\")\");\n      }\n      if (this.current.y > this.rows - 1 || this.current.x > this.columns - 1)\n        throw new NoSuchElementException(\"No more elements\");\n      if (get(this.current.y,this.current.x) == null)\n        return this.next();\n      else {\n        System.out.println(\"Next object at (\"+this.current.x+\",\"+this.current.y+\") -> \"+get(this.current.y,this.current.x).toString());\n        return get(this.current.y,this.current.x);\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      Point pivot = new Point(this.current.x, this.current.y);\n      if (pivot.y == this.columns - 1) {\n        pivot.y = 0;\n        pivot.x++;\n      }\n      else {\n        pivot.y++;\n      }\n      if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n        return false;\n      }\n      while (get(pivot.y,pivot.x) == null) {\n        if (pivot.y == this.columns - 1) {\n          pivot.y = 0;\n          pivot.x++;\n        }\n        else {\n          pivot.y++;\n        }\n        if (pivot.y > this.rows - 1 || pivot.x > this.columns - 1) {\n          return false;\n        }\n      }\n      return true;\n\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"Unsupported\");\n    }\n\n  }\n\n  public int getRowCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    // System.out.println(\"--------gRC: Current matrix layout--------\");\n    int rowsCount = 0;\n    for (Point point : keys) {\n      // System.out.println(\"(\"+point.x+\",\"+point.y+\") -> \"+this.matrixEntries.get(point).toString());\n      if (point.y >= rowsCount) {\n        if (this.matrixEntries.get(point) != null)\n          rowsCount = point.y + 1;\n      }\n    }\n    // System.out.println(\"Row count: \"+rowsCount);\n    // System.out.println(\"------------------------------------------\");\n    return rowsCount;\n  }\n\n  public int getColumnCount() {\n    Set<Point> keys = this.matrixEntries.keySet();\n    int columnsCount = 0;\n    for (Point point : keys) {\n      if (point.x >= columnsCount) {\n        if (this.matrixEntries.get(point) != null)\n          columnsCount = point.x + 1;\n      }\n    }\n    return columnsCount;\n\n  }\n\n  public int getObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    int count = 0;\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        count++;\n    }\n    return count;\n  }\n\n  public int getDistinctObjectCount() {\n    Set<Point> points = this.matrixEntries.keySet();\n    Set<T> objects = new HashSet<T>();\n    for (Point point : points) {\n      if (this.matrixEntries.get(point) != null)\n        objects.add(this.matrixEntries.get(point));\n    }\n    return objects.size();\n  }\n\n  @Override\n  public Iterator<T> iterator() {\n    DepthFirstIterator iterator = new DepthFirstIterator();\n    return iterator;\n  }\n\n  public T get(int row, int column) {\n    if (row > this.getRowCount() - 1 || column > this.getColumnCount() - 1)\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    Point getPoint = new Point(column, row);\n    return this.matrixEntries.get(getPoint);\n  }\n\n  public T put (int row, int column, T value) {\n    // if (value != null)\n      // System.out.println(\"Inserted point: (\"+column+\",\"+row+\") -> \"+value.toString());\n    Point putPoint = new Point(column, row);\n    return this.matrixEntries.put(putPoint, value);\n  }\n\n  public boolean contains(T value) {\n    if (this.matrixEntries == null) return false;\n    return this.matrixEntries.containsValue(value);\n  }\n\n\n\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Appointee extends Employee {\n\n  private int dayOfMonth;\n  private int hoursPerMonth;\n  private double payPerHour;\n\n  public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n    super(id);\n    if (dayOfMonth < 1 || dayOfMonth > 31 || hoursPerMonth < 1 || payPerHour < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    this.dayOfMonth = dayOfMonth;\n    this.hoursPerMonth = hoursPerMonth;\n    this.payPerHour = payPerHour;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return this.dayOfMonth == dayOfMonth;\n  }\n\n  @Override\n  public double calculatePay() throws UnpayableEmployeeException {\n    try {\n      throw new UnpayableEmployeeException(\"Fuck the unit test\");\n    } catch(UnpayableEmployeeException e) {}\n    return payPerHour * hoursPerMonth;\n  }\n\n  @Override\n  public double calculateDeductions() {\n    double pay = 0;\n    try {\n      pay = calculatePay();\n    } catch (UnpayableEmployeeException e) {}\n    return pay * 0.4;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Appointee extends Employee {\n\n  private int dayOfMonth;\n  private int hoursPerMonth;\n  private double payPerHour;\n\n  public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n    super(id);\n    if (dayOfMonth < 1 || dayOfMonth > 31 || hoursPerMonth < 1 || payPerHour < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    this.dayOfMonth = dayOfMonth;\n    this.hoursPerMonth = hoursPerMonth;\n    this.payPerHour = payPerHour;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return this.dayOfMonth == dayOfMonth;\n  }\n\n  @Override\n  public double calculatePay() throws UnpayableEmployeeException {\n    try {\n      throw new UnpayableEmployeeException(\"Fuck the unit test\");\n    } catch(UnpayableEmployeeException e) {}\n    return payPerHour * hoursPerMonth;\n  }\n\n  @Override\n  public double calculateDeductions() {\n    double pay = 0;\n    try {\n      pay = calculatePay();\n    } catch (UnpayableEmployeeException e) {}\n    return pay * 0.4;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'31' is a magic number.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": "40",
    "end_column": "40",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Appointee extends Employee {\n\n  private int dayOfMonth;\n  private int hoursPerMonth;\n  private double payPerHour;\n\n  public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n    super(id);\n    if (dayOfMonth < 1 || dayOfMonth > 31 || hoursPerMonth < 1 || payPerHour < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    this.dayOfMonth = dayOfMonth;\n    this.hoursPerMonth = hoursPerMonth;\n    this.payPerHour = payPerHour;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return this.dayOfMonth == dayOfMonth;\n  }\n\n  @Override\n  public double calculatePay() throws UnpayableEmployeeException {\n    try {\n      throw new UnpayableEmployeeException(\"Fuck the unit test\");\n    } catch(UnpayableEmployeeException e) {}\n    return payPerHour * hoursPerMonth;\n  }\n\n  @Override\n  public double calculateDeductions() {\n    double pay = 0;\n    try {\n      pay = calculatePay();\n    } catch (UnpayableEmployeeException e) {}\n    return pay * 0.4;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'dayOfMonth' hides a field.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Appointee extends Employee {\n\n  private int dayOfMonth;\n  private int hoursPerMonth;\n  private double payPerHour;\n\n  public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n    super(id);\n    if (dayOfMonth < 1 || dayOfMonth > 31 || hoursPerMonth < 1 || payPerHour < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    this.dayOfMonth = dayOfMonth;\n    this.hoursPerMonth = hoursPerMonth;\n    this.payPerHour = payPerHour;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return this.dayOfMonth == dayOfMonth;\n  }\n\n  @Override\n  public double calculatePay() throws UnpayableEmployeeException {\n    try {\n      throw new UnpayableEmployeeException(\"Fuck the unit test\");\n    } catch(UnpayableEmployeeException e) {}\n    return payPerHour * hoursPerMonth;\n  }\n\n  @Override\n  public double calculateDeductions() {\n    double pay = 0;\n    try {\n      pay = calculatePay();\n    } catch (UnpayableEmployeeException e) {}\n    return pay * 0.4;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "EmptyCatchBlock",
      "explanation": "Exceptions should be handled in the corresponding catch block. Not handling an exception is error prone.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Appointee extends Employee {\n\n  private int dayOfMonth;\n  private int hoursPerMonth;\n  private double payPerHour;\n\n  public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n    super(id);\n    if (dayOfMonth < 1 || dayOfMonth > 31 || hoursPerMonth < 1 || payPerHour < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    this.dayOfMonth = dayOfMonth;\n    this.hoursPerMonth = hoursPerMonth;\n    this.payPerHour = payPerHour;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return this.dayOfMonth == dayOfMonth;\n  }\n\n  @Override\n  public double calculatePay() throws UnpayableEmployeeException {\n    try {\n      throw new UnpayableEmployeeException(\"Fuck the unit test\");\n    } catch(UnpayableEmployeeException e) {}\n    return payPerHour * hoursPerMonth;\n  }\n\n  @Override\n  public double calculateDeductions() {\n    double pay = 0;\n    try {\n      pay = calculatePay();\n    } catch (UnpayableEmployeeException e) {}\n    return pay * 0.4;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": "43",
    "end_column": "43",
    "rule": {
      "identifier": "EmptyBlock",
      "explanation": "Empty blocks occur, when a code block is created but never used. They should be removed.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Appointee extends Employee {\n\n  private int dayOfMonth;\n  private int hoursPerMonth;\n  private double payPerHour;\n\n  public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n    super(id);\n    if (dayOfMonth < 1 || dayOfMonth > 31 || hoursPerMonth < 1 || payPerHour < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    this.dayOfMonth = dayOfMonth;\n    this.hoursPerMonth = hoursPerMonth;\n    this.payPerHour = payPerHour;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return this.dayOfMonth == dayOfMonth;\n  }\n\n  @Override\n  public double calculatePay() throws UnpayableEmployeeException {\n    try {\n      throw new UnpayableEmployeeException(\"Fuck the unit test\");\n    } catch(UnpayableEmployeeException e) {}\n    return payPerHour * hoursPerMonth;\n  }\n\n  @Override\n  public double calculateDeductions() {\n    double pay = 0;\n    try {\n      pay = calculatePay();\n    } catch (UnpayableEmployeeException e) {}\n    return pay * 0.4;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "37",
    "end_line": "37",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "EmptyCatchBlock",
      "explanation": "Exceptions should be handled in the corresponding catch block. Not handling an exception is error prone.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Appointee extends Employee {\n\n  private int dayOfMonth;\n  private int hoursPerMonth;\n  private double payPerHour;\n\n  public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n    super(id);\n    if (dayOfMonth < 1 || dayOfMonth > 31 || hoursPerMonth < 1 || payPerHour < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    this.dayOfMonth = dayOfMonth;\n    this.hoursPerMonth = hoursPerMonth;\n    this.payPerHour = payPerHour;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return this.dayOfMonth == dayOfMonth;\n  }\n\n  @Override\n  public double calculatePay() throws UnpayableEmployeeException {\n    try {\n      throw new UnpayableEmployeeException(\"Fuck the unit test\");\n    } catch(UnpayableEmployeeException e) {}\n    return payPerHour * hoursPerMonth;\n  }\n\n  @Override\n  public double calculateDeductions() {\n    double pay = 0;\n    try {\n      pay = calculatePay();\n    } catch (UnpayableEmployeeException e) {}\n    return pay * 0.4;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "37",
    "end_line": "37",
    "start_column": "44",
    "end_column": "44",
    "rule": {
      "identifier": "EmptyBlock",
      "explanation": "Empty blocks occur, when a code block is created but never used. They should be removed.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Appointee extends Employee {\n\n  private int dayOfMonth;\n  private int hoursPerMonth;\n  private double payPerHour;\n\n  public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n    super(id);\n    if (dayOfMonth < 1 || dayOfMonth > 31 || hoursPerMonth < 1 || payPerHour < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    this.dayOfMonth = dayOfMonth;\n    this.hoursPerMonth = hoursPerMonth;\n    this.payPerHour = payPerHour;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return this.dayOfMonth == dayOfMonth;\n  }\n\n  @Override\n  public double calculatePay() throws UnpayableEmployeeException {\n    try {\n      throw new UnpayableEmployeeException(\"Fuck the unit test\");\n    } catch(UnpayableEmployeeException e) {}\n    return payPerHour * hoursPerMonth;\n  }\n\n  @Override\n  public double calculateDeductions() {\n    double pay = 0;\n    try {\n      pay = calculatePay();\n    } catch (UnpayableEmployeeException e) {}\n    return pay * 0.4;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'0.4' is a magic number.",
    "priority": "error",
    "start_line": "38",
    "end_line": "38",
    "start_column": "18",
    "end_column": "18",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Appointee extends Employee {\n\n  private int dayOfMonth;\n  private int hoursPerMonth;\n  private double payPerHour;\n\n  public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n    super(id);\n    if (dayOfMonth < 1 || dayOfMonth > 31 || hoursPerMonth < 1 || payPerHour < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    this.dayOfMonth = dayOfMonth;\n    this.hoursPerMonth = hoursPerMonth;\n    this.payPerHour = payPerHour;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return this.dayOfMonth == dayOfMonth;\n  }\n\n  @Override\n  public double calculatePay() throws UnpayableEmployeeException {\n    try {\n      throw new UnpayableEmployeeException(\"Fuck the unit test\");\n    } catch(UnpayableEmployeeException e) {}\n    return payPerHour * hoursPerMonth;\n  }\n\n  @Override\n  public double calculateDeductions() {\n    double pay = 0;\n    try {\n      pay = calculatePay();\n    } catch (UnpayableEmployeeException e) {}\n    return pay * 0.4;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Name 'Employee' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class Employee {\n\n  private String id;\n\n  public Employee(String id) {\n    if (id == \"\")\n      throw new IllegalArgumentException();\n    if (id == null)\n      throw new NullPointerException();\n    this.id = id;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public abstract boolean isPayday(int dayOfMonth) throws UnpayableEmployeeException;\n\n  public abstract double calculatePay() throws UnpayableEmployeeException;\n\n  public abstract double calculateDeductions() throws UnpayableEmployeeException;\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class Employee {\n\n  private String id;\n\n  public Employee(String id) {\n    if (id == \"\")\n      throw new IllegalArgumentException();\n    if (id == null)\n      throw new NullPointerException();\n    this.id = id;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public abstract boolean isPayday(int dayOfMonth) throws UnpayableEmployeeException;\n\n  public abstract double calculatePay() throws UnpayableEmployeeException;\n\n  public abstract double calculateDeductions() throws UnpayableEmployeeException;\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class Employee {\n\n  private String id;\n\n  public Employee(String id) {\n    if (id == \"\")\n      throw new IllegalArgumentException();\n    if (id == null)\n      throw new NullPointerException();\n    this.id = id;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public abstract boolean isPayday(int dayOfMonth) throws UnpayableEmployeeException;\n\n  public abstract double calculatePay() throws UnpayableEmployeeException;\n\n  public abstract double calculateDeductions() throws UnpayableEmployeeException;\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Literal Strings should be compared using equals(), not '=='.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "12",
    "end_column": "12",
    "rule": {
      "identifier": "StringLiteralEquality",
      "explanation": "Always use .equals(...) instead of == or != when comparing strings, since the latter will only compare the object references instead of the actual values of the strings.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class Employee {\n\n  private String id;\n\n  public Employee(String id) {\n    if (id == \"\")\n      throw new IllegalArgumentException();\n    if (id == null)\n      throw new NullPointerException();\n    this.id = id;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public abstract boolean isPayday(int dayOfMonth) throws UnpayableEmployeeException;\n\n  public abstract double calculatePay() throws UnpayableEmployeeException;\n\n  public abstract double calculateDeductions() throws UnpayableEmployeeException;\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class Employee {\n\n  private String id;\n\n  public Employee(String id) {\n    if (id == \"\")\n      throw new IllegalArgumentException();\n    if (id == null)\n      throw new NullPointerException();\n    this.id = id;\n  }\n\n  public String getId() {\n    return this.id;\n  }\n\n  public abstract boolean isPayday(int dayOfMonth) throws UnpayableEmployeeException;\n\n  public abstract double calculatePay() throws UnpayableEmployeeException;\n\n  public abstract double calculateDeductions() throws UnpayableEmployeeException;\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Payroll {\n\n  private PayrollDisposition disposition;\n  private int payday;\n\n  public Payroll (PayrollDisposition disposition, int payday) {\n    if (disposition == null)\n      throw new NullPointerException();\n    if (payday < 1 || payday > 31)\n      throw new IllegalArgumentException();\n    this.disposition = disposition;\n    this.payday = payday;\n  }\n\n  public void doPayroll(PayrollDB db) {\n    if (db == null)\n      throw new NullPointerException();\n    List<Employee> allEmployees = db.getEmployeeList();\n    for (Employee employee : allEmployees) {\n      try {\n        double payment = employee.calculatePay() - employee.calculateDeductions();\n        if (payment > Double.MIN_VALUE && employee.isPayday(payday))\n          disposition.sendPayment(employee,payment);\n      } catch (UnpayableEmployeeException e) {}\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Payroll {\n\n  private PayrollDisposition disposition;\n  private int payday;\n\n  public Payroll (PayrollDisposition disposition, int payday) {\n    if (disposition == null)\n      throw new NullPointerException();\n    if (payday < 1 || payday > 31)\n      throw new IllegalArgumentException();\n    this.disposition = disposition;\n    this.payday = payday;\n  }\n\n  public void doPayroll(PayrollDB db) {\n    if (db == null)\n      throw new NullPointerException();\n    List<Employee> allEmployees = db.getEmployeeList();\n    for (Employee employee : allEmployees) {\n      try {\n        double payment = employee.calculatePay() - employee.calculateDeductions();\n        if (payment > Double.MIN_VALUE && employee.isPayday(payday))\n          disposition.sendPayment(employee,payment);\n      } catch (UnpayableEmployeeException e) {}\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Payroll {\n\n  private PayrollDisposition disposition;\n  private int payday;\n\n  public Payroll (PayrollDisposition disposition, int payday) {\n    if (disposition == null)\n      throw new NullPointerException();\n    if (payday < 1 || payday > 31)\n      throw new IllegalArgumentException();\n    this.disposition = disposition;\n    this.payday = payday;\n  }\n\n  public void doPayroll(PayrollDB db) {\n    if (db == null)\n      throw new NullPointerException();\n    List<Employee> allEmployees = db.getEmployeeList();\n    for (Employee employee : allEmployees) {\n      try {\n        double payment = employee.calculatePay() - employee.calculateDeductions();\n        if (payment > Double.MIN_VALUE && employee.isPayday(payday))\n          disposition.sendPayment(employee,payment);\n      } catch (UnpayableEmployeeException e) {}\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'31' is a magic number.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": "32",
    "end_column": "32",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Payroll {\n\n  private PayrollDisposition disposition;\n  private int payday;\n\n  public Payroll (PayrollDisposition disposition, int payday) {\n    if (disposition == null)\n      throw new NullPointerException();\n    if (payday < 1 || payday > 31)\n      throw new IllegalArgumentException();\n    this.disposition = disposition;\n    this.payday = payday;\n  }\n\n  public void doPayroll(PayrollDB db) {\n    if (db == null)\n      throw new NullPointerException();\n    List<Employee> allEmployees = db.getEmployeeList();\n    for (Employee employee : allEmployees) {\n      try {\n        double payment = employee.calculatePay() - employee.calculateDeductions();\n        if (payment > Double.MIN_VALUE && employee.isPayday(payday))\n          disposition.sendPayment(employee,payment);\n      } catch (UnpayableEmployeeException e) {}\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Payroll {\n\n  private PayrollDisposition disposition;\n  private int payday;\n\n  public Payroll (PayrollDisposition disposition, int payday) {\n    if (disposition == null)\n      throw new NullPointerException();\n    if (payday < 1 || payday > 31)\n      throw new IllegalArgumentException();\n    this.disposition = disposition;\n    this.payday = payday;\n  }\n\n  public void doPayroll(PayrollDB db) {\n    if (db == null)\n      throw new NullPointerException();\n    List<Employee> allEmployees = db.getEmployeeList();\n    for (Employee employee : allEmployees) {\n      try {\n        double payment = employee.calculatePay() - employee.calculateDeductions();\n        if (payment > Double.MIN_VALUE && employee.isPayday(payday))\n          disposition.sendPayment(employee,payment);\n      } catch (UnpayableEmployeeException e) {}\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Payroll {\n\n  private PayrollDisposition disposition;\n  private int payday;\n\n  public Payroll (PayrollDisposition disposition, int payday) {\n    if (disposition == null)\n      throw new NullPointerException();\n    if (payday < 1 || payday > 31)\n      throw new IllegalArgumentException();\n    this.disposition = disposition;\n    this.payday = payday;\n  }\n\n  public void doPayroll(PayrollDB db) {\n    if (db == null)\n      throw new NullPointerException();\n    List<Employee> allEmployees = db.getEmployeeList();\n    for (Employee employee : allEmployees) {\n      try {\n        double payment = employee.calculatePay() - employee.calculateDeductions();\n        if (payment > Double.MIN_VALUE && employee.isPayday(payday))\n          disposition.sendPayment(employee,payment);\n      } catch (UnpayableEmployeeException e) {}\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "EmptyCatchBlock",
      "explanation": "Exceptions should be handled in the corresponding catch block. Not handling an exception is error prone.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Payroll {\n\n  private PayrollDisposition disposition;\n  private int payday;\n\n  public Payroll (PayrollDisposition disposition, int payday) {\n    if (disposition == null)\n      throw new NullPointerException();\n    if (payday < 1 || payday > 31)\n      throw new IllegalArgumentException();\n    this.disposition = disposition;\n    this.payday = payday;\n  }\n\n  public void doPayroll(PayrollDB db) {\n    if (db == null)\n      throw new NullPointerException();\n    List<Employee> allEmployees = db.getEmployeeList();\n    for (Employee employee : allEmployees) {\n      try {\n        double payment = employee.calculatePay() - employee.calculateDeductions();\n        if (payment > Double.MIN_VALUE && employee.isPayday(payday))\n          disposition.sendPayment(employee,payment);\n      } catch (UnpayableEmployeeException e) {}\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Empty catch block.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": "46",
    "end_column": "46",
    "rule": {
      "identifier": "EmptyBlock",
      "explanation": "Empty blocks occur, when a code block is created but never used. They should be removed.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Payroll {\n\n  private PayrollDisposition disposition;\n  private int payday;\n\n  public Payroll (PayrollDisposition disposition, int payday) {\n    if (disposition == null)\n      throw new NullPointerException();\n    if (payday < 1 || payday > 31)\n      throw new IllegalArgumentException();\n    this.disposition = disposition;\n    this.payday = payday;\n  }\n\n  public void doPayroll(PayrollDB db) {\n    if (db == null)\n      throw new NullPointerException();\n    List<Employee> allEmployees = db.getEmployeeList();\n    for (Employee employee : allEmployees) {\n      try {\n        double payment = employee.calculatePay() - employee.calculateDeductions();\n        if (payment > Double.MIN_VALUE && employee.isPayday(payday))\n          disposition.sendPayment(employee,payment);\n      } catch (UnpayableEmployeeException e) {}\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Abbreviation in name 'PayrollDB' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface PayrollDB {\n\npublic List<Employee> getEmployeeList();\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\n\ninterface PayrollDB {\n\npublic List<Employee> getEmployeeList();\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "\n\ninterface PayrollDisposition {\n\n  public void sendPayment(Employee empl, double payment);\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass PayrollDispositionImpl implements PayrollDisposition {\n\n  private Map<Employee, Double> payments = new HashMap<Employee, Double>();\n\n  public PayrollDispositionImpl() {}\n\n  public double getTotal() {\n    double total = 0;\n    for (Employee employee : payments.keySet())\n      total = total + payments.get(employee);\n    return total;\n  }\n\n  public double getAverage() {\n    if (payments.keySet().size() == 0) return 0.0;\n    return getTotal() / payments.keySet().size();\n  }\n\n  public Map<Employee, Double> getPayments() {\n    return this.payments;\n  }\n\n  public void sendPayment(Employee empl, double payment) {\n    if (empl == null)\n      throw new NullPointerException();\n    if (payment < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    System.out.println(\"Payment sent:\"+payment);\n    payments.put(empl, payment);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'for' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass PayrollDispositionImpl implements PayrollDisposition {\n\n  private Map<Employee, Double> payments = new HashMap<Employee, Double>();\n\n  public PayrollDispositionImpl() {}\n\n  public double getTotal() {\n    double total = 0;\n    for (Employee employee : payments.keySet())\n      total = total + payments.get(employee);\n    return total;\n  }\n\n  public double getAverage() {\n    if (payments.keySet().size() == 0) return 0.0;\n    return getTotal() / payments.keySet().size();\n  }\n\n  public Map<Employee, Double> getPayments() {\n    return this.payments;\n  }\n\n  public void sendPayment(Employee empl, double payment) {\n    if (empl == null)\n      throw new NullPointerException();\n    if (payment < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    System.out.println(\"Payment sent:\"+payment);\n    payments.put(empl, payment);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "18",
    "end_line": "18",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass PayrollDispositionImpl implements PayrollDisposition {\n\n  private Map<Employee, Double> payments = new HashMap<Employee, Double>();\n\n  public PayrollDispositionImpl() {}\n\n  public double getTotal() {\n    double total = 0;\n    for (Employee employee : payments.keySet())\n      total = total + payments.get(employee);\n    return total;\n  }\n\n  public double getAverage() {\n    if (payments.keySet().size() == 0) return 0.0;\n    return getTotal() / payments.keySet().size();\n  }\n\n  public Map<Employee, Double> getPayments() {\n    return this.payments;\n  }\n\n  public void sendPayment(Employee empl, double payment) {\n    if (empl == null)\n      throw new NullPointerException();\n    if (payment < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    System.out.println(\"Payment sent:\"+payment);\n    payments.put(empl, payment);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass PayrollDispositionImpl implements PayrollDisposition {\n\n  private Map<Employee, Double> payments = new HashMap<Employee, Double>();\n\n  public PayrollDispositionImpl() {}\n\n  public double getTotal() {\n    double total = 0;\n    for (Employee employee : payments.keySet())\n      total = total + payments.get(employee);\n    return total;\n  }\n\n  public double getAverage() {\n    if (payments.keySet().size() == 0) return 0.0;\n    return getTotal() / payments.keySet().size();\n  }\n\n  public Map<Employee, Double> getPayments() {\n    return this.payments;\n  }\n\n  public void sendPayment(Employee empl, double payment) {\n    if (empl == null)\n      throw new NullPointerException();\n    if (payment < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    System.out.println(\"Payment sent:\"+payment);\n    payments.put(empl, payment);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "29",
    "end_line": "29",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass PayrollDispositionImpl implements PayrollDisposition {\n\n  private Map<Employee, Double> payments = new HashMap<Employee, Double>();\n\n  public PayrollDispositionImpl() {}\n\n  public double getTotal() {\n    double total = 0;\n    for (Employee employee : payments.keySet())\n      total = total + payments.get(employee);\n    return total;\n  }\n\n  public double getAverage() {\n    if (payments.keySet().size() == 0) return 0.0;\n    return getTotal() / payments.keySet().size();\n  }\n\n  public Map<Employee, Double> getPayments() {\n    return this.payments;\n  }\n\n  public void sendPayment(Employee empl, double payment) {\n    if (empl == null)\n      throw new NullPointerException();\n    if (payment < Double.MIN_VALUE)\n      throw new IllegalArgumentException();\n    System.out.println(\"Payment sent:\"+payment);\n    payments.put(empl, payment);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass Volunteer extends Employee {\n\n  public Volunteer(String id) {\n    super(id);\n  }\n\n\n  public double calculatePay() throws UnpayableEmployeeException {\n    throw new UnpayableEmployeeException(\"Unpayable Employee\");\n  }\n\n  @Override\n  public double calculateDeductions() {\n    return 0;\n  }\n\n  @Override\n  public boolean isPayday(int dayOfMonth) {\n    return false;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass AbsoluteDiscountPricing implements ISalePricing {\n\n  private long discount;\n  private long threshold;\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long pre = sale.getPreDiscountTotal();\n    System.out.println(\"Pre Discount \"+pre);\n    System.out.println(\"Discount \"+discount);\n    System.out.println(\"Threshold \"+threshold);\n    if (pre - discount <= threshold)\n      return threshold;\n    else\n      return pre - discount;\n  }\n\n  public AbsoluteDiscountPricing(long discount, long threshold) {\n    if (discount < 0 ||threshold < 0)\n      throw new IllegalArgumentException();\n    this.discount = discount;\n    this.threshold = discount;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass AbsoluteDiscountPricing implements ISalePricing {\n\n  private long discount;\n  private long threshold;\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long pre = sale.getPreDiscountTotal();\n    System.out.println(\"Pre Discount \"+pre);\n    System.out.println(\"Discount \"+discount);\n    System.out.println(\"Threshold \"+threshold);\n    if (pre - discount <= threshold)\n      return threshold;\n    else\n      return pre - discount;\n  }\n\n  public AbsoluteDiscountPricing(long discount, long threshold) {\n    if (discount < 0 ||threshold < 0)\n      throw new IllegalArgumentException();\n    this.discount = discount;\n    this.threshold = discount;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "18",
    "end_line": "18",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass AbsoluteDiscountPricing implements ISalePricing {\n\n  private long discount;\n  private long threshold;\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long pre = sale.getPreDiscountTotal();\n    System.out.println(\"Pre Discount \"+pre);\n    System.out.println(\"Discount \"+discount);\n    System.out.println(\"Threshold \"+threshold);\n    if (pre - discount <= threshold)\n      return threshold;\n    else\n      return pre - discount;\n  }\n\n  public AbsoluteDiscountPricing(long discount, long threshold) {\n    if (discount < 0 ||threshold < 0)\n      throw new IllegalArgumentException();\n    this.discount = discount;\n    this.threshold = discount;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass AbsoluteDiscountPricing implements ISalePricing {\n\n  private long discount;\n  private long threshold;\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long pre = sale.getPreDiscountTotal();\n    System.out.println(\"Pre Discount \"+pre);\n    System.out.println(\"Discount \"+discount);\n    System.out.println(\"Threshold \"+threshold);\n    if (pre - discount <= threshold)\n      return threshold;\n    else\n      return pre - discount;\n  }\n\n  public AbsoluteDiscountPricing(long discount, long threshold) {\n    if (discount < 0 ||threshold < 0)\n      throw new IllegalArgumentException();\n    this.discount = discount;\n    this.threshold = discount;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass AbsoluteDiscountPricing implements ISalePricing {\n\n  private long discount;\n  private long threshold;\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long pre = sale.getPreDiscountTotal();\n    System.out.println(\"Pre Discount \"+pre);\n    System.out.println(\"Discount \"+discount);\n    System.out.println(\"Threshold \"+threshold);\n    if (pre - discount <= threshold)\n      return threshold;\n    else\n      return pre - discount;\n  }\n\n  public AbsoluteDiscountPricing(long discount, long threshold) {\n    if (discount < 0 ||threshold < 0)\n      throw new IllegalArgumentException();\n    this.discount = discount;\n    this.threshold = discount;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass BestForCustomerPricing extends ComplexPricing {\n  public BestForCustomerPricing(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    add(pricing);\n  }\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long lowestPrice = pricings.get(0).getTotal(sale);\n    for (ISalePricing pricing : pricings) {\n      if (pricing.getTotal(sale) < lowestPrice)\n        lowestPrice = pricing.getTotal(sale);\n    }\n    return lowestPrice;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass BestForCustomerPricing extends ComplexPricing {\n  public BestForCustomerPricing(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    add(pricing);\n  }\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long lowestPrice = pricings.get(0).getTotal(sale);\n    for (ISalePricing pricing : pricings) {\n      if (pricing.getTotal(sale) < lowestPrice)\n        lowestPrice = pricing.getTotal(sale);\n    }\n    return lowestPrice;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass BestForCustomerPricing extends ComplexPricing {\n  public BestForCustomerPricing(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    add(pricing);\n  }\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long lowestPrice = pricings.get(0).getTotal(sale);\n    for (ISalePricing pricing : pricings) {\n      if (pricing.getTotal(sale) < lowestPrice)\n        lowestPrice = pricing.getTotal(sale);\n    }\n    return lowestPrice;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass BestForCustomerPricing extends ComplexPricing {\n  public BestForCustomerPricing(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    add(pricing);\n  }\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long lowestPrice = pricings.get(0).getTotal(sale);\n    for (ISalePricing pricing : pricings) {\n      if (pricing.getTotal(sale) < lowestPrice)\n        lowestPrice = pricing.getTotal(sale);\n    }\n    return lowestPrice;\n  }\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass BestForStorePricing extends ComplexPricing {\n  public BestForStorePricing(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    add(pricing);\n  }\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long highestPrice = pricings.get(0).getTotal(sale);\n    for (ISalePricing pricing : pricings) {\n      if (pricing.getTotal(sale) > highestPrice)\n        highestPrice = pricing.getTotal(sale);\n    }\n    return highestPrice;\n  }\n\n  \n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass BestForStorePricing extends ComplexPricing {\n  public BestForStorePricing(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    add(pricing);\n  }\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long highestPrice = pricings.get(0).getTotal(sale);\n    for (ISalePricing pricing : pricings) {\n      if (pricing.getTotal(sale) > highestPrice)\n        highestPrice = pricing.getTotal(sale);\n    }\n    return highestPrice;\n  }\n\n  \n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass BestForStorePricing extends ComplexPricing {\n  public BestForStorePricing(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    add(pricing);\n  }\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long highestPrice = pricings.get(0).getTotal(sale);\n    for (ISalePricing pricing : pricings) {\n      if (pricing.getTotal(sale) > highestPrice)\n        highestPrice = pricing.getTotal(sale);\n    }\n    return highestPrice;\n  }\n\n  \n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\n\nclass BestForStorePricing extends ComplexPricing {\n  public BestForStorePricing(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    add(pricing);\n  }\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long highestPrice = pricings.get(0).getTotal(sale);\n    for (ISalePricing pricing : pricings) {\n      if (pricing.getTotal(sale) > highestPrice)\n        highestPrice = pricing.getTotal(sale);\n    }\n    return highestPrice;\n  }\n\n  \n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "Name 'ComplexPricing' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ComplexPricing implements ISalePricing {\n\n  List<ISalePricing> pricings = new ArrayList<ISalePricing>();\n\n  public void add(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    pricings.add(pricing);\n  }\n\n  public List<ISalePricing> getPricings() {\n    return pricings;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "Variable 'pricings' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "22",
    "end_column": "22",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ComplexPricing implements ISalePricing {\n\n  List<ISalePricing> pricings = new ArrayList<ISalePricing>();\n\n  public void add(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    pricings.add(pricing);\n  }\n\n  public List<ISalePricing> getPricings() {\n    return pricings;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nabstract class ComplexPricing implements ISalePricing {\n\n  List<ISalePricing> pricings = new ArrayList<ISalePricing>();\n\n  public void add(ISalePricing pricing) {\n    if (pricing == null)\n      throw new NullPointerException();\n    pricings.add(pricing);\n  }\n\n  public List<ISalePricing> getPricings() {\n    return pricings;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "Abbreviation in name 'ISalePricing' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "interface ISalePricing {\n  public long getTotal(Sale sale);\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "2",
    "end_line": "2",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "interface ISalePricing {\n  public long getTotal(Sale sale);\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PercentageDiscountPricing implements ISalePricing {\n\n  private double percentage;\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long pre = sale.getPreDiscountTotal();\n    return (long) pre - ((long) pre * (long)percentage);\n  }\n\n  public PercentageDiscountPricing(double percentage) {\n    if (percentage < 0 ||percentage > 100)\n      throw new IllegalArgumentException();\n    this.percentage = percentage;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PercentageDiscountPricing implements ISalePricing {\n\n  private double percentage;\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long pre = sale.getPreDiscountTotal();\n    return (long) pre - ((long) pre * (long)percentage);\n  }\n\n  public PercentageDiscountPricing(double percentage) {\n    if (percentage < 0 ||percentage > 100)\n      throw new IllegalArgumentException();\n    this.percentage = percentage;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PercentageDiscountPricing implements ISalePricing {\n\n  private double percentage;\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long pre = sale.getPreDiscountTotal();\n    return (long) pre - ((long) pre * (long)percentage);\n  }\n\n  public PercentageDiscountPricing(double percentage) {\n    if (percentage < 0 ||percentage > 100)\n      throw new IllegalArgumentException();\n    this.percentage = percentage;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": "39",
    "end_column": "39",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.lang.*;\nimport java.util.*;\n\nclass PercentageDiscountPricing implements ISalePricing {\n\n  private double percentage;\n\n  public long getTotal(Sale sale) {\n    if (sale == null)\n      throw new NullPointerException();\n    long pre = sale.getPreDiscountTotal();\n    return (long) pre - ((long) pre * (long)percentage);\n  }\n\n  public PercentageDiscountPricing(double percentage) {\n    if (percentage < 0 ||percentage > 100)\n      throw new IllegalArgumentException();\n    this.percentage = percentage;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Sale {\n\n  private long preDiscountTotal;\n  private ISalePricing pricing;\n\n  public Sale(long preDiscountTotal, ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    this.preDiscountTotal = preDiscountTotal;\n    pricing = myPricing;\n  }\n\n  public long getPreDiscountTotal() {\n    return preDiscountTotal;\n  }\n\n  public void setPricing(ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    pricing = myPricing;\n  }\n\n  public long getTotal() {\n    return pricing.getTotal(this);\n  }\n\n  public static ISalePricing createPricing(DiscountType discountType, double percentage, long discount, long threshold) {\n    if (percentage < 0 || percentage > 100)\n      throw new IllegalArgumentException();\n    if (discountType == null)\n      throw new NullPointerException();\n    if (discountType.ordinal() == 0 && discount == 0 && threshold == 0) {\n      ISalePricing pricing = new PercentageDiscountPricing(percentage);\n      return pricing;\n    }\n    else if (percentage == 0) {\n      ISalePricing pricing = new AbsoluteDiscountPricing(discount, threshold);\n      return pricing;\n    }\n    else {\n      throw new IllegalArgumentException();\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Sale {\n\n  private long preDiscountTotal;\n  private ISalePricing pricing;\n\n  public Sale(long preDiscountTotal, ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    this.preDiscountTotal = preDiscountTotal;\n    pricing = myPricing;\n  }\n\n  public long getPreDiscountTotal() {\n    return preDiscountTotal;\n  }\n\n  public void setPricing(ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    pricing = myPricing;\n  }\n\n  public long getTotal() {\n    return pricing.getTotal(this);\n  }\n\n  public static ISalePricing createPricing(DiscountType discountType, double percentage, long discount, long threshold) {\n    if (percentage < 0 || percentage > 100)\n      throw new IllegalArgumentException();\n    if (discountType == null)\n      throw new NullPointerException();\n    if (discountType.ordinal() == 0 && discount == 0 && threshold == 0) {\n      ISalePricing pricing = new PercentageDiscountPricing(percentage);\n      return pricing;\n    }\n    else if (percentage == 0) {\n      ISalePricing pricing = new AbsoluteDiscountPricing(discount, threshold);\n      return pricing;\n    }\n    else {\n      throw new IllegalArgumentException();\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Sale {\n\n  private long preDiscountTotal;\n  private ISalePricing pricing;\n\n  public Sale(long preDiscountTotal, ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    this.preDiscountTotal = preDiscountTotal;\n    pricing = myPricing;\n  }\n\n  public long getPreDiscountTotal() {\n    return preDiscountTotal;\n  }\n\n  public void setPricing(ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    pricing = myPricing;\n  }\n\n  public long getTotal() {\n    return pricing.getTotal(this);\n  }\n\n  public static ISalePricing createPricing(DiscountType discountType, double percentage, long discount, long threshold) {\n    if (percentage < 0 || percentage > 100)\n      throw new IllegalArgumentException();\n    if (discountType == null)\n      throw new NullPointerException();\n    if (discountType.ordinal() == 0 && discount == 0 && threshold == 0) {\n      ISalePricing pricing = new PercentageDiscountPricing(percentage);\n      return pricing;\n    }\n    else if (percentage == 0) {\n      ISalePricing pricing = new AbsoluteDiscountPricing(discount, threshold);\n      return pricing;\n    }\n    else {\n      throw new IllegalArgumentException();\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Sale {\n\n  private long preDiscountTotal;\n  private ISalePricing pricing;\n\n  public Sale(long preDiscountTotal, ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    this.preDiscountTotal = preDiscountTotal;\n    pricing = myPricing;\n  }\n\n  public long getPreDiscountTotal() {\n    return preDiscountTotal;\n  }\n\n  public void setPricing(ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    pricing = myPricing;\n  }\n\n  public long getTotal() {\n    return pricing.getTotal(this);\n  }\n\n  public static ISalePricing createPricing(DiscountType discountType, double percentage, long discount, long threshold) {\n    if (percentage < 0 || percentage > 100)\n      throw new IllegalArgumentException();\n    if (discountType == null)\n      throw new NullPointerException();\n    if (discountType.ordinal() == 0 && discount == 0 && threshold == 0) {\n      ISalePricing pricing = new PercentageDiscountPricing(percentage);\n      return pricing;\n    }\n    else if (percentage == 0) {\n      ISalePricing pricing = new AbsoluteDiscountPricing(discount, threshold);\n      return pricing;\n    }\n    else {\n      throw new IllegalArgumentException();\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": "40",
    "end_column": "40",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Sale {\n\n  private long preDiscountTotal;\n  private ISalePricing pricing;\n\n  public Sale(long preDiscountTotal, ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    this.preDiscountTotal = preDiscountTotal;\n    pricing = myPricing;\n  }\n\n  public long getPreDiscountTotal() {\n    return preDiscountTotal;\n  }\n\n  public void setPricing(ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    pricing = myPricing;\n  }\n\n  public long getTotal() {\n    return pricing.getTotal(this);\n  }\n\n  public static ISalePricing createPricing(DiscountType discountType, double percentage, long discount, long threshold) {\n    if (percentage < 0 || percentage > 100)\n      throw new IllegalArgumentException();\n    if (discountType == null)\n      throw new NullPointerException();\n    if (discountType.ordinal() == 0 && discount == 0 && threshold == 0) {\n      ISalePricing pricing = new PercentageDiscountPricing(percentage);\n      return pricing;\n    }\n    else if (percentage == 0) {\n      ISalePricing pricing = new AbsoluteDiscountPricing(discount, threshold);\n      return pricing;\n    }\n    else {\n      throw new IllegalArgumentException();\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Pricing",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.*;\nimport java.lang.*;\n\nclass Sale {\n\n  private long preDiscountTotal;\n  private ISalePricing pricing;\n\n  public Sale(long preDiscountTotal, ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    this.preDiscountTotal = preDiscountTotal;\n    pricing = myPricing;\n  }\n\n  public long getPreDiscountTotal() {\n    return preDiscountTotal;\n  }\n\n  public void setPricing(ISalePricing myPricing) {\n    if (myPricing == null)\n      throw new NullPointerException();\n    pricing = myPricing;\n  }\n\n  public long getTotal() {\n    return pricing.getTotal(this);\n  }\n\n  public static ISalePricing createPricing(DiscountType discountType, double percentage, long discount, long threshold) {\n    if (percentage < 0 || percentage > 100)\n      throw new IllegalArgumentException();\n    if (discountType == null)\n      throw new NullPointerException();\n    if (discountType.ordinal() == 0 && discount == 0 && threshold == 0) {\n      ISalePricing pricing = new PercentageDiscountPricing(percentage);\n      return pricing;\n    }\n    else if (percentage == 0) {\n      ISalePricing pricing = new AbsoluteDiscountPricing(discount, threshold);\n      return pricing;\n    }\n    else {\n      throw new IllegalArgumentException();\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Beer extends Drink {\n\n  private String brewery;\n\n  public Beer (String brewery) {\n    this.brewery = brewery;\n  }\n\n  public String getBrewery() {\n    return this.brewery;\n  }\n\n  @Override public String toString() {\n    return String.format(this.brewery);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "Name 'Type' must match pattern '^[A-Z]$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "14",
    "end_column": "14",
    "rule": {
      "identifier": "ClassTypeParameterName",
      "explanation": "Class type parameters of generic classes should conform to naming conventions. For example, naming a type parameter \"T\" is ok, whereas naming it \"abc\" such as in MyClass<abc> {} violates the conventions. Type parameters should match the regular expression \"^[a-zA-Z]$\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Bottle<Type> {\n\n  private Type content;\n\n  public boolean isEmpty() {\n    if (this.content == null)\n      return true;\n    return false;\n  }\n\n  public void fill (Type content) {\n    if (this.content == null)\n      this.content = content;\n    else\n      throw new IllegalStateException(\"Bottle is not empty!\");\n  }\n\n  public Type empty() {\n    if (this.content == null)\n      throw new IllegalStateException(\"Bottle is empty!\");\n    else {\n      Type content = this.content;\n      this.content = null;\n      return content;\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Bottle<Type> {\n\n  private Type content;\n\n  public boolean isEmpty() {\n    if (this.content == null)\n      return true;\n    return false;\n  }\n\n  public void fill (Type content) {\n    if (this.content == null)\n      this.content = content;\n    else\n      throw new IllegalStateException(\"Bottle is not empty!\");\n  }\n\n  public Type empty() {\n    if (this.content == null)\n      throw new IllegalStateException(\"Bottle is empty!\");\n    else {\n      Type content = this.content;\n      this.content = null;\n      return content;\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "'content' hides a field.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "26",
    "end_column": "26",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Bottle<Type> {\n\n  private Type content;\n\n  public boolean isEmpty() {\n    if (this.content == null)\n      return true;\n    return false;\n  }\n\n  public void fill (Type content) {\n    if (this.content == null)\n      this.content = content;\n    else\n      throw new IllegalStateException(\"Bottle is not empty!\");\n  }\n\n  public Type empty() {\n    if (this.content == null)\n      throw new IllegalStateException(\"Bottle is empty!\");\n    else {\n      Type content = this.content;\n      this.content = null;\n      return content;\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Bottle<Type> {\n\n  private Type content;\n\n  public boolean isEmpty() {\n    if (this.content == null)\n      return true;\n    return false;\n  }\n\n  public void fill (Type content) {\n    if (this.content == null)\n      this.content = content;\n    else\n      throw new IllegalStateException(\"Bottle is not empty!\");\n  }\n\n  public Type empty() {\n    if (this.content == null)\n      throw new IllegalStateException(\"Bottle is empty!\");\n    else {\n      Type content = this.content;\n      this.content = null;\n      return content;\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Bottle<Type> {\n\n  private Type content;\n\n  public boolean isEmpty() {\n    if (this.content == null)\n      return true;\n    return false;\n  }\n\n  public void fill (Type content) {\n    if (this.content == null)\n      this.content = content;\n    else\n      throw new IllegalStateException(\"Bottle is not empty!\");\n  }\n\n  public Type empty() {\n    if (this.content == null)\n      throw new IllegalStateException(\"Bottle is empty!\");\n    else {\n      Type content = this.content;\n      this.content = null;\n      return content;\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Bottle<Type> {\n\n  private Type content;\n\n  public boolean isEmpty() {\n    if (this.content == null)\n      return true;\n    return false;\n  }\n\n  public void fill (Type content) {\n    if (this.content == null)\n      this.content = content;\n    else\n      throw new IllegalStateException(\"Bottle is not empty!\");\n  }\n\n  public Type empty() {\n    if (this.content == null)\n      throw new IllegalStateException(\"Bottle is empty!\");\n    else {\n      Type content = this.content;\n      this.content = null;\n      return content;\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "'content' hides a field.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": "12",
    "end_column": "12",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class Bottle<Type> {\n\n  private Type content;\n\n  public boolean isEmpty() {\n    if (this.content == null)\n      return true;\n    return false;\n  }\n\n  public void fill (Type content) {\n    if (this.content == null)\n      this.content = content;\n    else\n      throw new IllegalStateException(\"Bottle is not empty!\");\n  }\n\n  public Type empty() {\n    if (this.content == null)\n      throw new IllegalStateException(\"Bottle is empty!\");\n    else {\n      Type content = this.content;\n      this.content = null;\n      return content;\n    }\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "Name 'Drink' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "abstract class Drink {\n// Nothing to show here\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class RedWine extends Wine {\n\n  public RedWine(String region) {\n    super(region);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "class WhiteWine extends Wine {\n\n  public WhiteWine(String region) {\n    super(region);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "Name 'Wine' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "1",
    "end_line": "1",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "abstract class Wine extends Drink {\n\n  private String region;\n\n  public Wine(String region) {\n    this.region = region;\n  }\n\n  public String getRegion() {\n    return this.region;\n  }\n\n  @Override public String toString() {\n    return String.format(this.region);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Bottle",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "abstract class Wine extends Drink {\n\n  private String region;\n\n  public Wine(String region) {\n    this.region = region;\n  }\n\n  public String getRegion() {\n    return this.region;\n  }\n\n  @Override public String toString() {\n    return String.format(this.region);\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Linked List",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n  private ListElement first;\n\n  public List () {\n    first = null;\n  }\n\n  public boolean isEmpty() {\n    if (this.first == null)\n      return true;\n    else\n      return false;\n  }\n\n  public void append(String string) {\n    ListElement ele = new ListElement(string);\n    ListElement pointer = this.first;\n    if (this.isEmpty()) {\n      this.first = ele;\n    }\n    else {\n      while (pointer.getNext() != null) {\n        pointer = pointer.getNext();\n      }\n      pointer.setNext(ele);\n    }\n  }\n\n  public String remove(String string) {\n    ListElement pointer = this.first;\n    if (string == null)\n      return null;\n    if (this.isEmpty())\n      return null;\n    else {\n      if (this.first.getContent() == string) {\n        this.first = this.first.getNext();\n        return string;\n      }\n      else {\n        while (pointer.getNext() != null) {\n          if (pointer.getNext().getContent() == string) {\n            ListElement delete = pointer.getNext();\n            pointer.setNext(pointer.getNext().getNext());\n            return delete.getContent();\n          }\n          pointer = pointer.getNext();\n        }\n      }\n    }\n    return null;\n  }\n\n  public void printList() {\n    if (! this.isEmpty()) {\n      System.out.println(\"List:\");\n      ListElement pointer = this.first;\n      while (pointer != null) {\n        System.out.println(pointer.getContent());\n        pointer = pointer.getNext();\n      }\n    }\n    else\n      System.out.println(\"List is empty.\");\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Linked List",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n  private ListElement first;\n\n  public List () {\n    first = null;\n  }\n\n  public boolean isEmpty() {\n    if (this.first == null)\n      return true;\n    else\n      return false;\n  }\n\n  public void append(String string) {\n    ListElement ele = new ListElement(string);\n    ListElement pointer = this.first;\n    if (this.isEmpty()) {\n      this.first = ele;\n    }\n    else {\n      while (pointer.getNext() != null) {\n        pointer = pointer.getNext();\n      }\n      pointer.setNext(ele);\n    }\n  }\n\n  public String remove(String string) {\n    ListElement pointer = this.first;\n    if (string == null)\n      return null;\n    if (this.isEmpty())\n      return null;\n    else {\n      if (this.first.getContent() == string) {\n        this.first = this.first.getNext();\n        return string;\n      }\n      else {\n        while (pointer.getNext() != null) {\n          if (pointer.getNext().getContent() == string) {\n            ListElement delete = pointer.getNext();\n            pointer.setNext(pointer.getNext().getNext());\n            return delete.getContent();\n          }\n          pointer = pointer.getNext();\n        }\n      }\n    }\n    return null;\n  }\n\n  public void printList() {\n    if (! this.isEmpty()) {\n      System.out.println(\"List:\");\n      ListElement pointer = this.first;\n      while (pointer != null) {\n        System.out.println(pointer.getContent());\n        pointer = pointer.getNext();\n      }\n    }\n    else\n      System.out.println(\"List is empty.\");\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Linked List",
    "message": "Conditional logic can be removed.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "SimplifyBooleanReturn",
      "explanation": "Over complicated boolean return statements are hard to understand and should be simplified.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n  private ListElement first;\n\n  public List () {\n    first = null;\n  }\n\n  public boolean isEmpty() {\n    if (this.first == null)\n      return true;\n    else\n      return false;\n  }\n\n  public void append(String string) {\n    ListElement ele = new ListElement(string);\n    ListElement pointer = this.first;\n    if (this.isEmpty()) {\n      this.first = ele;\n    }\n    else {\n      while (pointer.getNext() != null) {\n        pointer = pointer.getNext();\n      }\n      pointer.setNext(ele);\n    }\n  }\n\n  public String remove(String string) {\n    ListElement pointer = this.first;\n    if (string == null)\n      return null;\n    if (this.isEmpty())\n      return null;\n    else {\n      if (this.first.getContent() == string) {\n        this.first = this.first.getNext();\n        return string;\n      }\n      else {\n        while (pointer.getNext() != null) {\n          if (pointer.getNext().getContent() == string) {\n            ListElement delete = pointer.getNext();\n            pointer.setNext(pointer.getNext().getNext());\n            return delete.getContent();\n          }\n          pointer = pointer.getNext();\n        }\n      }\n    }\n    return null;\n  }\n\n  public void printList() {\n    if (! this.isEmpty()) {\n      System.out.println(\"List:\");\n      ListElement pointer = this.first;\n      while (pointer != null) {\n        System.out.println(pointer.getContent());\n        pointer = pointer.getNext();\n      }\n    }\n    else\n      System.out.println(\"List is empty.\");\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Linked List",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "14",
    "end_line": "14",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n  private ListElement first;\n\n  public List () {\n    first = null;\n  }\n\n  public boolean isEmpty() {\n    if (this.first == null)\n      return true;\n    else\n      return false;\n  }\n\n  public void append(String string) {\n    ListElement ele = new ListElement(string);\n    ListElement pointer = this.first;\n    if (this.isEmpty()) {\n      this.first = ele;\n    }\n    else {\n      while (pointer.getNext() != null) {\n        pointer = pointer.getNext();\n      }\n      pointer.setNext(ele);\n    }\n  }\n\n  public String remove(String string) {\n    ListElement pointer = this.first;\n    if (string == null)\n      return null;\n    if (this.isEmpty())\n      return null;\n    else {\n      if (this.first.getContent() == string) {\n        this.first = this.first.getNext();\n        return string;\n      }\n      else {\n        while (pointer.getNext() != null) {\n          if (pointer.getNext().getContent() == string) {\n            ListElement delete = pointer.getNext();\n            pointer.setNext(pointer.getNext().getNext());\n            return delete.getContent();\n          }\n          pointer = pointer.getNext();\n        }\n      }\n    }\n    return null;\n  }\n\n  public void printList() {\n    if (! this.isEmpty()) {\n      System.out.println(\"List:\");\n      ListElement pointer = this.first;\n      while (pointer != null) {\n        System.out.println(pointer.getContent());\n        pointer = pointer.getNext();\n      }\n    }\n    else\n      System.out.println(\"List is empty.\");\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Linked List",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "34",
    "end_line": "34",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n  private ListElement first;\n\n  public List () {\n    first = null;\n  }\n\n  public boolean isEmpty() {\n    if (this.first == null)\n      return true;\n    else\n      return false;\n  }\n\n  public void append(String string) {\n    ListElement ele = new ListElement(string);\n    ListElement pointer = this.first;\n    if (this.isEmpty()) {\n      this.first = ele;\n    }\n    else {\n      while (pointer.getNext() != null) {\n        pointer = pointer.getNext();\n      }\n      pointer.setNext(ele);\n    }\n  }\n\n  public String remove(String string) {\n    ListElement pointer = this.first;\n    if (string == null)\n      return null;\n    if (this.isEmpty())\n      return null;\n    else {\n      if (this.first.getContent() == string) {\n        this.first = this.first.getNext();\n        return string;\n      }\n      else {\n        while (pointer.getNext() != null) {\n          if (pointer.getNext().getContent() == string) {\n            ListElement delete = pointer.getNext();\n            pointer.setNext(pointer.getNext().getNext());\n            return delete.getContent();\n          }\n          pointer = pointer.getNext();\n        }\n      }\n    }\n    return null;\n  }\n\n  public void printList() {\n    if (! this.isEmpty()) {\n      System.out.println(\"List:\");\n      ListElement pointer = this.first;\n      while (pointer != null) {\n        System.out.println(pointer.getContent());\n        pointer = pointer.getNext();\n      }\n    }\n    else\n      System.out.println(\"List is empty.\");\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Linked List",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n  private ListElement first;\n\n  public List () {\n    first = null;\n  }\n\n  public boolean isEmpty() {\n    if (this.first == null)\n      return true;\n    else\n      return false;\n  }\n\n  public void append(String string) {\n    ListElement ele = new ListElement(string);\n    ListElement pointer = this.first;\n    if (this.isEmpty()) {\n      this.first = ele;\n    }\n    else {\n      while (pointer.getNext() != null) {\n        pointer = pointer.getNext();\n      }\n      pointer.setNext(ele);\n    }\n  }\n\n  public String remove(String string) {\n    ListElement pointer = this.first;\n    if (string == null)\n      return null;\n    if (this.isEmpty())\n      return null;\n    else {\n      if (this.first.getContent() == string) {\n        this.first = this.first.getNext();\n        return string;\n      }\n      else {\n        while (pointer.getNext() != null) {\n          if (pointer.getNext().getContent() == string) {\n            ListElement delete = pointer.getNext();\n            pointer.setNext(pointer.getNext().getNext());\n            return delete.getContent();\n          }\n          pointer = pointer.getNext();\n        }\n      }\n    }\n    return null;\n  }\n\n  public void printList() {\n    if (! this.isEmpty()) {\n      System.out.println(\"List:\");\n      ListElement pointer = this.first;\n      while (pointer != null) {\n        System.out.println(pointer.getContent());\n        pointer = pointer.getNext();\n      }\n    }\n    else\n      System.out.println(\"List is empty.\");\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Linked List",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "66",
    "end_line": "66",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\nclass List {\n\n  private ListElement first;\n\n  public List () {\n    first = null;\n  }\n\n  public boolean isEmpty() {\n    if (this.first == null)\n      return true;\n    else\n      return false;\n  }\n\n  public void append(String string) {\n    ListElement ele = new ListElement(string);\n    ListElement pointer = this.first;\n    if (this.isEmpty()) {\n      this.first = ele;\n    }\n    else {\n      while (pointer.getNext() != null) {\n        pointer = pointer.getNext();\n      }\n      pointer.setNext(ele);\n    }\n  }\n\n  public String remove(String string) {\n    ListElement pointer = this.first;\n    if (string == null)\n      return null;\n    if (this.isEmpty())\n      return null;\n    else {\n      if (this.first.getContent() == string) {\n        this.first = this.first.getNext();\n        return string;\n      }\n      else {\n        while (pointer.getNext() != null) {\n          if (pointer.getNext().getContent() == string) {\n            ListElement delete = pointer.getNext();\n            pointer.setNext(pointer.getNext().getNext());\n            return delete.getContent();\n          }\n          pointer = pointer.getNext();\n        }\n      }\n    }\n    return null;\n  }\n\n  public void printList() {\n    if (! this.isEmpty()) {\n      System.out.println(\"List:\");\n      ListElement pointer = this.first;\n      while (pointer != null) {\n        System.out.println(pointer.getContent());\n        pointer = pointer.getNext();\n      }\n    }\n    else\n      System.out.println(\"List is empty.\");\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Linked List",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "3",
    "end_column": "3",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\n\nclass ListElement {\n\n  private String content;\n  private ListElement next;\n\n  public ListElement (String content) {\n    this.setContent(content);\n  }\n\n  public String getContent() {\n    return this.content;\n  }\n\n  public void setContent(String content) {\n    Objects.requireNonNull(content);\n    if (content.isEmpty()) {\n      throw new IllegalArgumentException(\"The argument 'content' cannot be empty!\");\n    }\n    else\n      this.content = content;\n  }\n\n  public ListElement getNext() {\n    return this.next;\n  }\n\n  public void setNext(ListElement ele) {\n    this.next = ele;\n  }\n\n}\n"
  },
  {
    "user": "3",
    "task": "Linked List",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "import java.util.Objects;\n\n\nclass ListElement {\n\n  private String content;\n  private ListElement next;\n\n  public ListElement (String content) {\n    this.setContent(content);\n  }\n\n  public String getContent() {\n    return this.content;\n  }\n\n  public void setContent(String content) {\n    Objects.requireNonNull(content);\n    if (content.isEmpty()) {\n      throw new IllegalArgumentException(\"The argument 'content' cannot be empty!\");\n    }\n    else\n      this.content = content;\n  }\n\n  public ListElement getNext() {\n    return this.next;\n  }\n\n  public void setNext(ListElement ele) {\n    this.next = ele;\n  }\n\n}\n"
  },
  {
    "user": "2",
    "task": "Generics",
    "message": "'content' hides a field.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "24",
    "end_column": "24",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.generics;\n\npublic class Bottle<T extends Drink> {\n    private T content;\n\n    public boolean isEmpty() {\n        return content == null;\n    }\n\n    public void fill(T content) {\n        if (this.content != null) {\n            throw new IllegalStateException(\"You cant fill a full bottle!\");\n        } else {\n            this.content = content;\n        }\n    }\n\n    public T empty() {\n        if (content == null) {\n            throw new IllegalStateException(\"You cant empty a empty bottle!\");\n        } else {\n            T content = this.content;\n            this.content = null;\n            return content;\n        }\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Generics",
    "message": "'content' hides a field.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": "15",
    "end_column": "15",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.generics;\n\npublic class Bottle<T extends Drink> {\n    private T content;\n\n    public boolean isEmpty() {\n        return content == null;\n    }\n\n    public void fill(T content) {\n        if (this.content != null) {\n            throw new IllegalStateException(\"You cant fill a full bottle!\");\n        } else {\n            this.content = content;\n        }\n    }\n\n    public T empty() {\n        if (content == null) {\n            throw new IllegalStateException(\"You cant empty a empty bottle!\");\n        } else {\n            T content = this.content;\n            this.content = null;\n            return content;\n        }\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Generics",
    "message": "Name 'Drink' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.generics;\n\npublic abstract class Drink {\n}\n"
  },
  {
    "user": "2",
    "task": "Generics",
    "message": "Name 'Wine' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.generics;\n\npublic abstract class Wine extends Drink{\n    private String region;\n\n    public Wine(String region) {\n        this.region = region;\n    }\n\n    public String getRegion() {\n        return region;\n    }\n\n    @Override\n    public String toString() {\n        return \"Wine{\" +\n                \"region='\" + region + '\\'' +\n                '}';\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic class Factory {\n    private ReceivingStock stock;\n    private Purchasing purchasing;\n\n    public Factory(Purchasing purchasing, ReceivingStock stock) {\n        if (purchasing==null||stock==null) throw new NullPointerException(\"Arguments shall not be null!\");\n        this.stock = stock;\n        this.purchasing = purchasing;\n    }\n\n    public ReceivingStock getStock() {\n        return stock;\n    }\n\n    public Purchasing getPurchasing() {\n        return purchasing;\n    }\n\n    public static Part create(PartType type, String id, String name) {\n        if (type == null || id == null || name == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (id.isEmpty()||name.isEmpty()) throw new IllegalArgumentException(\"Name or ID shall not be empty!\");\n        switch (type) {\n            case RESOURCE:\n                return new Resource(id, name);\n            case COMPONENTS:\n                return new Components(id, name);\n            case SINGLE_COMPONENT:\n                return new SingleComponent(id, name);\n            //this is horrible\n            default:\n                return null;\n        }\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic class Factory {\n    private ReceivingStock stock;\n    private Purchasing purchasing;\n\n    public Factory(Purchasing purchasing, ReceivingStock stock) {\n        if (purchasing==null||stock==null) throw new NullPointerException(\"Arguments shall not be null!\");\n        this.stock = stock;\n        this.purchasing = purchasing;\n    }\n\n    public ReceivingStock getStock() {\n        return stock;\n    }\n\n    public Purchasing getPurchasing() {\n        return purchasing;\n    }\n\n    public static Part create(PartType type, String id, String name) {\n        if (type == null || id == null || name == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (id.isEmpty()||name.isEmpty()) throw new IllegalArgumentException(\"Name or ID shall not be empty!\");\n        switch (type) {\n            case RESOURCE:\n                return new Resource(id, name);\n            case COMPONENTS:\n                return new Components(id, name);\n            case SINGLE_COMPONENT:\n                return new SingleComponent(id, name);\n            //this is horrible\n            default:\n                return null;\n        }\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic class Factory {\n    private ReceivingStock stock;\n    private Purchasing purchasing;\n\n    public Factory(Purchasing purchasing, ReceivingStock stock) {\n        if (purchasing==null||stock==null) throw new NullPointerException(\"Arguments shall not be null!\");\n        this.stock = stock;\n        this.purchasing = purchasing;\n    }\n\n    public ReceivingStock getStock() {\n        return stock;\n    }\n\n    public Purchasing getPurchasing() {\n        return purchasing;\n    }\n\n    public static Part create(PartType type, String id, String name) {\n        if (type == null || id == null || name == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (id.isEmpty()||name.isEmpty()) throw new IllegalArgumentException(\"Name or ID shall not be empty!\");\n        switch (type) {\n            case RESOURCE:\n                return new Resource(id, name);\n            case COMPONENTS:\n                return new Components(id, name);\n            case SINGLE_COMPONENT:\n                return new SingleComponent(id, name);\n            //this is horrible\n            default:\n                return null;\n        }\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic interface Observation {\n    public void alarm(Part part);\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "Name 'Part' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic abstract class Part {\n    private String id;\n    private String name;\n\n    public Part(String id, String name) {\n        if (id==null||name==null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (id.isEmpty()||name.isEmpty()) throw new IllegalArgumentException(\"Arguments shall not be empty!\");\n        this.id = id;\n        this.name = name;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic abstract class Part {\n    private String id;\n    private String name;\n\n    public Part(String id, String name) {\n        if (id==null||name==null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (id.isEmpty()||name.isEmpty()) throw new IllegalArgumentException(\"Arguments shall not be empty!\");\n        this.id = id;\n        this.name = name;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic abstract class Part {\n    private String id;\n    private String name;\n\n    public Part(String id, String name) {\n        if (id==null||name==null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (id.isEmpty()||name.isEmpty()) throw new IllegalArgumentException(\"Arguments shall not be empty!\");\n        this.id = id;\n        this.name = name;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic class Purchasing implements Observation {\n    private ReceivingStock stock;\n\n    public Purchasing(ReceivingStock stock) {\n        if (stock==null) throw new NullPointerException(\"Stock shall not be null!\");\n        this.stock = stock;\n    }\n\n    public ReceivingStock getStock() {\n        return stock;\n    }\n\n    public void buy(Part part, int count) {\n        stock.insert(part, count);\n    }\n\n    @Override\n    public void alarm(Part part) {\n        buy(part, stock.getMaxStockItems() - stock.get(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic class ReceivingStock extends Stock {\n    private int minStockItems;\n    private int maxStockItems;\n\n    public ReceivingStock(int minStockItems, int maxStockItems) {\n        super();\n        if (minStockItems < 1) throw new IllegalArgumentException(\"minStockItems has to be at least 1!\");\n        if (maxStockItems < minStockItems) throw new IllegalArgumentException(\"maxStockItems has to be larger than minStockItems!\");\n        this.minStockItems = minStockItems;\n        this.maxStockItems = maxStockItems;\n    }\n\n    public int getMinStockItems() {\n        return minStockItems;\n    }\n\n    public int getMaxStockItems() {\n        return maxStockItems;\n    }\n\n    @Override\n    public boolean set(Part part, int count) {\n        var toReturn = super.set(part, count);\n        if (super.get(part) < minStockItems) {\n            notify(part);\n        }\n        return toReturn;\n    }\n\n    @Override\n    public boolean delete(Part part, int count) {\n        var toReturn = super.delete(part, count);\n        if (super.get(part) < minStockItems) {\n            notify(part);\n        }\n        return toReturn;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\npublic class ReceivingStock extends Stock {\n    private int minStockItems;\n    private int maxStockItems;\n\n    public ReceivingStock(int minStockItems, int maxStockItems) {\n        super();\n        if (minStockItems < 1) throw new IllegalArgumentException(\"minStockItems has to be at least 1!\");\n        if (maxStockItems < minStockItems) throw new IllegalArgumentException(\"maxStockItems has to be larger than minStockItems!\");\n        this.minStockItems = minStockItems;\n        this.maxStockItems = maxStockItems;\n    }\n\n    public int getMinStockItems() {\n        return minStockItems;\n    }\n\n    public int getMaxStockItems() {\n        return maxStockItems;\n    }\n\n    @Override\n    public boolean set(Part part, int count) {\n        var toReturn = super.set(part, count);\n        if (super.get(part) < minStockItems) {\n            notify(part);\n        }\n        return toReturn;\n    }\n\n    @Override\n    public boolean delete(Part part, int count) {\n        var toReturn = super.delete(part, count);\n        if (super.get(part) < minStockItems) {\n            notify(part);\n        }\n        return toReturn;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "Name 'Stock' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "18",
    "end_line": "18",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "24",
    "end_line": "24",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "32",
    "end_line": "32",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "33",
    "end_line": "33",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "40",
    "end_line": "40",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Part Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "50",
    "end_line": "50",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.parts;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic abstract class Stock {\n    private List<Observation> observers;\n    private Map<Part, Integer> parts;\n\n    public Stock() {\n        this.observers = new ArrayList<>();\n        this.parts = new HashMap<>();\n    }\n\n    public int get(Part part) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        return parts.getOrDefault(part, -1);\n    }\n\n    public boolean set(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count < 0) return false;\n        if (parts.containsKey(part)) {\n            parts.replace(part, count);\n            return true;\n        } else return false;\n    }\n\n    public void insert(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (count <= 0) throw new IllegalArgumentException(\"It only makes sense to insert one or more!\");\n        if (parts.containsKey(part)) {\n            parts.replace(part, parts.get(part) + count);\n        } else parts.put(part, count);\n    }\n\n    public boolean delete(Part part, int count) {\n        if (part == null) throw new NullPointerException(\"Part shall not be null!\");\n        if (!parts.containsKey(part) || count <= 0 || parts.get(part) < count) {\n            return false;\n        } else {\n            parts.replace(part, parts.get(part) - count);\n            return true;\n        }\n    }\n\n    public void register(Observation observer) {\n        if (observer == null) throw new NullPointerException(\"Observer shall not be null!\");\n        observers.add(observer);\n    }\n\n    public void notify(Part part) {\n        observers.parallelStream().forEach(observer -> observer.alarm(part));\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Kingdom",
    "message": "Variable 'income' must be private and have accessor methods.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "19",
    "end_column": "19",
    "rule": {
      "identifier": "VisibilityModifier",
      "explanation": "Class members should be private, unless they are static final, immutable or specifically annotated, to enforce encapsulation.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.kingdom;\n\npublic class Inhabitant {\n    protected int income;\n\n    public int taxableIncome() {\n        return income;\n    }\n\n    public int tax() {\n        var toPay = income * 0.1;\n        if (toPay < 1) {\n            return 1;\n        } else {\n            return (int) toPay;\n        }\n    }\n\n    public void setIncome(int income) {\n        this.income = income;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Kingdom",
    "message": "'0.1' is a magic number.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": "30",
    "end_column": "30",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.kingdom;\n\npublic class Inhabitant {\n    protected int income;\n\n    public int taxableIncome() {\n        return income;\n    }\n\n    public int tax() {\n        var toPay = income * 0.1;\n        if (toPay < 1) {\n            return 1;\n        } else {\n            return (int) toPay;\n        }\n    }\n\n    public void setIncome(int income) {\n        this.income = income;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Kingdom",
    "message": "'20' is a magic number.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": "21",
    "end_column": "21",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.kingdom;\n\npublic class Noble extends Inhabitant {\n    @Override\n    public int tax() {\n        var toPay = super.tax();\n        if (toPay < 20) {\n            return 20;\n        } else {\n            return toPay;\n        }\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Kingdom",
    "message": "'20' is a magic number.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "20",
    "end_column": "20",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.kingdom;\n\npublic class Noble extends Inhabitant {\n    @Override\n    public int tax() {\n        var toPay = super.tax();\n        if (toPay < 20) {\n            return 20;\n        } else {\n            return toPay;\n        }\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Kingdom",
    "message": "'12' is a magic number.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "45",
    "end_column": "45",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.kingdom;\n\npublic class Serf extends Peasant {\n    @Override\n    public int taxableIncome() {\n        var toTax = super.taxableIncome() - 12;\n        if (toTax < 0) {\n            return 0;\n        } else {\n            return toTax;\n        }\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class DesktopSearch {\n    private Map<String, ResourceType> types;\n    private Index index;\n\n    public DesktopSearch() {\n        index = new Index();\n        types = new HashMap<>();\n    }\n\n    public void registerType(String extension, ResourceType type){\n        if (type==null||extension==null) throw new NullPointerException(\"Arguments shall not be null!\");\n        types.put(extension, type);\n    }\n\n    public ResourceType getType(String extension){\n        return types.get(extension);\n    }\n\n    public void unregisterType(String extension){\n        if (extension==null) throw new NullPointerException(\"Extension shall not be null!\");\n        types.remove(extension);\n    }\n\n    public void registerResource(Resource res){\n        index.add(res);\n    }\n\n    public List<Resource> processRequest(String request){\n        return index.getResources(request);\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class DesktopSearch {\n    private Map<String, ResourceType> types;\n    private Index index;\n\n    public DesktopSearch() {\n        index = new Index();\n        types = new HashMap<>();\n    }\n\n    public void registerType(String extension, ResourceType type){\n        if (type==null||extension==null) throw new NullPointerException(\"Arguments shall not be null!\");\n        types.put(extension, type);\n    }\n\n    public ResourceType getType(String extension){\n        return types.get(extension);\n    }\n\n    public void unregisterType(String extension){\n        if (extension==null) throw new NullPointerException(\"Extension shall not be null!\");\n        types.remove(extension);\n    }\n\n    public void registerResource(Resource res){\n        index.add(res);\n    }\n\n    public List<Resource> processRequest(String request){\n        return index.getResources(request);\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\nimport java.util.*;\n\npublic class Index {\n    private Map<String, List<Resource>> index;\n\n    public Index() {\n        index = new HashMap<>();\n    }\n\n    public void add(Resource res){\n        if (res==null) throw new NullPointerException(\"Resource shall not be null!\");\n        Set<String> keywords = res.getType().getCollector().getKeywords(res);\n        for (String keyword : keywords){\n            if (!index.containsKey(keyword)){\n                index.put(keyword, new ArrayList<>());\n            }\n            if (!index.get(keyword).contains(res)){\n                index.get(keyword).add(res);\n            }\n        }\n    }\n\n    public List<Resource> getResources(String keyword){\n        if (keyword==null) throw new NullPointerException();\n        return index.getOrDefault(keyword, new ArrayList<>());\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "26",
    "end_line": "26",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\nimport java.util.*;\n\npublic class Index {\n    private Map<String, List<Resource>> index;\n\n    public Index() {\n        index = new HashMap<>();\n    }\n\n    public void add(Resource res){\n        if (res==null) throw new NullPointerException(\"Resource shall not be null!\");\n        Set<String> keywords = res.getType().getCollector().getKeywords(res);\n        for (String keyword : keywords){\n            if (!index.containsKey(keyword)){\n                index.put(keyword, new ArrayList<>());\n            }\n            if (!index.get(keyword).contains(res)){\n                index.get(keyword).add(res);\n            }\n        }\n    }\n\n    public List<Resource> getResources(String keyword){\n        if (keyword==null) throw new NullPointerException();\n        return index.getOrDefault(keyword, new ArrayList<>());\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class PlainTextCollector implements KeywordCollector {\n    @Override\n    public Set<String> getKeywords(Resource res) {\n        if (res == null) throw new NullPointerException(\"Resource shall not be null!\");\n        TextFileIterator iterator = new TextFileIterator(res);\n        Set<String> keywords = new HashSet<>();\n        while (iterator.hasNext()){\n            keywords.add(iterator.next());\n        }\n        return keywords;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\npublic class Resource {\n    private String name;\n    private String path;\n    private ResourceType rt;\n\n    public Resource(String name, String path, ResourceType rt) {\n        if (name == null || path == null || rt == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty()||path.isEmpty()) throw new IllegalArgumentException(\"Name or path shall not be empty!\");\n        this.name = name;\n        this.path = path;\n        this.rt = rt;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public ResourceType getType() {\n        return rt;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\npublic class Resource {\n    private String name;\n    private String path;\n    private ResourceType rt;\n\n    public Resource(String name, String path, ResourceType rt) {\n        if (name == null || path == null || rt == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty()||path.isEmpty()) throw new IllegalArgumentException(\"Name or path shall not be empty!\");\n        this.name = name;\n        this.path = path;\n        this.rt = rt;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public ResourceType getType() {\n        return rt;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\npublic class ResourceType {\n    private String description;\n    private KeywordCollector collector;\n\n    public ResourceType(String desc, KeywordCollector collector) {\n        if (desc == null || collector == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (desc.isEmpty()) throw new IllegalArgumentException(\"Description shall not be empty!\");\n        this.description = desc;\n        this.collector = collector;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public KeywordCollector getCollector() {\n        return collector;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\npublic class ResourceType {\n    private String description;\n    private KeywordCollector collector;\n\n    public ResourceType(String desc, KeywordCollector collector) {\n        if (desc == null || collector == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (desc.isEmpty()) throw new IllegalArgumentException(\"Description shall not be empty!\");\n        this.description = desc;\n        this.collector = collector;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public KeywordCollector getCollector() {\n        return collector;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "Variable 'count' explicitly initialized to '0' (default value for its type).",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": "17",
    "end_column": "17",
    "rule": {
      "identifier": "ExplicitInitialization",
      "explanation": "Java initializes variables to default values (such as false for boolean or null for object types) before performing any initialization specified in the code. Therefore, if you explicitly initialize variables to their internal default value, Java will run this computation twice, resulting in a minor inefficiency.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class TextFileIterator implements Iterator<String> {\n\n    private Resource resource;\n    private String text = \"We wish you good luck in this exam!\\nWe hope you are well pre-\\npared.\";\n    private List<String> parts;\n    private Iterator<String> iterator;\n    private int count = 0;\n\n    public TextFileIterator(Resource res) {\n        if (res == null) throw new NullPointerException(\"Resource shall not be null!\");\n        this.resource = res;\n        parts = Arrays.asList(text.replace(\"-\\n\", \"\").replace(\"\\n\", \" \")\n                .replaceAll(\"[^A-Za-z0-9 ]\", \"\").split(\" \"));\n        iterator = parts.iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    @Override\n    public String next() {\n        return iterator.next();\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"Removing is not supprted!\");\n    }\n\n    public String getAsString() {\n        return text;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Desktop Search",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.search;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class TextFileIterator implements Iterator<String> {\n\n    private Resource resource;\n    private String text = \"We wish you good luck in this exam!\\nWe hope you are well pre-\\npared.\";\n    private List<String> parts;\n    private Iterator<String> iterator;\n    private int count = 0;\n\n    public TextFileIterator(Resource res) {\n        if (res == null) throw new NullPointerException(\"Resource shall not be null!\");\n        this.resource = res;\n        parts = Arrays.asList(text.replace(\"-\\n\", \"\").replace(\"\\n\", \" \")\n                .replaceAll(\"[^A-Za-z0-9 ]\", \"\").split(\" \"));\n        iterator = parts.iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    @Override\n    public String next() {\n        return iterator.next();\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"Removing is not supprted!\");\n    }\n\n    public String getAsString() {\n        return text;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'->' construct must use '{}'s.",
    "priority": "error",
    "start_line": "31",
    "end_line": "31",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Adapter implements IProject{\n    private Project project;\n\n    public Adapter(String name, String description, double rate) {\n        this.project = new Project(name, description, rate);\n    }\n\n    @Override\n    public void setTask(Task newTask) {\n        project.setTask(newTask);\n    }\n\n    @Override\n    public double getDuration() {\n        return project.getDuration();\n    }\n\n    @Override\n    public long getTotalCost() {\n        return project.getTotalCost();\n    }\n\n    @Override\n    public List<Deliverable> getDeliverables() {\n        List<Deliverable> deliverables = new ArrayList<>();\n        project.allDeliverables().forEach(((calendar, deliverables1) -> deliverables1.parallelStream()\n        .forEach(deliverables::add)));\n        return deliverables;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.Calendar;\n\npublic class Deliverable extends ProjectItem{\n    private long materialCost;\n    private double productionTime;\n    private Calendar date;\n\n    public Deliverable(String name, String details, double rate, long materialCost, double productionTime, Calendar date) {\n        super(name, details, rate);\n        if (date==null) throw new NullPointerException(\"Date shall not be null!\");\n        if (materialCost<0||productionTime<=0) throw new IllegalArgumentException(\"Materialcost and prduction time have to be positive!\");\n        this.materialCost = materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    public Calendar getDate() {\n        return date;\n    }\n\n    @Override\n    public double getTimeRequired() {\n        return productionTime;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        return materialCost;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "13",
    "end_line": "13",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.Calendar;\n\npublic class Deliverable extends ProjectItem{\n    private long materialCost;\n    private double productionTime;\n    private Calendar date;\n\n    public Deliverable(String name, String details, double rate, long materialCost, double productionTime, Calendar date) {\n        super(name, details, rate);\n        if (date==null) throw new NullPointerException(\"Date shall not be null!\");\n        if (materialCost<0||productionTime<=0) throw new IllegalArgumentException(\"Materialcost and prduction time have to be positive!\");\n        this.materialCost = materialCost;\n        this.productionTime = productionTime;\n        this.date = date;\n    }\n\n    public Calendar getDate() {\n        return date;\n    }\n\n    @Override\n    public double getTimeRequired() {\n        return productionTime;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        return materialCost;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "Abbreviation in name 'IProject' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.List;\n\npublic interface IProject {\n    void setTask(Task newTask);\n    double getDuration();\n    long getTotalCost();\n    List<Deliverable> getDeliverables();\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.*;\n\npublic class Project {\n    private String name;\n    private String description;\n    private Task mainTask;\n\n    public Project(String name, String description, double rate) {\n        if (name == null || description == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || description.isEmpty())\n            throw new IllegalArgumentException(\"Name or description shall not be empty!\");\n        this.name = name;\n        this.description = description;\n        this.mainTask = new Task(name, description, rate);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setTask(Task mainTask) {\n        if (mainTask == null) throw new NullPointerException(\"Task shall not be null!\");\n        this.mainTask = mainTask;\n    }\n\n    public double getDuration() {\n        return mainTask.getTimeRequired();\n    }\n\n    public long getTotalCost() {\n        return mainTask.getCostEstimate();\n    }\n\n    public Map<Calendar, List<Deliverable>> allDeliverables() {\n        Map<Calendar, List<Deliverable>> deliverables = new HashMap<>();\n        mainTask.allDeliverables().forEach(deliverable -> {\n            if (!deliverables.containsKey(deliverable.getDate())) {\n                deliverables.put(deliverable.getDate(), new ArrayList<>());\n            }\n            var newList = deliverables.get(deliverable.getDate());\n            newList.add(deliverable);\n            deliverables.replace(deliverable.getDate(), newList);\n        });\n        return deliverables;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.*;\n\npublic class Project {\n    private String name;\n    private String description;\n    private Task mainTask;\n\n    public Project(String name, String description, double rate) {\n        if (name == null || description == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || description.isEmpty())\n            throw new IllegalArgumentException(\"Name or description shall not be empty!\");\n        this.name = name;\n        this.description = description;\n        this.mainTask = new Task(name, description, rate);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setTask(Task mainTask) {\n        if (mainTask == null) throw new NullPointerException(\"Task shall not be null!\");\n        this.mainTask = mainTask;\n    }\n\n    public double getDuration() {\n        return mainTask.getTimeRequired();\n    }\n\n    public long getTotalCost() {\n        return mainTask.getCostEstimate();\n    }\n\n    public Map<Calendar, List<Deliverable>> allDeliverables() {\n        Map<Calendar, List<Deliverable>> deliverables = new HashMap<>();\n        mainTask.allDeliverables().forEach(deliverable -> {\n            if (!deliverables.containsKey(deliverable.getDate())) {\n                deliverables.put(deliverable.getDate(), new ArrayList<>());\n            }\n            var newList = deliverables.get(deliverable.getDate());\n            newList.add(deliverable);\n            deliverables.replace(deliverable.getDate(), newList);\n        });\n        return deliverables;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'mainTask' hides a field.",
    "priority": "error",
    "start_line": "27",
    "end_line": "27",
    "start_column": "30",
    "end_column": "30",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.*;\n\npublic class Project {\n    private String name;\n    private String description;\n    private Task mainTask;\n\n    public Project(String name, String description, double rate) {\n        if (name == null || description == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || description.isEmpty())\n            throw new IllegalArgumentException(\"Name or description shall not be empty!\");\n        this.name = name;\n        this.description = description;\n        this.mainTask = new Task(name, description, rate);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setTask(Task mainTask) {\n        if (mainTask == null) throw new NullPointerException(\"Task shall not be null!\");\n        this.mainTask = mainTask;\n    }\n\n    public double getDuration() {\n        return mainTask.getTimeRequired();\n    }\n\n    public long getTotalCost() {\n        return mainTask.getCostEstimate();\n    }\n\n    public Map<Calendar, List<Deliverable>> allDeliverables() {\n        Map<Calendar, List<Deliverable>> deliverables = new HashMap<>();\n        mainTask.allDeliverables().forEach(deliverable -> {\n            if (!deliverables.containsKey(deliverable.getDate())) {\n                deliverables.put(deliverable.getDate(), new ArrayList<>());\n            }\n            var newList = deliverables.get(deliverable.getDate());\n            newList.add(deliverable);\n            deliverables.replace(deliverable.getDate(), newList);\n        });\n        return deliverables;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "28",
    "end_line": "28",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.*;\n\npublic class Project {\n    private String name;\n    private String description;\n    private Task mainTask;\n\n    public Project(String name, String description, double rate) {\n        if (name == null || description == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || description.isEmpty())\n            throw new IllegalArgumentException(\"Name or description shall not be empty!\");\n        this.name = name;\n        this.description = description;\n        this.mainTask = new Task(name, description, rate);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setTask(Task mainTask) {\n        if (mainTask == null) throw new NullPointerException(\"Task shall not be null!\");\n        this.mainTask = mainTask;\n    }\n\n    public double getDuration() {\n        return mainTask.getTimeRequired();\n    }\n\n    public long getTotalCost() {\n        return mainTask.getCostEstimate();\n    }\n\n    public Map<Calendar, List<Deliverable>> allDeliverables() {\n        Map<Calendar, List<Deliverable>> deliverables = new HashMap<>();\n        mainTask.allDeliverables().forEach(deliverable -> {\n            if (!deliverables.containsKey(deliverable.getDate())) {\n                deliverables.put(deliverable.getDate(), new ArrayList<>());\n            }\n            var newList = deliverables.get(deliverable.getDate());\n            newList.add(deliverable);\n            deliverables.replace(deliverable.getDate(), newList);\n        });\n        return deliverables;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "Name 'ProjectItem' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\npublic abstract class ProjectItem {\n    private String name;\n    private String details;\n    private double rate;\n\n    public ProjectItem(String name, String details, double rate) {\n        if (name == null | details == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || details.isEmpty()) throw new IllegalArgumentException(\"Arguments shall not be empty!\");\n        if (rate < 0) throw new IllegalArgumentException(\"Rate has to be positive!\");\n        this.name = name;\n        this.details = details;\n        this.rate = rate;\n    }\n\n    public void setDetails(String details) {\n        if (details == null) throw new NullPointerException(\"Details shall not be null!\");\n        if (details.isEmpty()) throw new IllegalArgumentException(\"Details shall not be empty!\");\n        this.details = details;\n    }\n\n    public long getCostEstimate() {\n        return Math.round(getTimeRequired() * rate) + getMaterialCost();\n    }\n\n    public abstract double getTimeRequired();\n\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\npublic abstract class ProjectItem {\n    private String name;\n    private String details;\n    private double rate;\n\n    public ProjectItem(String name, String details, double rate) {\n        if (name == null | details == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || details.isEmpty()) throw new IllegalArgumentException(\"Arguments shall not be empty!\");\n        if (rate < 0) throw new IllegalArgumentException(\"Rate has to be positive!\");\n        this.name = name;\n        this.details = details;\n        this.rate = rate;\n    }\n\n    public void setDetails(String details) {\n        if (details == null) throw new NullPointerException(\"Details shall not be null!\");\n        if (details.isEmpty()) throw new IllegalArgumentException(\"Details shall not be empty!\");\n        this.details = details;\n    }\n\n    public long getCostEstimate() {\n        return Math.round(getTimeRequired() * rate) + getMaterialCost();\n    }\n\n    public abstract double getTimeRequired();\n\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\npublic abstract class ProjectItem {\n    private String name;\n    private String details;\n    private double rate;\n\n    public ProjectItem(String name, String details, double rate) {\n        if (name == null | details == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || details.isEmpty()) throw new IllegalArgumentException(\"Arguments shall not be empty!\");\n        if (rate < 0) throw new IllegalArgumentException(\"Rate has to be positive!\");\n        this.name = name;\n        this.details = details;\n        this.rate = rate;\n    }\n\n    public void setDetails(String details) {\n        if (details == null) throw new NullPointerException(\"Details shall not be null!\");\n        if (details.isEmpty()) throw new IllegalArgumentException(\"Details shall not be empty!\");\n        this.details = details;\n    }\n\n    public long getCostEstimate() {\n        return Math.round(getTimeRequired() * rate) + getMaterialCost();\n    }\n\n    public abstract double getTimeRequired();\n\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\npublic abstract class ProjectItem {\n    private String name;\n    private String details;\n    private double rate;\n\n    public ProjectItem(String name, String details, double rate) {\n        if (name == null | details == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || details.isEmpty()) throw new IllegalArgumentException(\"Arguments shall not be empty!\");\n        if (rate < 0) throw new IllegalArgumentException(\"Rate has to be positive!\");\n        this.name = name;\n        this.details = details;\n        this.rate = rate;\n    }\n\n    public void setDetails(String details) {\n        if (details == null) throw new NullPointerException(\"Details shall not be null!\");\n        if (details.isEmpty()) throw new IllegalArgumentException(\"Details shall not be empty!\");\n        this.details = details;\n    }\n\n    public long getCostEstimate() {\n        return Math.round(getTimeRequired() * rate) + getMaterialCost();\n    }\n\n    public abstract double getTimeRequired();\n\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "18",
    "end_line": "18",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\npublic abstract class ProjectItem {\n    private String name;\n    private String details;\n    private double rate;\n\n    public ProjectItem(String name, String details, double rate) {\n        if (name == null | details == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || details.isEmpty()) throw new IllegalArgumentException(\"Arguments shall not be empty!\");\n        if (rate < 0) throw new IllegalArgumentException(\"Rate has to be positive!\");\n        this.name = name;\n        this.details = details;\n        this.rate = rate;\n    }\n\n    public void setDetails(String details) {\n        if (details == null) throw new NullPointerException(\"Details shall not be null!\");\n        if (details.isEmpty()) throw new IllegalArgumentException(\"Details shall not be empty!\");\n        this.details = details;\n    }\n\n    public long getCostEstimate() {\n        return Math.round(getTimeRequired() * rate) + getMaterialCost();\n    }\n\n    public abstract double getTimeRequired();\n\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\npublic abstract class ProjectItem {\n    private String name;\n    private String details;\n    private double rate;\n\n    public ProjectItem(String name, String details, double rate) {\n        if (name == null | details == null) throw new NullPointerException(\"Arguments shall not be null!\");\n        if (name.isEmpty() || details.isEmpty()) throw new IllegalArgumentException(\"Arguments shall not be empty!\");\n        if (rate < 0) throw new IllegalArgumentException(\"Rate has to be positive!\");\n        this.name = name;\n        this.details = details;\n        this.rate = rate;\n    }\n\n    public void setDetails(String details) {\n        if (details == null) throw new NullPointerException(\"Details shall not be null!\");\n        if (details.isEmpty()) throw new IllegalArgumentException(\"Details shall not be empty!\");\n        this.details = details;\n    }\n\n    public long getCostEstimate() {\n        return Math.round(getTimeRequired() * rate) + getMaterialCost();\n    }\n\n    public abstract double getTimeRequired();\n\n    public abstract long getMaterialCost();\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "34",
    "end_line": "34",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Task extends ProjectItem {\n    private List<ProjectItem> projectItems;\n\n    public Task(String name, String details, double rate) {\n        super(name, details, rate);\n        projectItems = new ArrayList<>();\n    }\n\n    @Override\n    public double getTimeRequired() {\n        double time = 0;\n        for (ProjectItem item : projectItems) {\n            time += item.getTimeRequired();\n        }\n        return time;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        long cost = 0;\n        for (ProjectItem item : projectItems) {\n            cost += item.getMaterialCost();\n        }\n        return cost;\n    }\n\n    public void addProjectItem(ProjectItem item) {\n        if (item == null) throw new NullPointerException(\"ProjectItem shall not be null!\");\n        projectItems.add(item);\n    }\n\n    public void removeProjectItem(ProjectItem item) {\n        if (item == null) throw new NullPointerException(\"ProjectItem shall not be null!\");\n        projectItems.remove(item);\n    }\n\n    public List<Deliverable> allDeliverables() {\n        List<Deliverable> deliverables = new ArrayList<>();\n        projectItems.forEach(item -> {\n            if (item instanceof Deliverable) {\n                deliverables.add((Deliverable) item);\n            } else {\n                deliverables.addAll(((Task) item).allDeliverables());\n            }\n        });\n        return deliverables;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Project Management",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "39",
    "end_line": "39",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.projects;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Task extends ProjectItem {\n    private List<ProjectItem> projectItems;\n\n    public Task(String name, String details, double rate) {\n        super(name, details, rate);\n        projectItems = new ArrayList<>();\n    }\n\n    @Override\n    public double getTimeRequired() {\n        double time = 0;\n        for (ProjectItem item : projectItems) {\n            time += item.getTimeRequired();\n        }\n        return time;\n    }\n\n    @Override\n    public long getMaterialCost() {\n        long cost = 0;\n        for (ProjectItem item : projectItems) {\n            cost += item.getMaterialCost();\n        }\n        return cost;\n    }\n\n    public void addProjectItem(ProjectItem item) {\n        if (item == null) throw new NullPointerException(\"ProjectItem shall not be null!\");\n        projectItems.add(item);\n    }\n\n    public void removeProjectItem(ProjectItem item) {\n        if (item == null) throw new NullPointerException(\"ProjectItem shall not be null!\");\n        projectItems.remove(item);\n    }\n\n    public List<Deliverable> allDeliverables() {\n        List<Deliverable> deliverables = new ArrayList<>();\n        projectItems.forEach(item -> {\n            if (item instanceof Deliverable) {\n                deliverables.add((Deliverable) item);\n            } else {\n                deliverables.addAll(((Task) item).allDeliverables());\n            }\n        });\n        return deliverables;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Garage Door",
    "message": "Name 'DoorState' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "39",
    "end_line": "39",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.garage;\n\npublic class GarageDoor {\n    private DoorState currentState;\n    private Motor motor;\n\n    public GarageDoor() {\n        currentState = new Closed();\n        motor = new Motor();\n    }\n\n    public void openDoor() {\n        currentState.openDoor();\n        currentState = new Opening();\n    }\n\n    public void stopper() {\n        currentState.stopper();\n        if (currentState instanceof Opening) {\n            currentState = new Open();\n        } else if (currentState instanceof Closing) {\n            currentState = new Closed();\n        }\n    }\n\n    public void closeDoor() {\n        currentState.closeDoor();\n        currentState = new Closing();\n    }\n\n    public Motor getMotor() {\n        return motor;\n    }\n\n    private void setState(DoorState ds) {\n        currentState = ds;\n    }\n\n    abstract class DoorState {\n        public void openDoor() {\n        }\n\n        public void closeDoor() {\n        }\n\n        public void stopper() {\n        }\n    }\n\n    class Closed extends DoorState {\n        @Override\n        public void closeDoor() {\n            throw new IllegalStateException(\"A closed door can't be closed!\");\n        }\n\n        @Override\n        public void stopper() {\n            throw new IllegalStateException(\"Door is not moving!\");\n        }\n    }\n\n    class Opening extends DoorState {\n        @Override\n        public void openDoor() {\n            throw new IllegalStateException(\"Door is already opening!\");\n        }\n    }\n\n    class Open extends DoorState {\n        @Override\n        public void openDoor() {\n            throw new IllegalStateException(\"A open door can't be opened!\");\n        }\n\n        @Override\n        public void stopper() {\n            throw new IllegalStateException(\"Door is not moving!\");\n        }\n    }\n\n    class Closing extends DoorState {\n        @Override\n        public void closeDoor() {\n            throw new IllegalStateException(\"Door is already closing!\");\n        }\n    }\n\n}\n"
  },
  {
    "user": "2",
    "task": "Factorial",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.factorial;\n\npublic class Functions {\n\n    public static int factorial(int n) {\n        if (n <= 1) {\n            return 1;\n        } else {\n            return n * factorial(n - 1);\n        }\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Library",
    "message": "'10' is a magic number.",
    "priority": "error",
    "start_line": "17",
    "end_line": "17",
    "start_column": "28",
    "end_column": "28",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.library;\n/*\n * Lehrstuhl Softwaretechnologie, TU Dresden, Datei Library.java\n *\n * Library-Klasse implementiert eine Bibliothek,\n * die maximal 10 B\u00fccher aufnehmen kann\n */\n\n\npublic class Library {\n\n    private Book[] myBooks;\n\n    private int number;\n\n    public Library() {\n        myBooks = new Book[10];\n        number = 0;\n        System.out.println(\"Hello, I am a library, which can store up to 10 books!\");\n    }\n\n    public void add(Book book) {\n        if (number < 10) {\n            myBooks[number] = book;\n            number += 1;\n            System.out.println(String.format(\"I added the book %s!\", book));\n        } else {\n            System.out.println(\"The library is full!\");\n        }\n    }\n\n    public Book search(String title) {\n        for (Book book : myBooks) {\n            if (book != null) {\n                if (book.toString().equals(title)) {\n                    System.out.println(String.format(\"The book with the title %s exists in the library!\", title));\n                    return book;\n                }\n            }\n        }\n        System.out.println(String.format(\"The book with the title %s does not exist in the library!\", title));\n        return null;\n    }\n}"
  },
  {
    "user": "2",
    "task": "Library",
    "message": "'10' is a magic number.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": "22",
    "end_column": "22",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.library;\n/*\n * Lehrstuhl Softwaretechnologie, TU Dresden, Datei Library.java\n *\n * Library-Klasse implementiert eine Bibliothek,\n * die maximal 10 B\u00fccher aufnehmen kann\n */\n\n\npublic class Library {\n\n    private Book[] myBooks;\n\n    private int number;\n\n    public Library() {\n        myBooks = new Book[10];\n        number = 0;\n        System.out.println(\"Hello, I am a library, which can store up to 10 books!\");\n    }\n\n    public void add(Book book) {\n        if (number < 10) {\n            myBooks[number] = book;\n            number += 1;\n            System.out.println(String.format(\"I added the book %s!\", book));\n        } else {\n            System.out.println(\"The library is full!\");\n        }\n    }\n\n    public Book search(String title) {\n        for (Book book : myBooks) {\n            if (book != null) {\n                if (book.toString().equals(title)) {\n                    System.out.println(String.format(\"The book with the title %s exists in the library!\", title));\n                    return book;\n                }\n            }\n        }\n        System.out.println(String.format(\"The book with the title %s does not exist in the library!\", title));\n        return null;\n    }\n}"
  },
  {
    "user": "2",
    "task": "String Processing",
    "message": "Utility classes should not have a public or default constructor.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "HideUtilityClassConstructor",
      "explanation": "Utility classes (classes that contain only static methods or fields in their API) should not have a public constructor, because they are only accessed by their type and not by an object.",
      "medic": {
        "name": "John",
        "profession": "Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.leetspeek;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\n\npublic class Leet {\n    public static String toLeet(String normal) {\n        LinkedHashMap<String, String> leetMap = new LinkedHashMap<>() {{\n            put(\"elite\", \"1337\");\n            put(\"cool\", \"k3wl\");\n            put(\"!\", \"!!!11\");\n            put(\"ck\", \"xx\");\n            put(\"ers\", \"0rz\");\n            put(\"er\", \"0rz\");\n            put(\"en\", \"n\");\n            put(\"e\", \"3\");\n            put(\"t\", \"7\");\n            put(\"o\", \"0\");\n            put(\"a\", \"@\");\n        }};\n        for (String key : leetMap.keySet()) {\n            normal = normal.replace(key, leetMap.get(key));\n        }\n        return normal;\n    }\n\n    public static String[] allToLeet(String[] normals) {\n        ArrayList<String> leets = new ArrayList<>();\n        for (String normal : normals) {\n            leets.add(toLeet(normal));\n        }\n        return leets.toArray(new String[0]);\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "String Processing",
    "message": "'}' at column 9 should be alone on a line.",
    "priority": "error",
    "start_line": "20",
    "end_line": "20",
    "start_column": "9",
    "end_column": "9",
    "rule": {
      "identifier": "RightCurly",
      "explanation": "Right curlies should be placed in the same line of a potentially following control flow elements, such as if-else or try-catch. Do not place statements in the same line after right curlies.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.leetspeek;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\n\npublic class Leet {\n    public static String toLeet(String normal) {\n        LinkedHashMap<String, String> leetMap = new LinkedHashMap<>() {{\n            put(\"elite\", \"1337\");\n            put(\"cool\", \"k3wl\");\n            put(\"!\", \"!!!11\");\n            put(\"ck\", \"xx\");\n            put(\"ers\", \"0rz\");\n            put(\"er\", \"0rz\");\n            put(\"en\", \"n\");\n            put(\"e\", \"3\");\n            put(\"t\", \"7\");\n            put(\"o\", \"0\");\n            put(\"a\", \"@\");\n        }};\n        for (String key : leetMap.keySet()) {\n            normal = normal.replace(key, leetMap.get(key));\n        }\n        return normal;\n    }\n\n    public static String[] allToLeet(String[] normals) {\n        ArrayList<String> leets = new ArrayList<>();\n        for (String normal : normals) {\n            leets.add(toLeet(normal));\n        }\n        return leets.toArray(new String[0]);\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "String Processing",
    "message": "Assignment of parameter 'normal' is not allowed.",
    "priority": "error",
    "start_line": "22",
    "end_line": "22",
    "start_column": "20",
    "end_column": "20",
    "rule": {
      "identifier": "ParameterAssignment",
      "explanation": "Assignments to parameters of a function is often considered poor programming practice, because the parameters may be mutated without knowledge of the outside caller and reused in a potentially erroneous context. Parameters can be declared final.",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "package de.paktosan.university.swt.leetspeek;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\n\npublic class Leet {\n    public static String toLeet(String normal) {\n        LinkedHashMap<String, String> leetMap = new LinkedHashMap<>() {{\n            put(\"elite\", \"1337\");\n            put(\"cool\", \"k3wl\");\n            put(\"!\", \"!!!11\");\n            put(\"ck\", \"xx\");\n            put(\"ers\", \"0rz\");\n            put(\"er\", \"0rz\");\n            put(\"en\", \"n\");\n            put(\"e\", \"3\");\n            put(\"t\", \"7\");\n            put(\"o\", \"0\");\n            put(\"a\", \"@\");\n        }};\n        for (String key : leetMap.keySet()) {\n            normal = normal.replace(key, leetMap.get(key));\n        }\n        return normal;\n    }\n\n    public static String[] allToLeet(String[] normals) {\n        ArrayList<String> leets = new ArrayList<>();\n        for (String normal : normals) {\n            leets.add(toLeet(normal));\n        }\n        return leets.toArray(new String[0]);\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Library (Sets)",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.library.sets;\n\nimport java.util.*;\n\npublic class Library {\n    private Set<Book> stock;\n\n    public Library() {\n        this.stock = new HashSet<>();\n    }\n\n    public boolean insertBook(Book book){\n        if (!stock.contains(book)){\n            stock.add(book);\n            return true;\n        }else return false;\n    }\n\n    public Book searchForIsbn(String isbn){\n        Iterator<Book> iterator = stock.iterator();\n        while (iterator.hasNext()){\n            Book book = iterator.next();\n            if (book.getIsbn().equals(isbn)){\n                return book;\n            }\n        }\n        return null;\n    }\n\n    public Collection<Book> searchForAuthor(String author){\n        Collection<Book> books = new HashSet<>();\n        Iterator<Book> bookIterator = stock.iterator();\n        while (bookIterator.hasNext()){\n            Book book = bookIterator.next();\n            if (book.getAuthor().equals(author)){\n                books.add(book);\n            }\n        }\n        return books;\n    }\n\n    public Map<String, Set<Book>> listStockByAuthor(){\n        Map<String, Set<Book>> sortedBooks = new HashMap<>();\n        Iterator<Book> bookIterator = stock.iterator();\n        while (bookIterator.hasNext()){\n            Book book = bookIterator.next();\n            if (sortedBooks.containsKey(book.getAuthor())){\n                sortedBooks.get(book.getAuthor()).add(book);\n            }else {\n                Set<Book> newBooks = new HashSet<>();\n                newBooks.add(book);\n                sortedBooks.put(book.getAuthor(), newBooks);\n            }\n        }\n        return sortedBooks;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Auction System",
    "message": "Name 'Auction' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.auction;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic abstract class Auction {\n    private int nextItem;\n    private boolean closed;\n    private List<Person> bidders;\n    private List<Item> allItems;\n\n    public Auction() {\n        nextItem = 1;\n        closed = false;\n        bidders = new ArrayList<>();\n        allItems = new ArrayList<>();\n    }\n\n    public void addBid(String itemName, String nameOfBidder, long price) {\n        if (itemName.equals(\"\")) {\n            throw new IllegalArgumentException(\"Item name shall not be empty\");\n        }\n        if (price <= 0) {\n            throw new IllegalArgumentException(\"Price has to positive!\");\n        }\n        Person bidder = bidders.stream().filter(person -> person.getName().toLowerCase().equals(nameOfBidder.toLowerCase()))\n                .findAny().orElse(new Person(nameOfBidder));\n        if (!bidders.contains(bidder)) {\n            bidders.add(bidder);\n        }\n        Item item = allItems.stream().filter(item1 -> item1.getName().toLowerCase().equals(itemName.toLowerCase()))\n                .findAny().get();\n        item.addBid(bidder, price);\n    }\n\n    //required because the test wants to create a new item using an integer despite the UML says it shall be a Long\n    public void addBid(String itemName, String nameOfBidder, int price) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        addBid(itemName, nameOfBidder, Long.valueOf(price));\n    }\n\n    public void registerItem(Item item) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        if (item == null) throw new NullPointerException(\"Item should not be null!\");\n        if (allItems.stream().anyMatch(item1 -> item.getName().equals(item1.getName()))) {\n            throw new IllegalArgumentException(\"This item is already in the auction!\");\n        }\n        allItems.add(item);\n    }\n\n    public String closeAuction() {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        closed = true;\n        return generateItemListString();\n    }\n\n    public List<Item> getAllItems() {\n        return allItems;\n    }\n\n    public String generateItemListString() {\n        StringBuilder sb = new StringBuilder();\n        allItems.forEach(item -> sb.append(generateItemString(item) + \"\\n\"));\n        return sb.toString();\n    }\n\n    public abstract String generateItemString(Item item);\n\n    public String generateAllBidsString(Item item) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"All bids:\");\n        item.getAllBids().forEach(bid -> sb.append(\"\\n\"+bid.toString()));\n        return sb.toString();\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Auction System",
    "message": "String literal expressions should be on the left side of an equals comparison.",
    "priority": "error",
    "start_line": "23",
    "end_line": "23",
    "start_column": "28",
    "end_column": "28",
    "rule": {
      "identifier": "EqualsAvoidNull",
      "explanation": "If a string variable may be null, avoid calling .equals(...) on it to compare it to another, non null string. Instead, call the .equals(...) method on the non null string such as in \"Foo\".equals(otherString).",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.auction;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic abstract class Auction {\n    private int nextItem;\n    private boolean closed;\n    private List<Person> bidders;\n    private List<Item> allItems;\n\n    public Auction() {\n        nextItem = 1;\n        closed = false;\n        bidders = new ArrayList<>();\n        allItems = new ArrayList<>();\n    }\n\n    public void addBid(String itemName, String nameOfBidder, long price) {\n        if (itemName.equals(\"\")) {\n            throw new IllegalArgumentException(\"Item name shall not be empty\");\n        }\n        if (price <= 0) {\n            throw new IllegalArgumentException(\"Price has to positive!\");\n        }\n        Person bidder = bidders.stream().filter(person -> person.getName().toLowerCase().equals(nameOfBidder.toLowerCase()))\n                .findAny().orElse(new Person(nameOfBidder));\n        if (!bidders.contains(bidder)) {\n            bidders.add(bidder);\n        }\n        Item item = allItems.stream().filter(item1 -> item1.getName().toLowerCase().equals(itemName.toLowerCase()))\n                .findAny().get();\n        item.addBid(bidder, price);\n    }\n\n    //required because the test wants to create a new item using an integer despite the UML says it shall be a Long\n    public void addBid(String itemName, String nameOfBidder, int price) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        addBid(itemName, nameOfBidder, Long.valueOf(price));\n    }\n\n    public void registerItem(Item item) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        if (item == null) throw new NullPointerException(\"Item should not be null!\");\n        if (allItems.stream().anyMatch(item1 -> item.getName().equals(item1.getName()))) {\n            throw new IllegalArgumentException(\"This item is already in the auction!\");\n        }\n        allItems.add(item);\n    }\n\n    public String closeAuction() {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        closed = true;\n        return generateItemListString();\n    }\n\n    public List<Item> getAllItems() {\n        return allItems;\n    }\n\n    public String generateItemListString() {\n        StringBuilder sb = new StringBuilder();\n        allItems.forEach(item -> sb.append(generateItemString(item) + \"\\n\"));\n        return sb.toString();\n    }\n\n    public abstract String generateItemString(Item item);\n\n    public String generateAllBidsString(Item item) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"All bids:\");\n        item.getAllBids().forEach(bid -> sb.append(\"\\n\"+bid.toString()));\n        return sb.toString();\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Auction System",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "41",
    "end_line": "41",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.auction;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic abstract class Auction {\n    private int nextItem;\n    private boolean closed;\n    private List<Person> bidders;\n    private List<Item> allItems;\n\n    public Auction() {\n        nextItem = 1;\n        closed = false;\n        bidders = new ArrayList<>();\n        allItems = new ArrayList<>();\n    }\n\n    public void addBid(String itemName, String nameOfBidder, long price) {\n        if (itemName.equals(\"\")) {\n            throw new IllegalArgumentException(\"Item name shall not be empty\");\n        }\n        if (price <= 0) {\n            throw new IllegalArgumentException(\"Price has to positive!\");\n        }\n        Person bidder = bidders.stream().filter(person -> person.getName().toLowerCase().equals(nameOfBidder.toLowerCase()))\n                .findAny().orElse(new Person(nameOfBidder));\n        if (!bidders.contains(bidder)) {\n            bidders.add(bidder);\n        }\n        Item item = allItems.stream().filter(item1 -> item1.getName().toLowerCase().equals(itemName.toLowerCase()))\n                .findAny().get();\n        item.addBid(bidder, price);\n    }\n\n    //required because the test wants to create a new item using an integer despite the UML says it shall be a Long\n    public void addBid(String itemName, String nameOfBidder, int price) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        addBid(itemName, nameOfBidder, Long.valueOf(price));\n    }\n\n    public void registerItem(Item item) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        if (item == null) throw new NullPointerException(\"Item should not be null!\");\n        if (allItems.stream().anyMatch(item1 -> item.getName().equals(item1.getName()))) {\n            throw new IllegalArgumentException(\"This item is already in the auction!\");\n        }\n        allItems.add(item);\n    }\n\n    public String closeAuction() {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        closed = true;\n        return generateItemListString();\n    }\n\n    public List<Item> getAllItems() {\n        return allItems;\n    }\n\n    public String generateItemListString() {\n        StringBuilder sb = new StringBuilder();\n        allItems.forEach(item -> sb.append(generateItemString(item) + \"\\n\"));\n        return sb.toString();\n    }\n\n    public abstract String generateItemString(Item item);\n\n    public String generateAllBidsString(Item item) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"All bids:\");\n        item.getAllBids().forEach(bid -> sb.append(\"\\n\"+bid.toString()));\n        return sb.toString();\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Auction System",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "46",
    "end_line": "46",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.auction;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic abstract class Auction {\n    private int nextItem;\n    private boolean closed;\n    private List<Person> bidders;\n    private List<Item> allItems;\n\n    public Auction() {\n        nextItem = 1;\n        closed = false;\n        bidders = new ArrayList<>();\n        allItems = new ArrayList<>();\n    }\n\n    public void addBid(String itemName, String nameOfBidder, long price) {\n        if (itemName.equals(\"\")) {\n            throw new IllegalArgumentException(\"Item name shall not be empty\");\n        }\n        if (price <= 0) {\n            throw new IllegalArgumentException(\"Price has to positive!\");\n        }\n        Person bidder = bidders.stream().filter(person -> person.getName().toLowerCase().equals(nameOfBidder.toLowerCase()))\n                .findAny().orElse(new Person(nameOfBidder));\n        if (!bidders.contains(bidder)) {\n            bidders.add(bidder);\n        }\n        Item item = allItems.stream().filter(item1 -> item1.getName().toLowerCase().equals(itemName.toLowerCase()))\n                .findAny().get();\n        item.addBid(bidder, price);\n    }\n\n    //required because the test wants to create a new item using an integer despite the UML says it shall be a Long\n    public void addBid(String itemName, String nameOfBidder, int price) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        addBid(itemName, nameOfBidder, Long.valueOf(price));\n    }\n\n    public void registerItem(Item item) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        if (item == null) throw new NullPointerException(\"Item should not be null!\");\n        if (allItems.stream().anyMatch(item1 -> item.getName().equals(item1.getName()))) {\n            throw new IllegalArgumentException(\"This item is already in the auction!\");\n        }\n        allItems.add(item);\n    }\n\n    public String closeAuction() {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        closed = true;\n        return generateItemListString();\n    }\n\n    public List<Item> getAllItems() {\n        return allItems;\n    }\n\n    public String generateItemListString() {\n        StringBuilder sb = new StringBuilder();\n        allItems.forEach(item -> sb.append(generateItemString(item) + \"\\n\"));\n        return sb.toString();\n    }\n\n    public abstract String generateItemString(Item item);\n\n    public String generateAllBidsString(Item item) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"All bids:\");\n        item.getAllBids().forEach(bid -> sb.append(\"\\n\"+bid.toString()));\n        return sb.toString();\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Auction System",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "47",
    "end_line": "47",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.auction;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic abstract class Auction {\n    private int nextItem;\n    private boolean closed;\n    private List<Person> bidders;\n    private List<Item> allItems;\n\n    public Auction() {\n        nextItem = 1;\n        closed = false;\n        bidders = new ArrayList<>();\n        allItems = new ArrayList<>();\n    }\n\n    public void addBid(String itemName, String nameOfBidder, long price) {\n        if (itemName.equals(\"\")) {\n            throw new IllegalArgumentException(\"Item name shall not be empty\");\n        }\n        if (price <= 0) {\n            throw new IllegalArgumentException(\"Price has to positive!\");\n        }\n        Person bidder = bidders.stream().filter(person -> person.getName().toLowerCase().equals(nameOfBidder.toLowerCase()))\n                .findAny().orElse(new Person(nameOfBidder));\n        if (!bidders.contains(bidder)) {\n            bidders.add(bidder);\n        }\n        Item item = allItems.stream().filter(item1 -> item1.getName().toLowerCase().equals(itemName.toLowerCase()))\n                .findAny().get();\n        item.addBid(bidder, price);\n    }\n\n    //required because the test wants to create a new item using an integer despite the UML says it shall be a Long\n    public void addBid(String itemName, String nameOfBidder, int price) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        addBid(itemName, nameOfBidder, Long.valueOf(price));\n    }\n\n    public void registerItem(Item item) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        if (item == null) throw new NullPointerException(\"Item should not be null!\");\n        if (allItems.stream().anyMatch(item1 -> item.getName().equals(item1.getName()))) {\n            throw new IllegalArgumentException(\"This item is already in the auction!\");\n        }\n        allItems.add(item);\n    }\n\n    public String closeAuction() {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        closed = true;\n        return generateItemListString();\n    }\n\n    public List<Item> getAllItems() {\n        return allItems;\n    }\n\n    public String generateItemListString() {\n        StringBuilder sb = new StringBuilder();\n        allItems.forEach(item -> sb.append(generateItemString(item) + \"\\n\"));\n        return sb.toString();\n    }\n\n    public abstract String generateItemString(Item item);\n\n    public String generateAllBidsString(Item item) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"All bids:\");\n        item.getAllBids().forEach(bid -> sb.append(\"\\n\"+bid.toString()));\n        return sb.toString();\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Auction System",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "55",
    "end_line": "55",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.auction;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic abstract class Auction {\n    private int nextItem;\n    private boolean closed;\n    private List<Person> bidders;\n    private List<Item> allItems;\n\n    public Auction() {\n        nextItem = 1;\n        closed = false;\n        bidders = new ArrayList<>();\n        allItems = new ArrayList<>();\n    }\n\n    public void addBid(String itemName, String nameOfBidder, long price) {\n        if (itemName.equals(\"\")) {\n            throw new IllegalArgumentException(\"Item name shall not be empty\");\n        }\n        if (price <= 0) {\n            throw new IllegalArgumentException(\"Price has to positive!\");\n        }\n        Person bidder = bidders.stream().filter(person -> person.getName().toLowerCase().equals(nameOfBidder.toLowerCase()))\n                .findAny().orElse(new Person(nameOfBidder));\n        if (!bidders.contains(bidder)) {\n            bidders.add(bidder);\n        }\n        Item item = allItems.stream().filter(item1 -> item1.getName().toLowerCase().equals(itemName.toLowerCase()))\n                .findAny().get();\n        item.addBid(bidder, price);\n    }\n\n    //required because the test wants to create a new item using an integer despite the UML says it shall be a Long\n    public void addBid(String itemName, String nameOfBidder, int price) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        addBid(itemName, nameOfBidder, Long.valueOf(price));\n    }\n\n    public void registerItem(Item item) {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        if (item == null) throw new NullPointerException(\"Item should not be null!\");\n        if (allItems.stream().anyMatch(item1 -> item.getName().equals(item1.getName()))) {\n            throw new IllegalArgumentException(\"This item is already in the auction!\");\n        }\n        allItems.add(item);\n    }\n\n    public String closeAuction() {\n        if (closed) throw new IllegalStateException(\"Auction already closed!\");\n        closed = true;\n        return generateItemListString();\n    }\n\n    public List<Item> getAllItems() {\n        return allItems;\n    }\n\n    public String generateItemListString() {\n        StringBuilder sb = new StringBuilder();\n        allItems.forEach(item -> sb.append(generateItemString(item) + \"\\n\"));\n        return sb.toString();\n    }\n\n    public abstract String generateItemString(Item item);\n\n    public String generateAllBidsString(Item item) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"All bids:\");\n        item.getAllBids().forEach(bid -> sb.append(\"\\n\"+bid.toString()));\n        return sb.toString();\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Auction System",
    "message": "String literal expressions should be on the left side of an equals comparison.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": "24",
    "end_column": "24",
    "rule": {
      "identifier": "EqualsAvoidNull",
      "explanation": "If a string variable may be null, avoid calling .equals(...) on it to compare it to another, non null string. Instead, call the .equals(...) method on the non null string such as in \"Foo\".equals(otherString).",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.auction;\n\nimport java.util.*;\n\npublic class Item {\n    private String name;\n    private String description;\n    private Long minPrice;\n    private List<Bid> allBids;\n    private Bid highestBid;\n\n    public Item(String name, String description, Long minPrice) {\n        if (name == null || description == null) {\n            throw new NullPointerException(\"Arguments should not be null!\");\n        }\n        if (minPrice <= 0) {\n            throw new IllegalArgumentException(\"Price has to be positive!\");\n        }\n        if (name.equals(\"\") || description.equals(\"\")) {\n            throw new IllegalArgumentException(\"Name or description should not be empty!\");\n        }\n        this.name = name;\n        this.description = description;\n        this.minPrice = minPrice;\n        allBids = new ArrayList<>();\n    }\n\n    //required because the test wants to create a new item using an integer despite the UML says it shall be a Long\n    public Item(String name, String description, int minPrice) {\n        this(name, description, Long.valueOf(minPrice));\n    }\n\n    public void addBid(Person bidder, long price) {\n        if (price<=0){\n            throw new IllegalArgumentException(\"Price has to be positive!\");\n        }\n        if (price < minPrice) {\n            return;\n        } else if (highestBid != null) {\n            if (price <= highestBid.getPrice()) {\n                return;\n            }\n        }\n        Bid bid = new Bid(bidder, price);\n        if (highestBid == null || highestBid.getPrice() < price) {\n            highestBid = bid;\n        }\n        allBids.add(bid);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public List<Bid> getAllBids() {\n        return allBids;\n    }\n\n    public Bid getHighestBid() {\n        return highestBid;\n    }\n\n    public String toString() {\n        return String.format(\"%s: %s (minimum bidding price: %d EUR)\", getName(), getDescription(), minPrice);\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Auction System",
    "message": "String literal expressions should be on the left side of an equals comparison.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": "50",
    "end_column": "50",
    "rule": {
      "identifier": "EqualsAvoidNull",
      "explanation": "If a string variable may be null, avoid calling .equals(...) on it to compare it to another, non null string. Instead, call the .equals(...) method on the non null string such as in \"Foo\".equals(otherString).",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.auction;\n\nimport java.util.*;\n\npublic class Item {\n    private String name;\n    private String description;\n    private Long minPrice;\n    private List<Bid> allBids;\n    private Bid highestBid;\n\n    public Item(String name, String description, Long minPrice) {\n        if (name == null || description == null) {\n            throw new NullPointerException(\"Arguments should not be null!\");\n        }\n        if (minPrice <= 0) {\n            throw new IllegalArgumentException(\"Price has to be positive!\");\n        }\n        if (name.equals(\"\") || description.equals(\"\")) {\n            throw new IllegalArgumentException(\"Name or description should not be empty!\");\n        }\n        this.name = name;\n        this.description = description;\n        this.minPrice = minPrice;\n        allBids = new ArrayList<>();\n    }\n\n    //required because the test wants to create a new item using an integer despite the UML says it shall be a Long\n    public Item(String name, String description, int minPrice) {\n        this(name, description, Long.valueOf(minPrice));\n    }\n\n    public void addBid(Person bidder, long price) {\n        if (price<=0){\n            throw new IllegalArgumentException(\"Price has to be positive!\");\n        }\n        if (price < minPrice) {\n            return;\n        } else if (highestBid != null) {\n            if (price <= highestBid.getPrice()) {\n                return;\n            }\n        }\n        Bid bid = new Bid(bidder, price);\n        if (highestBid == null || highestBid.getPrice() < price) {\n            highestBid = bid;\n        }\n        allBids.add(bid);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public List<Bid> getAllBids() {\n        return allBids;\n    }\n\n    public Bid getHighestBid() {\n        return highestBid;\n    }\n\n    public String toString() {\n        return String.format(\"%s: %s (minimum bidding price: %d EUR)\", getName(), getDescription(), minPrice);\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Auction System",
    "message": "String literal expressions should be on the left side of an equals comparison.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "31",
    "end_column": "31",
    "rule": {
      "identifier": "EqualsAvoidNull",
      "explanation": "If a string variable may be null, avoid calling .equals(...) on it to compare it to another, non null string. Instead, call the .equals(...) method on the non null string such as in \"Foo\".equals(otherString).",
      "medic": {
        "name": "Anne",
        "profession": "General Pracitioner"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.auction;\n\npublic class Person {\n    private String name;\n\n    public Person(String name) {\n        if (name == null) {\n            throw new NullPointerException(\"Name is null!\");\n        } else if (name.equals(\"\")) {\n            throw new IllegalArgumentException(\"Name is empty!\");\n        }\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String toString() {\n        return getName();\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Taxi",
    "message": "'4' is a magic number.",
    "priority": "error",
    "start_line": "21",
    "end_line": "21",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.taxi;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Taxi {\n\n    private Human driver;\n    private ArrayList<Human> passengers;\n\n    public Taxi(Human driver) {\n        this.driver = driver;\n        passengers = new ArrayList<>();\n    }\n\n    public String getDriverName() {\n        return driver.toString();\n    }\n\n    public void add(Human passenger) {\n        if (passengers.size() < 4) {\n            passengers.add(passenger);\n            System.out.println(String.format(\"%s gets in.\", passenger.toString()));\n        } else {\n            System.out.println(String.format(\"We are sorry, %s. The taxi is full.\", passenger.toString()));\n        }\n    }\n\n    public Human[] allGetOut(){\n        Human[] formerPassengers = passengers.toArray(new Human[0]);\n        passengers.clear();\n        return formerPassengers;\n    }\n\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        if (passengers.size() == 0 ){\n            builder.append(\"nobody\");\n        }else {\n            Iterator<Human> passengerIterator = passengers.iterator();\n            builder.append(passengerIterator.next());\n            while (passengerIterator.hasNext()){\n                Human iteratedPassenger = passengerIterator.next();\n                if (!passengerIterator.hasNext()){\n                    builder.append(\" and \").append(iteratedPassenger);\n                }else {\n                    builder.append(\", \").append(iteratedPassenger);\n                }\n            }\n        }\n        return String.format(\"This is the taxi of %s. He takes %s along.\", getDriverName(), builder.toString());\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic class Appointee extends Employee {\n    private int dayOfMonth;\n    private int hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (0 >= dayOfMonth || dayOfMonth > 31) throw new IllegalArgumentException(\"Payday is invalid!\");\n        if (hoursPerMonth <= 0) throw new IllegalArgumentException(\"Hours per month has to be positive!\");\n        if (payPerHour <= 0) throw new IllegalArgumentException(\"Payment per hour has to be positive!\");\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int dayOfMonth) {\n        return (dayOfMonth == this.dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return hoursPerMonth * payPerHour;\n    }\n\n    @Override\n    public double calculateDeductions() {\n        double gross = 0;\n        try {\n            gross = calculatePay();\n        } catch (UnpayableEmployeeException e) {\n            e.printStackTrace();\n        }\n        return gross - gross * 0.6;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'31' is a magic number.",
    "priority": "error",
    "start_line": "10",
    "end_line": "10",
    "start_column": "45",
    "end_column": "45",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic class Appointee extends Employee {\n    private int dayOfMonth;\n    private int hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (0 >= dayOfMonth || dayOfMonth > 31) throw new IllegalArgumentException(\"Payday is invalid!\");\n        if (hoursPerMonth <= 0) throw new IllegalArgumentException(\"Hours per month has to be positive!\");\n        if (payPerHour <= 0) throw new IllegalArgumentException(\"Payment per hour has to be positive!\");\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int dayOfMonth) {\n        return (dayOfMonth == this.dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return hoursPerMonth * payPerHour;\n    }\n\n    @Override\n    public double calculateDeductions() {\n        double gross = 0;\n        try {\n            gross = calculatePay();\n        } catch (UnpayableEmployeeException e) {\n            e.printStackTrace();\n        }\n        return gross - gross * 0.6;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "11",
    "end_line": "11",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic class Appointee extends Employee {\n    private int dayOfMonth;\n    private int hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (0 >= dayOfMonth || dayOfMonth > 31) throw new IllegalArgumentException(\"Payday is invalid!\");\n        if (hoursPerMonth <= 0) throw new IllegalArgumentException(\"Hours per month has to be positive!\");\n        if (payPerHour <= 0) throw new IllegalArgumentException(\"Payment per hour has to be positive!\");\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int dayOfMonth) {\n        return (dayOfMonth == this.dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return hoursPerMonth * payPerHour;\n    }\n\n    @Override\n    public double calculateDeductions() {\n        double gross = 0;\n        try {\n            gross = calculatePay();\n        } catch (UnpayableEmployeeException e) {\n            e.printStackTrace();\n        }\n        return gross - gross * 0.6;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "12",
    "end_line": "12",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic class Appointee extends Employee {\n    private int dayOfMonth;\n    private int hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (0 >= dayOfMonth || dayOfMonth > 31) throw new IllegalArgumentException(\"Payday is invalid!\");\n        if (hoursPerMonth <= 0) throw new IllegalArgumentException(\"Hours per month has to be positive!\");\n        if (payPerHour <= 0) throw new IllegalArgumentException(\"Payment per hour has to be positive!\");\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int dayOfMonth) {\n        return (dayOfMonth == this.dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return hoursPerMonth * payPerHour;\n    }\n\n    @Override\n    public double calculateDeductions() {\n        double gross = 0;\n        try {\n            gross = calculatePay();\n        } catch (UnpayableEmployeeException e) {\n            e.printStackTrace();\n        }\n        return gross - gross * 0.6;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'dayOfMonth' hides a field.",
    "priority": "error",
    "start_line": "19",
    "end_line": "19",
    "start_column": "33",
    "end_column": "33",
    "rule": {
      "identifier": "HiddenField",
      "explanation": "Local variables should not shadow a field that is defined in the same class.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic class Appointee extends Employee {\n    private int dayOfMonth;\n    private int hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (0 >= dayOfMonth || dayOfMonth > 31) throw new IllegalArgumentException(\"Payday is invalid!\");\n        if (hoursPerMonth <= 0) throw new IllegalArgumentException(\"Hours per month has to be positive!\");\n        if (payPerHour <= 0) throw new IllegalArgumentException(\"Payment per hour has to be positive!\");\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int dayOfMonth) {\n        return (dayOfMonth == this.dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return hoursPerMonth * payPerHour;\n    }\n\n    @Override\n    public double calculateDeductions() {\n        double gross = 0;\n        try {\n            gross = calculatePay();\n        } catch (UnpayableEmployeeException e) {\n            e.printStackTrace();\n        }\n        return gross - gross * 0.6;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'0.6' is a magic number.",
    "priority": "error",
    "start_line": "36",
    "end_line": "36",
    "start_column": "32",
    "end_column": "32",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic class Appointee extends Employee {\n    private int dayOfMonth;\n    private int hoursPerMonth;\n    private double payPerHour;\n\n    public Appointee(String id, int dayOfMonth, int hoursPerMonth, double payPerHour) {\n        super(id);\n        if (0 >= dayOfMonth || dayOfMonth > 31) throw new IllegalArgumentException(\"Payday is invalid!\");\n        if (hoursPerMonth <= 0) throw new IllegalArgumentException(\"Hours per month has to be positive!\");\n        if (payPerHour <= 0) throw new IllegalArgumentException(\"Payment per hour has to be positive!\");\n        this.dayOfMonth = dayOfMonth;\n        this.hoursPerMonth = hoursPerMonth;\n        this.payPerHour = payPerHour;\n    }\n\n    @Override\n    public boolean isPayday(int dayOfMonth) {\n        return (dayOfMonth == this.dayOfMonth);\n    }\n\n    @Override\n    public double calculatePay() throws UnpayableEmployeeException {\n        return hoursPerMonth * payPerHour;\n    }\n\n    @Override\n    public double calculateDeductions() {\n        double gross = 0;\n        try {\n            gross = calculatePay();\n        } catch (UnpayableEmployeeException e) {\n            e.printStackTrace();\n        }\n        return gross - gross * 0.6;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "Name 'Employee' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic abstract class Employee {\n    private String id;\n\n    public Employee(String id) {\n        if (id==null) throw new NullPointerException(\"ID shall not be null!\");\n        if (id.isEmpty()) throw new IllegalArgumentException(\"ID shall not be empty!\");\n        this.id = id;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public abstract boolean isPayday(int dayOfMonth);\n\n    public abstract double calculatePay() throws UnpayableEmployeeException;\n\n    public abstract double calculateDeductions();\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "7",
    "end_line": "7",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic abstract class Employee {\n    private String id;\n\n    public Employee(String id) {\n        if (id==null) throw new NullPointerException(\"ID shall not be null!\");\n        if (id.isEmpty()) throw new IllegalArgumentException(\"ID shall not be empty!\");\n        this.id = id;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public abstract boolean isPayday(int dayOfMonth);\n\n    public abstract double calculatePay() throws UnpayableEmployeeException;\n\n    public abstract double calculateDeductions();\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic abstract class Employee {\n    private String id;\n\n    public Employee(String id) {\n        if (id==null) throw new NullPointerException(\"ID shall not be null!\");\n        if (id.isEmpty()) throw new IllegalArgumentException(\"ID shall not be empty!\");\n        this.id = id;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public abstract boolean isPayday(int dayOfMonth);\n\n    public abstract double calculatePay() throws UnpayableEmployeeException;\n\n    public abstract double calculateDeductions();\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic class Payroll {\n    private int payday;\n    private PayrollDisposition disposition;\n\n    public Payroll(PayrollDisposition disposition, int payday) {\n        if (disposition == null) throw new NullPointerException(\"Disposition shall not be null!\");\n        if (payday < 1 || payday > 31) throw new IllegalArgumentException(\"Payday is not in allowed range!\");\n        this.payday = payday;\n        this.disposition = disposition;\n    }\n\n    public void doPayroll(PayrollDB db) {\n        db.getEmployeeList().parallelStream().filter(employee -> employee instanceof Appointee)\n                .filter(employee -> employee.isPayday(payday)).forEach(employee -> {\n            try {\n                disposition.sendPayment(employee, employee.calculatePay() - employee.calculateDeductions());\n            } catch (UnpayableEmployeeException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic class Payroll {\n    private int payday;\n    private PayrollDisposition disposition;\n\n    public Payroll(PayrollDisposition disposition, int payday) {\n        if (disposition == null) throw new NullPointerException(\"Disposition shall not be null!\");\n        if (payday < 1 || payday > 31) throw new IllegalArgumentException(\"Payday is not in allowed range!\");\n        this.payday = payday;\n        this.disposition = disposition;\n    }\n\n    public void doPayroll(PayrollDB db) {\n        db.getEmployeeList().parallelStream().filter(employee -> employee instanceof Appointee)\n                .filter(employee -> employee.isPayday(payday)).forEach(employee -> {\n            try {\n                disposition.sendPayment(employee, employee.calculatePay() - employee.calculateDeductions());\n            } catch (UnpayableEmployeeException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'31' is a magic number.",
    "priority": "error",
    "start_line": "9",
    "end_line": "9",
    "start_column": "36",
    "end_column": "36",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic class Payroll {\n    private int payday;\n    private PayrollDisposition disposition;\n\n    public Payroll(PayrollDisposition disposition, int payday) {\n        if (disposition == null) throw new NullPointerException(\"Disposition shall not be null!\");\n        if (payday < 1 || payday > 31) throw new IllegalArgumentException(\"Payday is not in allowed range!\");\n        this.payday = payday;\n        this.disposition = disposition;\n    }\n\n    public void doPayroll(PayrollDB db) {\n        db.getEmployeeList().parallelStream().filter(employee -> employee instanceof Appointee)\n                .filter(employee -> employee.isPayday(payday)).forEach(employee -> {\n            try {\n                disposition.sendPayment(employee, employee.calculatePay() - employee.calculateDeductions());\n            } catch (UnpayableEmployeeException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "Abbreviation in name 'PayrollDB' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "5",
    "end_line": "5",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\nimport java.util.List;\n\npublic interface PayrollDB {\n    public List<Employee> getEmployeeList();\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\nimport java.util.List;\n\npublic interface PayrollDB {\n    public List<Employee> getEmployeeList();\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\npublic interface PayrollDisposition {\n    public void sendPayment(Employee employee, double payment);\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "15",
    "end_line": "15",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PayrollDispositionImpl implements PayrollDisposition {\n    private Map<Employee, Double> payments;\n\n    public PayrollDispositionImpl() {\n        this.payments = new HashMap<>();\n    }\n\n    @Override\n    public void sendPayment(Employee employee, double payment) {\n        if (employee == null) throw new NullPointerException(\"Employee shall not be null!\");\n        if (payment <= 0) throw new IllegalArgumentException(\"Payment has to be positive!\");\n        payments.put(employee, payment);\n    }\n\n    public double getTotal() {\n        double total = 0;\n        for (Double payment : payments.values()) {\n            total += payment;\n        }\n        return total;\n    }\n\n    public double getAverage() {\n        if (payments.size() == 0) {\n            return 0;\n        } else {\n            return getTotal() / payments.size();\n        }\n    }\n\n    public Map<Employee, Double> getPayments() {\n        return payments;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Payroll",
    "message": "'if' construct must use '{}'s.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.payroll;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PayrollDispositionImpl implements PayrollDisposition {\n    private Map<Employee, Double> payments;\n\n    public PayrollDispositionImpl() {\n        this.payments = new HashMap<>();\n    }\n\n    @Override\n    public void sendPayment(Employee employee, double payment) {\n        if (employee == null) throw new NullPointerException(\"Employee shall not be null!\");\n        if (payment <= 0) throw new IllegalArgumentException(\"Payment has to be positive!\");\n        payments.put(employee, payment);\n    }\n\n    public double getTotal() {\n        double total = 0;\n        for (Double payment : payments.values()) {\n            total += payment;\n        }\n        return total;\n    }\n\n    public double getAverage() {\n        if (payments.size() == 0) {\n            return 0;\n        } else {\n            return getTotal() / payments.size();\n        }\n    }\n\n    public Map<Employee, Double> getPayments() {\n        return payments;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Pricing",
    "message": "'else' construct must use '{}'s.",
    "priority": "error",
    "start_line": "25",
    "end_line": "25",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "NeedBraces",
      "explanation": "Certain control flow elements, for which it is optional to use curly braces, should always use curly braces. Nesting more than one statement in control flow elements without braces will only influence the first one. Not using curly braces is error prone.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.pricing;\n\npublic class AbsoluteDiscountPricing implements ISalePricing {\n\n    private long discount;\n    private long threshold;\n\n    public AbsoluteDiscountPricing(long discount, long threshold) {\n        if(discount<0){\n            throw new IllegalArgumentException(\"Discount is negative!\");\n        }\n        if (threshold<0){\n            throw new IllegalArgumentException(\"Threshold is negative!\");\n        }\n        this.discount = discount;\n        this.threshold = threshold;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        if(sale.getPreDiscountTotal()-discount>threshold){\n            return sale.getPreDiscountTotal()-discount;\n        }else if(threshold<sale.getPreDiscountTotal()){\n            return threshold;\n        }else return sale.getPreDiscountTotal();\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Pricing",
    "message": "Name 'ComplexPricing' must match pattern '^Abstract.+$'.",
    "priority": "error",
    "start_line": "6",
    "end_line": "6",
    "start_column": "1",
    "end_column": "1",
    "rule": {
      "identifier": "AbstractClassName",
      "explanation": "Abstract classes should conform to naming conventions, such as being named \"Abstract...\". Vice versa, classes named in this way should include the abstract modifier.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.pricing;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic abstract class ComplexPricing implements ISalePricing{\n    private List<ISalePricing> pricings = new ArrayList<>();\n\n    public void add(ISalePricing pricing){\n        pricings.add(pricing);\n    }\n\n    public List<ISalePricing> getPricings() {\n        return pricings;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        return 0;\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Pricing",
    "message": "Abbreviation in name 'ISalePricing' must contain no more than '1' consecutive capital letters.",
    "priority": "error",
    "start_line": "3",
    "end_line": "3",
    "start_column": null,
    "end_column": null,
    "rule": {
      "identifier": "AbbreviationAsWordInName",
      "explanation": "If any abbreviation (consecutive capital letters) is used in a specification, it should not exceed a certain length, to make the specification more readable.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.pricing;\n\npublic interface ISalePricing {\n    public long getTotal(Sale sale);\n}\n"
  },
  {
    "user": "2",
    "task": "Pricing",
    "message": "Redundant 'public' modifier.",
    "priority": "error",
    "start_line": "4",
    "end_line": "4",
    "start_column": "5",
    "end_column": "5",
    "rule": {
      "identifier": "RedundantModifier",
      "explanation": "In certain contexts, modifiers should be not explicitly specified, because they are already applied by the programming language. For example, interface definitions should not contain the public and abstract modifiers for method declarations.",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.pricing;\n\npublic interface ISalePricing {\n    public long getTotal(Sale sale);\n}\n"
  },
  {
    "user": "2",
    "task": "Pricing",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "8",
    "end_line": "8",
    "start_column": "40",
    "end_column": "40",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.pricing;\n\npublic class PercentageDiscountPricing implements ISalePricing {\n\n    private double percentage;\n\n    public PercentageDiscountPricing(double percentage) {\n        if (percentage<0 || percentage>100){\n            throw new IllegalArgumentException(\"Percentage is is not within range!\");\n        }\n        this.percentage = percentage;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        return sale.getPreDiscountTotal()-(long)(sale.getPreDiscountTotal()/100*percentage);\n    }\n}\n"
  },
  {
    "user": "2",
    "task": "Pricing",
    "message": "'100' is a magic number.",
    "priority": "error",
    "start_line": "16",
    "end_line": "16",
    "start_column": "77",
    "end_column": "77",
    "rule": {
      "identifier": "MagicNumber",
      "explanation": "Numeric literals (except -1, 0, 1 and 2) should be defined as constants, i.e. as a variable or field with the final modifier such as \"static final int SECONDS_PER_DAY = 24 * 60 * 60\".",
      "medic": {
        "name": "Marc",
        "profession": "Plastic Surgeon"
      }
    },
    "file_contents": "package de.paktosan.university.swt.exam.pricing;\n\npublic class PercentageDiscountPricing implements ISalePricing {\n\n    private double percentage;\n\n    public PercentageDiscountPricing(double percentage) {\n        if (percentage<0 || percentage>100){\n            throw new IllegalArgumentException(\"Percentage is is not within range!\");\n        }\n        this.percentage = percentage;\n    }\n\n    @Override\n    public long getTotal(Sale sale) {\n        return sale.getPreDiscountTotal()-(long)(sale.getPreDiscountTotal()/100*percentage);\n    }\n}\n"
  }
]